<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Debate Competition</title>
      <link href="/2025/05/06/Debate_Competition/"/>
      <url>/2025/05/06/Debate_Competition/</url>
      
        <content type="html"><![CDATA[<p>📢 博主私藏辩论赛精选合集：神级现场与宝藏冷门一网打尽！<br>整理了个人心目中值得N刷的辩论赛录播清单！既有被全网封神的封神之战，也有初看平淡细品封神的宝藏场次，点击即可跳转食用</p><p>（重要的事情说三遍：<strong>排名不分先后！不分先后！不分先后！</strong>）</p><p>👉 食用指南：</p><ul><li><p>弹幕生存法则<br>B站链接建议关闭弹幕护体！尤其哲理类辩题，满屏的”666””开杠”可能打断你的颅内高潮。当然，搞笑场次开着弹幕体验更佳~</p></li><li><p>链接急救通道<br>若遇失效链接，欢迎<strong>随时</strong>拍打（私信）博主！</p></li></ul><p>💡 彩蛋预告：有时间会为每场辩论写下推荐词（挖坑不躺平，填坑看缘分！）</p><p>❤️ <strong>欢迎评论区反向安利你心中的辩论赛TOP！</strong>说不定下次更新就有你的宝藏推荐~</p><p><a href="https://www.bilibili.com/video/BV1sA411R7ca">决定相伴一生的爱侣，要不要一起打上永远爱对方的“思想钢印”？</a></p><p><a href="https://www.youtube.com/watch?v=trOfoGi_lPc">人们可以自由买卖生命时间，你支持吗？</a></p><p><a href="https://www.bilibili.com/video/BV1W7411B74e">如果你有超能力，可以让你爱的人也爱你，你要不要使用这项超能力？</a></p><p><a href="https://www.bilibili.com/video/BV1LU4y1J7Wi">熬夜是现代人的病&#x2F;药？</a></p><p><a href="https://www.bilibili.com/video/BV1tV411W7LJ">故事的结局重不重要？</a></p><p><a href="https://www.bilibili.com/video/BV1uo4y1f7Ba">内卷是个真问题&#x2F;假问题？</a></p><p><a href="https://www.bilibili.com/video/BV17Y411R7Ze">AI绘画是&#x2F;不是艺术？</a></p><p><a href="https://www.youtube.com/watch?v=CtuSP49QlEQ">工作是钱还是爱好更重要？</a></p><p><a href="https://www.youtube.com/watch?v=92i6lT4IDV4">如果有个按钮可以知道爱人有多爱你你会按嘛？</a></p><p><a href="https://www.bilibili.com/video/BV1Va4y1A7ST">要不要踏上一段注定无法回头的伟大冒险？</a></p><p><a href="https://www.youtube.com/watch?v=suZ2J145qR8">情侣之间吵架应该谁错谁道歉还是男生先道歉？</a></p><p><a href="https://www.youtube.com/watch?v=ykCP2HOGEr8&list=PLdbzRdDJq2MwLSjifhafBLdbuY3yJaSrw&index=22">能者就应该多劳吗？</a></p><p><a href="https://www.youtube.com/watch?v=A5CUR9DxC4o&list=PLdbzRdDJq2MwLSjifhafBLdbuY3yJaSrw&index=23">如果你能看到别人剩余的生命你会愿意选择告诉TA嘛？</a></p><p><a href="https://www.youtube.com/watch?v=3i-gMoAArPU">终其一生只是个平凡人你后悔吗？</a></p><p><a href="https://www.bilibili.com/video/BV1AfVizdENX">“典孝急乐蚌麻”是语言的进步还是退步？</a></p>]]></content>
      
      
      <categories>
          
          <category> recommendation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 辩论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Compiler Principle</title>
      <link href="/2025/05/06/Compiler_Principle/"/>
      <url>/2025/05/06/Compiler_Principle/</url>
      
        <content type="html"><![CDATA[<p>机器语言 汇编语言 高级语言</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Computer Organization</title>
      <link href="/2025/05/06/Principle_of_Computer_Organization/"/>
      <url>/2025/05/06/Principle_of_Computer_Organization/</url>
      
        <content type="html"><![CDATA[<h2 id="RISC-vs-CISC"><a href="#RISC-vs-CISC" class="headerlink" title="RISC vs CISC"></a>RISC vs CISC</h2><h3 id="一、RISC-架构及其主流操作系统"><a href="#一、RISC-架构及其主流操作系统" class="headerlink" title="一、RISC 架构及其主流操作系统"></a><strong>一、RISC 架构及其主流操作系统</strong></h3><p><strong>RISC</strong> 架构的核心特点是指令集精简，主要用于嵌入式设备、移动设备和高性能计算领域。以下是 RISC 架构的主要类别及其对应的操作系统。</p><h4 id="1-ARM（Advanced-RISC-Machine）"><a href="#1-ARM（Advanced-RISC-Machine）" class="headerlink" title="1. ARM（Advanced RISC Machine）"></a><strong>1. ARM（Advanced RISC Machine）</strong></h4><ul><li><strong>应用场景</strong>：手机、平板、嵌入式设备、树莓派、高性能计算（如 AWS Graviton 服务器）。</li><li>主流操作系统：<ul><li>移动设备：<ul><li><strong>Android</strong>：大多数 Android 设备运行在 ARM 架构上。</li><li><strong>iOS</strong>：苹果的 iPhone 和 iPad 使用基于 ARM 的 iOS。</li></ul></li><li>桌面&#x2F;服务器：<ul><li><strong>Windows on ARM</strong>：微软推出的 ARM 专用版本（如 Surface Pro X）。</li><li><strong>macOS（Apple Silicon）</strong>：适配苹果自研 ARM 芯片（M1&#x2F;M2 系列）。</li><li>Linux：<ul><li>Ubuntu、Debian、CentOS 等，广泛适配 ARM 设备。</li><li>树莓派官方系统（Raspberry Pi OS，基于 Debian）。</li></ul></li><li><strong>FreeBSD</strong>：支持 ARM 和 ARM64。</li></ul></li><li>嵌入式设备：<ul><li><strong>RTOS（实时操作系统）</strong>：如 FreeRTOS、Zephyr RTOS。</li></ul></li></ul></li></ul><hr><h4 id="2-RISC-V"><a href="#2-RISC-V" class="headerlink" title="2. RISC-V"></a><strong>2. RISC-V</strong></h4><ul><li><strong>应用场景</strong>：嵌入式、科研、高性能计算，未来可能挑战 ARM。</li><li>主流操作系统：<ul><li>Linux：<ul><li>Ubuntu、Debian、Fedora 等社区已推出 RISC-V 支持版本。</li><li>OpenSUSE Leap 和 Rocky Linux 也支持 RISC-V。</li></ul></li><li><strong>FreeBSD</strong>：支持 RISC-V。</li><li>专用系统：<ul><li><strong>RTOS</strong>：如 Zephyr RTOS 和 FreeRTOS。</li><li><strong>Berkeley Boot Loader</strong> (bbl)：用于研究和开发。</li><li><strong>OpenEmbedded&#x2F;Yocto</strong>：为嵌入式设备开发的系统。</li></ul></li></ul></li></ul><hr><h4 id="3-MIPS"><a href="#3-MIPS" class="headerlink" title="3. MIPS"></a><strong>3. MIPS</strong></h4><ul><li><strong>应用场景</strong>：嵌入式设备、网络设备（如路由器），曾用于工作站和游戏机。</li><li>主流操作系统：<ul><li>Linux：<ul><li>Debian、OpenWRT（路由器系统）。</li><li>Gentoo 和 Alpine Linux 等轻量级发行版。</li></ul></li><li><strong>FreeBSD</strong>：支持 MIPS 架构。</li><li>专用系统：<ul><li>嵌入式系统：如 VxWorks 和 RTEMS。</li><li>游戏机系统：Sony PlayStation 1 和 2 的操作系统（基于 MIPS）。</li></ul></li></ul></li></ul><hr><h4 id="4-SPARC（Scalable-Processor-Architecture）"><a href="#4-SPARC（Scalable-Processor-Architecture）" class="headerlink" title="4. SPARC（Scalable Processor Architecture）"></a><strong>4. SPARC（Scalable Processor Architecture）</strong></h4><ul><li><strong>应用场景</strong>：高性能计算、服务器（由 Sun Microsystems 开发）。</li><li>主流操作系统：<ul><li><strong>Solaris</strong>：由 Sun Microsystems 开发的专属系统。</li><li>Linux：<ul><li>Debian 和 Ubuntu 支持 SPARC 架构。</li></ul></li><li><strong>FreeBSD</strong>：支持 SPARC。</li></ul></li></ul><hr><h4 id="5-PowerPC（Performance-Optimization-With-Enhanced-RISC-–-Performance-Computing）"><a href="#5-PowerPC（Performance-Optimization-With-Enhanced-RISC-–-Performance-Computing）" class="headerlink" title="5. PowerPC（Performance Optimization With Enhanced RISC – Performance Computing）"></a><strong>5. PowerPC（Performance Optimization With Enhanced RISC – Performance Computing）</strong></h4><ul><li><strong>应用场景</strong>：嵌入式设备、老款苹果电脑、服务器、高性能计算。</li><li>主流操作系统：<ul><li>Linux：<ul><li>Debian、Ubuntu 和 Fedora 提供 PowerPC 支持。</li></ul></li><li><strong>AIX</strong>：IBM 为其 Power 系列服务器开发的操作系统。</li><li><strong>Mac OS</strong>（历史支持）：用于苹果使用 PowerPC 芯片的 Mac（20 世纪 90 年代至 2006 年）。</li></ul></li></ul><hr><h3 id="二、CISC-架构及其主流操作系统"><a href="#二、CISC-架构及其主流操作系统" class="headerlink" title="二、CISC 架构及其主流操作系统"></a><strong>二、CISC 架构及其主流操作系统</strong></h3><p><strong>CISC</strong> 架构的特点是指令集复杂，通常用于桌面计算机和服务器。</p><h4 id="1-x86（32位）-x86-64（64位）"><a href="#1-x86（32位）-x86-64（64位）" class="headerlink" title="1. x86（32位）&#x2F;x86-64（64位）"></a><strong>1. x86（32位）&#x2F;x86-64（64位）</strong></h4><ul><li><strong>应用场景</strong>：桌面电脑、笔记本电脑、服务器。</li><li>主流操作系统：<ul><li>桌面&#x2F;服务器：<ul><li><strong>Windows</strong>：所有现代 Windows 系统（Windows 10、11 等）以 x86&#x2F;x86-64 为核心。</li><li>Linux：<ul><li>支持所有主流发行版：Ubuntu、Debian、Fedora、CentOS、Arch Linux 等。</li></ul></li><li><strong>macOS</strong>（历史支持）：苹果在 2006-2020 年之间使用 x86 架构芯片。</li><li><strong>FreeBSD</strong>：对 x86 架构的支持非常全面。</li></ul></li><li>虚拟化和容器化：<ul><li>ESXi（VMware）、Proxmox、XenServer 等虚拟化工具非常依赖 x86 架构。</li></ul></li></ul></li></ul><hr><h4 id="2-Itanium（Intel-IA-64）"><a href="#2-Itanium（Intel-IA-64）" class="headerlink" title="2. Itanium（Intel IA-64）"></a><strong>2. Itanium（Intel IA-64）</strong></h4><ul><li><strong>应用场景</strong>：高端服务器（被 x86-64 替代）。</li><li>主流操作系统：<ul><li><strong>Linux</strong>：Red Hat Enterprise Linux（RHEL）、SUSE Linux Enterprise Server（SLES）。</li><li><strong>Windows Server</strong>：微软曾为 Itanium 提供支持，但已停止开发。</li><li><strong>HP-UX</strong>：惠普为其 Itanium 服务器开发的专属操作系统。</li></ul></li></ul><hr><h4 id="3-IBM-Z-系列（大型机架构）"><a href="#3-IBM-Z-系列（大型机架构）" class="headerlink" title="3. IBM Z 系列（大型机架构）"></a><strong>3. IBM Z 系列（大型机架构）</strong></h4><ul><li><strong>应用场景</strong>：银行、金融、高可靠性事务处理。</li><li>主流操作系统：<ul><li><strong>z&#x2F;OS</strong>：IBM 专属大型机操作系统。</li><li>Linux：<ul><li>SUSE Linux Enterprise Server 和 Red Hat Enterprise Linux 提供对 IBM Z 的支持。</li></ul></li><li><strong>UNIX</strong>：如 AIX。</li></ul></li></ul><hr><h3 id="三、汇总：RISC-和-CISC-架构上的主流操作系统对比"><a href="#三、汇总：RISC-和-CISC-架构上的主流操作系统对比" class="headerlink" title="三、汇总：RISC 和 CISC 架构上的主流操作系统对比"></a><strong>三、汇总：RISC 和 CISC 架构上的主流操作系统对比</strong></h3><table><thead><tr><th><strong>架构</strong></th><th><strong>类型</strong></th><th><strong>主流操作系统</strong></th></tr></thead><tbody><tr><td><strong>ARM</strong></td><td>RISC</td><td>Android、iOS、Windows on ARM、macOS（Apple Silicon）、Linux（Ubuntu、Debian、树莓派 OS）</td></tr><tr><td><strong>RISC-V</strong></td><td>RISC</td><td>Linux（Ubuntu、Debian、Fedora）、FreeBSD、RTOS（FreeRTOS、Zephyr）</td></tr><tr><td><strong>MIPS</strong></td><td>RISC</td><td>Linux（OpenWRT、Debian）、FreeBSD、RTOS（VxWorks）</td></tr><tr><td><strong>SPARC</strong></td><td>RISC</td><td>Solaris、Linux（Debian、Ubuntu）、FreeBSD</td></tr><tr><td><strong>PowerPC</strong></td><td>RISC</td><td>Linux（Debian、Ubuntu）、AIX、（历史上）Mac OS</td></tr><tr><td><strong>x86&#x2F;x86-64</strong></td><td>CISC</td><td>Windows、Linux（Ubuntu、CentOS、Fedora 等）、macOS（2006-2020）、FreeBSD</td></tr><tr><td><strong>Itanium</strong></td><td>CISC</td><td>Linux（RHEL、SLES）、Windows Server（历史支持）、HP-UX</td></tr><tr><td><strong>IBM Z</strong></td><td>CISC</td><td>z&#x2F;OS、Linux（SLES、RHEL）、AIX</td></tr></tbody></table><ol><li>RISC 架构：<ul><li>适用于低功耗、高效率场景，主流架构包括 ARM 和 RISC-V。</li><li>主要操作系统为 Linux 和嵌入式专用 RTOS，桌面和移动设备上也有 macOS 和 Windows 支持。</li></ul></li><li>CISC 架构：<ul><li>适用于复杂计算和通用计算场景，主流架构为 x86 和 x86-64。</li><li>主流操作系统为 Windows 和 Linux，服务器领域广泛使用。</li></ul></li></ol><p>未来，<strong>RISC-V</strong> 和 <strong>ARM</strong> 的发展可能会进一步蚕食传统 <strong>CISC</strong> 的市场份额。</p><h2 id="这些架构确定后可更改嘛"><a href="#这些架构确定后可更改嘛" class="headerlink" title="这些架构确定后可更改嘛"></a>这些架构确定后可更改嘛</h2><p>不同的架构（如 <strong>RISC</strong>、<strong>CISC</strong>、<strong>ARM</strong>、<strong>x86</strong> 等）在芯片制造时就已经决定了，后续通常无法更改。这是因为架构直接定义了芯片的<strong>指令集（ISA, Instruction Set Architecture）</strong>，而指令集是处理器执行所有指令的基础。</p><hr><h3 id="一、架构是芯片制造时决定的"><a href="#一、架构是芯片制造时决定的" class="headerlink" title="一、架构是芯片制造时决定的"></a><strong>一、架构是芯片制造时决定的</strong></h3><ol><li><strong>指令集架构（ISA）决定处理器的设计</strong>：<ul><li><strong>指令集架构（ISA）</strong> 是一种“契约”，定义了处理器能够识别和执行的指令（例如加法、存储、跳转等基本操作）。</li><li>芯片设计时，制造商会根据指定的架构（如 ARM、x86 或 RISC-V）设计硬件电路，包括：<ul><li><strong>指令解码单元</strong>：负责解释机器代码。</li><li><strong>寄存器</strong>：用于存储数据。</li><li><strong>流水线与执行单元</strong>：执行指令。</li></ul></li><li>因此，从设计电路到制造晶圆的过程中，芯片就已经确定了支持的架构。</li></ul></li><li><strong>硬件实现与架构绑定</strong>：<ul><li>架构是逻辑设计，而硬件实现（微架构）是用实际的晶体管和电路来实现架构规范。</li><li>一旦芯片被制造完成，其硬件逻辑电路和指令解码电路就是固定的，只能执行特定架构的指令。</li></ul></li><li><strong>芯片设计的定制性</strong>：<ul><li>不同架构的芯片设计有很大的差异。例如：<ul><li><strong>ARM</strong>：以低功耗为核心，广泛应用于移动设备。</li><li><strong>x86</strong>：以复杂指令和高性能为主，普遍用于桌面计算机和服务器。</li><li><strong>RISC-V</strong>：开源架构，允许定制扩展指令集。</li></ul></li><li>在设计阶段，芯片制造商会根据目标应用场景选择架构，并设计适配的硬件电路。一旦流片（芯片制造的关键阶段）完成，架构就无法更改。</li></ul></li></ol><hr><h3 id="二、后续为什么不能更改架构？"><a href="#二、后续为什么不能更改架构？" class="headerlink" title="二、后续为什么不能更改架构？"></a><strong>二、后续为什么不能更改架构？</strong></h3><ol><li><strong>硬件逻辑固定</strong>：<ul><li>芯片的指令解码器、电路设计、寄存器文件和执行单元完全基于架构设计。如果尝试运行不兼容的指令集，芯片根本无法解码或执行这些指令，因为硬件没有对应的逻辑。</li></ul></li><li><strong>架构与软件生态的绑定</strong>：<ul><li>软件是针对特定架构开发的。例如，x86 的程序使用 CISC 指令，而 ARM 的程序使用 RISC 指令。如果架构改变，原有的软件将无法运行。</li><li>虽然可以通过软件模拟器（如 QEMU）在不同架构上运行不兼容的软件，但这会显著降低性能。</li></ul></li><li><strong>架构的专用性</strong>：<ul><li>不同架构的芯片在设计时针对特定场景进行了优化。例如 ARM 专注低功耗设计，而 x86 专注通用计算性能。这种硬件优化是物理层面的，无法通过软件或固件更改。</li></ul></li></ol><hr><h3 id="三、是否有任何方式改变架构？"><a href="#三、是否有任何方式改变架构？" class="headerlink" title="三、是否有任何方式改变架构？"></a><strong>三、是否有任何方式改变架构？</strong></h3><p>虽然一般情况下芯片的架构无法更改，但以下两种方式可以实现一定程度的灵活性：</p><h4 id="1-使用指令集仿真-翻译"><a href="#1-使用指令集仿真-翻译" class="headerlink" title="1. 使用指令集仿真&#x2F;翻译"></a><strong>1. 使用指令集仿真&#x2F;翻译</strong></h4><ul><li>通过软件或硬件模拟一种架构上的指令集，在另一种架构上运行。例如：<ul><li><strong>Rosetta 2</strong>：苹果在过渡到 ARM 架构（M1 芯片）时，使用 Rosetta 2 模拟器让 x86 应用程序可以在 ARM 芯片上运行。</li><li><strong>QEMU</strong>：开源模拟器，可以在 ARM 芯片上运行 x86 程序，或在 RISC-V 上运行其他架构的软件。</li><li><strong>Transmeta</strong>：曾经设计了一种特殊的芯片，能够通过动态二进制翻译运行不同架构的软件。</li></ul></li><li><strong>缺点</strong>：<ul><li>模拟和翻译会增加性能开销，通常比原生运行慢得多。</li><li>仿真无法改变芯片本身的硬件架构，只是通过软件适配。</li></ul></li></ul><h4 id="2-可重配置硬件（如-FPGA）"><a href="#2-可重配置硬件（如-FPGA）" class="headerlink" title="2. 可重配置硬件（如 FPGA）"></a><strong>2. 可重配置硬件（如 FPGA）</strong></h4><ul><li><strong>FPGA（Field-Programmable Gate Array）</strong> 是一种可编程芯片，可以通过配置文件动态改变其硬件逻辑。</li><li>使用 FPGA 可以模拟不同架构的处理器，例如通过加载不同的配置文件让 FPGA 工作在 x86、ARM 或 RISC-V 模式。</li><li>缺点：<ul><li>FPGA 的性能和能效远低于专用芯片（ASIC）。</li><li>FPGA 主要用于科研和原型设计，实际应用中不常见。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>书评特辑·第四期</title>
      <link href="/2025/04/29/litchi/"/>
      <url>/2025/04/29/litchi/</url>
      
        <content type="html"><![CDATA[<h2 id="《长安的荔枝》：一骑红尘照见古今苍生泪"><a href="#《长安的荔枝》：一骑红尘照见古今苍生泪" class="headerlink" title="《长安的荔枝》：一骑红尘照见古今苍生泪"></a>《长安的荔枝》：一骑红尘照见古今苍生泪</h2><p>岭南的荔枝在史册的墨迹间滚动，碾过五千四百里驿道，留下一道胭脂色的血痕。“一骑红尘妃子笑”，绣口一吐就半个盛唐下的不堪，一览无余。当九品小吏李善德颤抖着展开岭南舆图时，他指尖触及的不仅是瘴疠之地的山川脉络，更是天宝年间权力齿轮下迸溅的火星。这场荔枝运输的狂想曲，以《夏侯阳算经》的精密与《酉阳杂俎》的诡谲为音符，最终奏响的却是《钱神论》的荒诞悲歌。</p><p>马伯庸的笔锋如唐代壁画匠人的凿刀，在历史的留白处刻出惊心动魄的纹路。书中李善德伏案演算荔枝腐坏时限的日夜，宣纸上蜿蜒的墨迹恰似《韩熙载夜宴图》中破碎的琴弦——他以明算科的公式解构《齐民要术》所载的隔水培冰法，将波斯商人苏谅的琉璃瓮、侗奴隶林邑奴的断指，统统编织成一张生存的罗网。当预算从三十丛经六部衙门滚雪球般涨至两百丛，当保鲜时限从三日延至十一日却需砍伐半座果园，那些精确到时辰的运输方案，终究成了照见官僚痼疾的青铜鉴。最刺目的莫过于杨国忠轻飘飘一句“右相可没逼着他们贪”，便将两万贯损耗转嫁给沿途驿户，恰如《唐律疏议》中“八议”条款在现实中的狞笑。</p><p>书中人性微芒的迸发，往往藏于史册不屑记录的缝隙。李善德与林邑奴月下对饮的场景，让人想起敦煌壁画中未被佛光笼罩的供养人——奴隶喉间滚过的米酒，洗去了主仆的界限，照见两个困在时代囚笼中的灵魂。“我这一生，竟像是等着喝这碗酒似的。”这般呓语，比《霓裳羽衣曲》的仙乐更接近盛唐的呼吸。而李夫人那句“<strong>我嫁的是他，又不是长安</strong>”，则如《世说新语》中的林下清风，吹散了《长恨歌》的脂粉气。当李善德深陷数据迷阵时，是夫人默默收拢他揉皱的算纸；当他即将流放岭南时，这句誓言让宦海沉浮都成了窗外的急雨。马伯庸在此显露出史家难得的温情：贵妃齿间的清甜、安禄山的铁骑、长安城的朱辇，终将化为马嵬坡的黄土，唯有人性褶皱里这些细微的晨露，能在《资治通鉴》的铜墙铁壁上洇出水痕。</p><p>然作者对典籍的痴迷，亦成双刃之剑。《南方草木状》的保鲜术、《唐六典》的驿传制、《通典》的赋税考，这些考据固然浇筑出青铜器般的厚重质感，但当李善德怒斥杨国忠时突然引述《盐铁论》，当林邑奴临终独白夹杂《洛阳伽蓝记》的佛偈，密集的引经据典便如唐三彩上过量的贴花，喧宾夺主地割裂叙事肌理。不过马伯庸终究是聪明的说书人，他将《册府元龟》中冰冷的“岭南贡荔枝敕令”浸泡于人性的酒曲，酿出“不劳一文而丰饶左右，此何异于凿百姓骨血”的诘问——这声嘶吼从《捕蛇者说》的竹简中破土而出，刺穿了十一个世纪的时空铁幕。</p><p>故事的余韵在岭南雨季里悄然发酵。当李善德放下荔枝使铜符，改握农具在焦土上耕种时，《容斋随笔》中“祸福相倚”的箴言突然有了温度。马伯庸未让他成为《刺客列传》中的悲壮符号，而是化作《岭表录异》里一株重生的荔枝树——被斧斤砍斫的旧桩上，新芽正刺破历史的痂。那些深埋地下的荔枝核，在远离长安的土壤里长成另一种不朽：它们不必再为妃子笑颜狂奔五千里，只需在瘴雾中静静酝酿自己的甜。正如书中奴隶膝盖压弯的野草，今春依旧绿得汹涌，而《新唐书》里工整的“开元全盛日”，反倒成了最苍白的注脚。</p><p>其实对这本书的起因是一场辩论赛——新国辩黄执中和熊浩在一场“决定相伴一生的伴侣要&#x2F;不要一起打上永远爱对方的‘思想钢印’”的哲理辩里，熊浩作为反方没有继续立论与驳斥，而是讲了这个我记忆犹新的故事。以下附上完整辩论稿。</p><h2 id="这钢印般恒久的爱恋，不过只是一枚长安的荔枝"><a href="#这钢印般恒久的爱恋，不过只是一枚长安的荔枝" class="headerlink" title="这钢印般恒久的爱恋，不过只是一枚长安的荔枝"></a>这钢印般恒久的爱恋，不过只是一枚长安的荔枝</h2><p>“传皇贵妃口谕，凡在京中二品以上大员和皇室千郡府上，皆赏岭南荔枝一枚。”</p><p>唐天宝十二载，公元753年，太子师李泌，受宰相杨国忠所害，因《感遇诗》案被玄宗贬斥至湖北蕲春。临行前，李泌进宫谢恩，在见了玄宗之后，离开兴庆宫之时，就见远处奔来一个跌跌撞撞的小太监，他赶紧迎上去说：“内官大人到此，是有何事啊？”太监说，“李先生可否稍后，贵妃娘娘在侧殿中等您，有一事请教。”</p><p>宦官口中的这位贵妃不是别人，就是盛唐时期集万千宠爱于一身的杨家玉环。李泌随宦官来到偏殿，这偏殿与正殿的光景完全不同，这兴庆宫的偏殿由贵妃设计和安造，殿内所有的布物、围廊、陈设皆为鹅黄色，星光一体，气韵柔和。比起兴庆宫当中那些金玉满目的装点要内敛得多，温润得多。在这鹅黄摇曳之中有一座乳白色的玉石茶几，在这个乳白色的玉石茶几上放了一个硕大的纯金石盘，石盘中全是晶莹剔透的冰块，而且冰块上是堆成小山一般来自岭南的新鲜荔枝。</p><p>李泌不敢多看，赶忙跪头叩礼。</p><p>“长源先生不必多礼，快快请起。”</p><p>在镇殿上传来一个无比清丽的声音，就见这镇殿之上坐着一位美艳的妃子，时值六月之下，贵妃着长服而未刻意雕饰。她身穿一身青绿色的长袍，浓抹乌黑的头发被一只栾凤绕珠赤金簪盘起，面容之上无脂粉，但却依然珠圆玉润，雍容绝美。</p><p>“劳驾先生讨扰片刻，是有一事相问，近日有臣工给三郎进言，说若在长生殿内修铁卷、立符咒，能够将三郎与本宫的七夕之爱恋立于钢印金石之上，定能感动上苍，引三清降福，庇佑我们长长久久一生不散。本宫素闻先生自幼修道，早已通晓太乙玄门之神通，如此立符咒、刻金石、求永驻之举是当还是不当？故向先生请教。”</p><p>李泌闻言道：“娘娘此举可是想求爱情历时而不变？”贵妃颔首点头。</p><p>“臣敢请娘娘，这世间您所遇之万物有何事可以历时而不变？”</p><p>这盛唐的贵妃稍作思索：“三郎的大唐江山，我与他的永恒爱恋，还有——”这目光恰好落在这晶莹剔透的荔枝之上。“还有这每每盛夏、每每初一、每每十五，必定送到这兴庆宫中的长安荔枝。”</p><p><em>“娘娘，您可知道这荔枝要经历如何才能到长安，进得这兴庆宫中？每年盛夏，岭南湿润之土若得天公垂怜，无旱涝两灾，无病虫两害，方能破土出芽。经园工悉心栽培，在这一人多高的树上方能第一波长出大约一百颗果子，果实刚刚成熟，不能早、不能晚，恰在七成之时，农人便要将荔枝连果树叶一并取下，如一颗小小的树苗径直放到一个硕大的特质竹筒中，这个竹筒内分内外两层，内部存放荔枝，而外侧则是鲜冻的冰块，片刻都不可迟疑，单人独骑上马奔驰五十里，换人换马换冰走八百里加急的军事驿道，昼夜兼程风雨无阻。这路上若是撞了人，无论死伤皆不耽误，人可以死，长安的荔枝绝不能停，如此狂奔十日，方能从岭南抵达长安。一句话，荔枝从土上到树上、从树上到竹筒、从竹筒到马背、从马背到驿站、从驿站到飞驰的路上、从路上进得长安城，最后送到尚司局，才能送到娘娘以及满朝臣工的手上。这期间，若是遇得土崩瓦解，若是遇到三灾七害，若是竹筒漏了冰，若是驿臣稍有大意，若是路上的病害之人蛮目纠缠，若是马匹得了病，若是尚司官怠慢，若是天光在沿路之上过于炎热，若是天子以众生之苦为念，不以一己之私欲而养如此之荔枝；若言官能够秉笔直抒，直谏君王，而不求明哲保身；若有司能够秉公直断，这途中之人若有死伤，乃天子犯法与庶民同罪。娘娘，哪儿来这使命必达的长安荔枝？”</em></p><p>“娘娘，佛道皆讲无常，在您眼中这一颗颗荔枝是使命的必达，在臣的眼中，那是无数前提无数机缘无数因果，如此密密匝匝拧成的一条纤细的丝线，不用多久，必断无疑。”</p><p>当夜，沉溺于李泌的教诲中，贵妃久久不能入眠，她懂了吗？似懂而非懂。她何时能全懂？</p><p>李泌被贬两年后，公元755年，安史之乱爆发，次年六月叛军攻破潼关，玄宗和那些拿到荔枝的满城亲眷仓皇出逃。还是在一个六月的夜晚，还是一个夏天，在马嵬坡的荒岗上，贵妃的身后是从树上悬下的赐死白绫。此时此刻，那大唐的永昌，那恒久的爱恋，那一颗颗新鲜欲滴的荔枝，全部灰飞烟灭。霎时间，贵妃记起与李泌当日的交谈。她都懂了，她完全懂了。那满脸的泪容之下竟然出现一丝丝人们难以察觉的淡然。</p><p>是啊，这钢印般恒久的爱恋，不过只是一枚 长安的荔枝。</p>]]></content>
      
      
      <categories>
          
          <category> Book Review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 马伯庸 </tag>
            
            <tag> 《长安的荔枝》 </tag>
            
            <tag> 熊浩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The Book of Songs</title>
      <link href="/2025/01/09/The_Book_of_Songs/"/>
      <url>/2025/01/09/The_Book_of_Songs/</url>
      
        <content type="html"><![CDATA[<h3 id="十月之交"><a href="#十月之交" class="headerlink" title="十月之交"></a>十月之交</h3><p>诗经·小雅〔先秦〕</p><p>十月之交，朔月辛卯。日有食之，亦孔之丑。彼月而微，此日而微；今此下民，亦孔之哀。</p><p>日月告凶，不用其行。四国无政，不用其良。彼月而食，则维其常；此日而食，于何不臧。</p><p>烨烨震电，不宁不令。百川沸腾，山冢崒崩。高岸为谷，深谷为陵。哀今之人，胡憯莫惩？</p><p>皇父卿士，番维司徒。家伯维宰，仲允膳夫。棸子内史，蹶维趣马。楀维师氏，艳妻煽方处。</p><p>抑此皇父，岂曰不时？胡为我作，不即我谋？彻我墙屋，田卒污莱。曰予不戕，礼则然矣。</p><p>皇父孔圣，作都于向。择三有事，亶侯多藏。不慭遗一老，俾守我王。择有车马，以居徂向。</p><p><strong>黾勉从事，不敢告劳。无罪无辜，谗口嚣嚣。</strong>下民之孽，匪降自天。<strong>噂沓背憎，职竞由人。</strong></p><p>悠悠我里，亦孔之痗。四方有羡，我独居忧。民莫不逸，我独不敢休。天命不彻，我不敢效我友自逸。</p>]]></content>
      
      
      <categories>
          
          <category> Poetry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《诗经》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DB Experiment</title>
      <link href="/2024/12/29/Db_Experiment/"/>
      <url>/2024/12/29/Db_Experiment/</url>
      
        <content type="html"><![CDATA[<p>以下是一套共 30 道数据库实验 (SYSU-DCS283) 期末考核题目示例，题目均基于所提供的 school 数据库表结构 (STUDENTS, TEACHERS, COURSES, CHOICES) 进行设计。每道题目包含简要描述、标准答案及解析，覆盖了数据查询（单表与多表连接）、数据操作（INSERT、UPDATE、DELETE）、表创建及约束、触发器和事务等主要内容。希望能帮助在复习和练习中全面掌握 SQL Server 的核心技能。</p><hr><h2 id="1-创建新表并设置主键与唯一性约束"><a href="#1-创建新表并设置主键与唯一性约束" class="headerlink" title="1. 创建新表并设置主键与唯一性约束"></a>1. 创建新表并设置主键与唯一性约束</h2><p><strong>题目描述</strong><br>在 school 数据库中，创建一个名为 Worker 的表，字段包括：  </p><ul><li>WID (int，主键)  </li><li>Wname (char(20) ，姓名，需要唯一性约束)  </li><li>Wage (int，年龄)  </li><li>Wgender (char(1)，性别)</li></ul><p>要求：  </p><ol><li>将 WID 作为主键。  </li><li>为 Wname 添加唯一性约束。  </li><li>限制 Wage 不超过 30。</li></ol><p><strong>标准答案</strong>  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Worker (</span><br><span class="line">    WID <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    Wname <span class="type">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    Wage <span class="type">INT</span> <span class="keyword">CHECK</span> (Wage <span class="operator">&lt;=</span> <span class="number">30</span>),</span><br><span class="line">    Wgender <span class="type">CHAR</span>(<span class="number">1</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>解析</strong>  </p><ol><li>PRIMARY KEY 关键字可直接在定义字段时声明，或在表最后统一声明。  </li><li>UNIQUE 关键字可为字段设置唯一性约束。  </li><li>CHECK 约束可限制字段的取值范围。</li></ol><hr><h2 id="2-简单查询-单表"><a href="#2-简单查询-单表" class="headerlink" title="2. 简单查询 (单表)"></a>2. 简单查询 (单表)</h2><p><strong>题目描述</strong><br>查询 STUDENTS 表中所有 grade 等于 2001 的学生姓名（sname），并按照 sid 升序排列输出。</p><p><strong>标准答案</strong>  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sname</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS</span><br><span class="line"><span class="keyword">WHERE</span> grade <span class="operator">=</span> <span class="number">2001</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> sid <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>  </p><ul><li>WHERE 子句筛选出 grade &#x3D; 2001 的记录。  </li><li>ORDER BY 可控制结果集的排序，默认为升序，也可手动指定 ASC。</li></ul><hr><h2 id="3-简单查询-单表，多字段"><a href="#3-简单查询-单表，多字段" class="headerlink" title="3. 简单查询 (单表，多字段)"></a>3. 简单查询 (单表，多字段)</h2><p><strong>题目描述</strong><br>查询 TEACHERS 表中所有老师（tid、tname、email）的信息，并按照 salary 降序排列。</p><p><strong>标准答案</strong>  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> tid, tname, email</span><br><span class="line"><span class="keyword">FROM</span> TEACHERS</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>  </p><ul><li>仅需使用 SELECT 列出需要的字段。  </li><li>ORDER BY salary DESC 进行降序排列。</li></ul><hr><h2 id="4-条件查询与别名"><a href="#4-条件查询与别名" class="headerlink" title="4. 条件查询与别名"></a>4. 条件查询与别名</h2><p><strong>题目描述</strong><br>查询 COURSES 表中课时 (hour) 大于 40 的课程编号 (cid) 和课程名称 (cname)，并将查询结果中的字段起别名：课程编号 AS 课程代码、课程名称 AS 课程名称。</p><p><strong>标准答案</strong>  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cid <span class="keyword">AS</span> 课程代码, cname <span class="keyword">AS</span> 课程名称</span><br><span class="line"><span class="keyword">FROM</span> COURSES</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">hour</span> <span class="operator">&gt;</span> <span class="number">40</span>;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>  </p><ul><li>使用 AS 来给查询结果字段起别名。  </li><li>WHERE hour &gt; 40 限制显示课时大于 40 的课程。</li></ul><hr><h2 id="5-多表连接查询-内连接"><a href="#5-多表连接查询-内连接" class="headerlink" title="5. 多表连接查询 (内连接)"></a>5. 多表连接查询 (内连接)</h2><p><strong>题目描述</strong><br>查询所有选课记录中（CHOICES 表）学生姓名、课程名称、成绩（score）。结果中应包含学生姓名 (STUDENTS 表的 sname) 与课程名称 (COURSES 表的 cname)，且只显示有对应关系的行。</p><p><strong>标准答案</strong>  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sname, C.cname, CH.score</span><br><span class="line"><span class="keyword">FROM</span> CHOICES CH</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> STUDENTS S <span class="keyword">ON</span> CH.sid <span class="operator">=</span> S.sid</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> COURSES C <span class="keyword">ON</span> CH.cid <span class="operator">=</span> C.cid;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>  </p><ul><li>先将 CHOICES 与 STUDENTS 表通过 sid 关联，再通过 CHOICES 与 COURSES 的 cid 关联。  </li><li>INNER JOIN 仅返回存在匹配关系的记录。</li></ul><hr><h2 id="6-多表条件查询-连接-条件"><a href="#6-多表条件查询-连接-条件" class="headerlink" title="6. 多表条件查询 (连接 + 条件)"></a>6. 多表条件查询 (连接 + 条件)</h2><p><strong>题目描述</strong><br>查询选修“C0001”课程且成绩大于 80 分的学生姓名及该课程成绩。</p><p><strong>标准答案</strong>  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sname, CH.score</span><br><span class="line"><span class="keyword">FROM</span> CHOICES CH</span><br><span class="line"><span class="keyword">JOIN</span> STUDENTS S <span class="keyword">ON</span> CH.sid <span class="operator">=</span> S.sid</span><br><span class="line"><span class="keyword">WHERE</span> CH.cid <span class="operator">=</span> <span class="string">&#x27;C0001&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> CH.score <span class="operator">&gt;</span> <span class="number">80</span>;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>  </p><ul><li>基于 CHOICES 和 STUDENTS 的连接，先找到 cid &#x3D; ‘C0001’ 的记录，再用 AND 进一步筛选 score &gt; 80 的记录。</li></ul><hr><h2 id="7-INSERT-语句-单条插入"><a href="#7-INSERT-语句-单条插入" class="headerlink" title="7. INSERT 语句 (单条插入)"></a>7. INSERT 语句 (单条插入)</h2><p><strong>题目描述</strong><br>往 STUDENTS 表中插入一条新学生信息，学号 sid &#x3D; ‘S1009’，姓名 sname &#x3D; ‘LinX’, email &#x3D; ‘<a href="mailto:&#108;&#x69;&#110;&#x78;&#x40;&#115;&#x63;&#104;&#111;&#111;&#108;&#x2e;&#99;&#111;&#x6d;">&#108;&#x69;&#110;&#x78;&#x40;&#115;&#x63;&#104;&#111;&#111;&#108;&#x2e;&#99;&#111;&#x6d;</a>‘, grade &#x3D; 2002。</p><p><strong>标准答案</strong>  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> STUDENTS (sid, sname, email, grade)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;S1009&#x27;</span>, <span class="string">&#x27;LinX&#x27;</span>, <span class="string">&#x27;linx@school.com&#x27;</span>, <span class="number">2002</span>);</span><br></pre></td></tr></table></figure><p><strong>解析</strong>  </p><ul><li>指定字段列表并与 VALUES 的值一一对应。  </li><li>注意如果 sid 是主键，需保证该值无重复。</li></ul><hr><h2 id="8-INSERT-语句-多条插入"><a href="#8-INSERT-语句-多条插入" class="headerlink" title="8. INSERT 语句 (多条插入)"></a>8. INSERT 语句 (多条插入)</h2><p><strong>题目描述</strong><br>在 TEACHERS 表中一次性插入两条新教师数据：  </p><ol><li>tid &#x3D; ‘T2001’，tname &#x3D; ‘Wang Wu’，email &#x3D; ‘<a href="mailto:&#119;&#x61;&#x6e;&#103;&#119;&#117;&#64;&#120;&#x78;&#120;&#46;&#x63;&#x6f;&#x6d;">&#119;&#x61;&#x6e;&#103;&#119;&#117;&#64;&#120;&#x78;&#120;&#46;&#x63;&#x6f;&#x6d;</a>‘，salary &#x3D; 4500  </li><li>tid &#x3D; ‘T2002’，tname &#x3D; ‘Zhao Liu’，email &#x3D; ‘<a href="mailto:&#x7a;&#x68;&#97;&#x6f;&#x6c;&#105;&#117;&#64;&#x78;&#120;&#x78;&#x2e;&#99;&#111;&#x6d;">&#x7a;&#x68;&#97;&#x6f;&#x6c;&#105;&#117;&#64;&#x78;&#120;&#x78;&#x2e;&#99;&#111;&#x6d;</a>‘，salary &#x3D; 2000</li></ol><p><strong>标准答案</strong>  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TEACHERS (tid, tname, email, salary)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;T2001&#x27;</span>, <span class="string">&#x27;Wang Wu&#x27;</span>, <span class="string">&#x27;wangwu@xxx.com&#x27;</span>, <span class="number">4500</span>),</span><br><span class="line">(<span class="string">&#x27;T2002&#x27;</span>, <span class="string">&#x27;Zhao Liu&#x27;</span>, <span class="string">&#x27;zhaoliu@xxx.com&#x27;</span>, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p><strong>解析</strong>  </p><ul><li>SQL Server 支持在单条 INSERT 语句中使用多个 VALUES 子句进行批量数据插入。  </li><li>注意字段与 VALUES 的顺序需一致。</li></ul><hr><h2 id="9-UPDATE-语句-单表"><a href="#9-UPDATE-语句-单表" class="headerlink" title="9. UPDATE 语句 (单表)"></a>9. UPDATE 语句 (单表)</h2><p><strong>题目描述</strong><br>将 STUDENTS 表中学号 sid &#x3D; ‘S1002’ 的学生邮箱 (email) 改为 ‘<a href="mailto:&#110;&#101;&#x77;&#x5f;&#x65;&#109;&#x61;&#105;&#108;&#64;&#x73;&#99;&#x68;&#111;&#x6f;&#x6c;&#x2e;&#99;&#111;&#109;">&#110;&#101;&#x77;&#x5f;&#x65;&#109;&#x61;&#105;&#108;&#64;&#x73;&#99;&#x68;&#111;&#x6f;&#x6c;&#x2e;&#99;&#111;&#109;</a>‘。</p><p><strong>标准答案</strong>  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> STUDENTS</span><br><span class="line"><span class="keyword">SET</span> email <span class="operator">=</span> <span class="string">&#x27;new_email@school.com&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> sid <span class="operator">=</span> <span class="string">&#x27;S1002&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>  </p><ul><li>使用 UPDATE 表名 SET 字段 &#x3D; 值， WHERE 子句确定要更新哪条记录。  </li><li>不加 WHERE 会导致该表所有记录都被更新。</li></ul><hr><h2 id="10-DELETE-语句-单表"><a href="#10-DELETE-语句-单表" class="headerlink" title="10. DELETE 语句 (单表)"></a>10. DELETE 语句 (单表)</h2><p><strong>题目描述</strong><br>删除 TEACHERS 表中工资 (salary) 小于 2500 的所有教师记录。</p><p><strong>标准答案</strong>  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> TEACHERS</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&lt;</span> <span class="number">2500</span>;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>  </p><ul><li>DELETE 语句配合 WHERE 子句定位要删除的行。  </li><li>不带 WHERE 子句则会删除表的所有记录，需谨慎使用。</li></ul><hr><h2 id="11-多表连接查询-左外连接"><a href="#11-多表连接查询-左外连接" class="headerlink" title="11. 多表连接查询 (左外连接)"></a>11. 多表连接查询 (左外连接)</h2><p><strong>题目描述</strong><br>查询所有 STUDENTS 表中的学生姓名以及他们在 CHOICES 表中是否有选课记录的成绩信息（score）。即使学生没有选课记录，也需要显示其姓名，score 字段可以显示为 NULL。</p><p><strong>标准答案</strong>  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sname, CH.score</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS S</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> CHOICES CH <span class="keyword">ON</span> S.sid <span class="operator">=</span> CH.sid;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>  </p><ul><li>LEFT JOIN 会保证左表 (STUDENTS) 的所有记录都被返回，即使右表 (CHOICES) 中无匹配行，右表字段以 NULL 填充。</li></ul><hr><h2 id="12-多表连接查询-内连接-多条件"><a href="#12-多表连接查询-内连接-多条件" class="headerlink" title="12. 多表连接查询 (内连接 + 多条件)"></a>12. 多表连接查询 (内连接 + 多条件)</h2><p><strong>题目描述</strong><br>查询 CHOICES 表中成绩大于 90 分并且对应的教师 salary 大于 5000 的学生姓名、课程名称、教师姓名。</p><p><strong>标准答案</strong>  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sname, C.cname, T.tname</span><br><span class="line"><span class="keyword">FROM</span> CHOICES CH</span><br><span class="line"><span class="keyword">JOIN</span> STUDENTS S <span class="keyword">ON</span> CH.sid <span class="operator">=</span> S.sid</span><br><span class="line"><span class="keyword">JOIN</span> COURSES C <span class="keyword">ON</span> CH.cid <span class="operator">=</span> C.cid</span><br><span class="line"><span class="keyword">JOIN</span> TEACHERS T <span class="keyword">ON</span> CH.tid <span class="operator">=</span> T.tid</span><br><span class="line"><span class="keyword">WHERE</span> CH.score <span class="operator">&gt;</span> <span class="number">90</span></span><br><span class="line">  <span class="keyword">AND</span> T.salary <span class="operator">&gt;</span> <span class="number">5000</span>;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>  </p><ul><li>通过 STUDENTS、COURSES、TEACHERS 三表与 CHOICES 连接获取需要的信息。  </li><li>WHERE 条件可并列多个限制。</li></ul><hr><h2 id="13-使用别名与表达式"><a href="#13-使用别名与表达式" class="headerlink" title="13. 使用别名与表达式"></a>13. 使用别名与表达式</h2><p><strong>题目描述</strong><br>查询 TEACHERS 表中所有教师姓名 (tname) 及其工资的 12 个月总额 (命名为 AnnualSalary)。AnnualSalary &#x3D; salary * 12。</p><p><strong>标准答案</strong>  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> tname,</span><br><span class="line">       salary <span class="operator">*</span> <span class="number">12</span> <span class="keyword">AS</span> AnnualSalary</span><br><span class="line"><span class="keyword">FROM</span> TEACHERS;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>  </p><ul><li>可在 SELECT 字段时直接使用算术表达式。  </li><li>AS AnnualSalary 用来设置输出字段别名。</li></ul><hr><h2 id="14-使用聚合函数-COUNT"><a href="#14-使用聚合函数-COUNT" class="headerlink" title="14. 使用聚合函数 (COUNT)"></a>14. 使用聚合函数 (COUNT)</h2><p><strong>题目描述</strong><br>查询 STUDENTS 表中共有多少位学生 (统计行数)，并将结果命名为 StudentCount。</p><p><strong>标准答案</strong>  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> StudentCount</span><br><span class="line"><span class="keyword">FROM</span> STUDENTS;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>  </p><ul><li>COUNT(*) 会计数表中的所有行。  </li><li>可以使用别名让结果列更具可读性。</li></ul><hr><h2 id="15-使用聚合函数-MAX、MIN、AVG"><a href="#15-使用聚合函数-MAX、MIN、AVG" class="headerlink" title="15. 使用聚合函数 (MAX、MIN、AVG)"></a>15. 使用聚合函数 (MAX、MIN、AVG)</h2><p><strong>题目描述</strong><br>查询 TEACHERS 表中最大工资、最小工资以及平均工资，分别命名为 MaxSalary、MinSalary 和 AvgSalary。</p><p><strong>标准答案</strong>  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="built_in">MAX</span>(salary) <span class="keyword">AS</span> MaxSalary,</span><br><span class="line">    <span class="built_in">MIN</span>(salary) <span class="keyword">AS</span> MinSalary,</span><br><span class="line">    <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> AvgSalary</span><br><span class="line"><span class="keyword">FROM</span> TEACHERS;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>  </p><ul><li>聚合函数可直接应用于一个列上。  </li><li>结果会在一行返回多个聚合值。</li></ul><hr><h2 id="16-GROUP-BY-与-HAVING"><a href="#16-GROUP-BY-与-HAVING" class="headerlink" title="16. GROUP BY 与 HAVING"></a>16. GROUP BY 与 HAVING</h2><p><strong>题目描述</strong><br>查询每门课程的选课人数 (COUNT(sid))，仅显示选课人数大于 3 的课程编号和对应人数。</p><p><strong>标准答案</strong>  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cid, <span class="built_in">COUNT</span>(sid) <span class="keyword">AS</span> StudentCount</span><br><span class="line"><span class="keyword">FROM</span> CHOICES</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cid</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(sid) <span class="operator">&gt;</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>  </p><ul><li>GROUP BY cid 先按课程分组，再使用 COUNT(sid) 聚合统计。  </li><li>HAVING 相当于对分组后的结果做进一步筛选。</li></ul><hr><h2 id="17-DISTINCT-去重"><a href="#17-DISTINCT-去重" class="headerlink" title="17. DISTINCT 去重"></a>17. DISTINCT 去重</h2><p><strong>题目描述</strong><br>查询所有已选课 (存在于 CHOICES 表中) 的学生年级 (grade) 信息，不可重复显示。</p><p><strong>标准答案</strong>  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> S.grade</span><br><span class="line"><span class="keyword">FROM</span> CHOICES C</span><br><span class="line"><span class="keyword">JOIN</span> STUDENTS S <span class="keyword">ON</span> C.sid <span class="operator">=</span> S.sid;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>  </p><ul><li>DISTINCT 可去除重复记录。  </li><li>需要和 STUDENTS 表关联获取 grade 字段。</li></ul><hr><h2 id="18-在现有表上增加列"><a href="#18-在现有表上增加列" class="headerlink" title="18. 在现有表上增加列"></a>18. 在现有表上增加列</h2><p><strong>题目描述</strong><br>在 STUDENTS 表中增加一个新列 phone，类型为 char(11)，允许 NULL 值。</p><p><strong>标准答案</strong>  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> STUDENTS</span><br><span class="line"><span class="keyword">ADD</span> phone <span class="type">CHAR</span>(<span class="number">11</span>) <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>  </p><ul><li>使用 ALTER TABLE … ADD 语句为已存在的表添加列。  </li><li>如果不指定 NULL&#x2F;NOT NULL，默认为允许 NULL。</li></ul><hr><h2 id="19-修改列类型与名称"><a href="#19-修改列类型与名称" class="headerlink" title="19. 修改列类型与名称"></a>19. 修改列类型与名称</h2><p><strong>题目描述</strong><br>将 TEACHERS 表中的 salary 列改名为 baseSalary，并将数据类型修改为 decimal(8,2)。</p><p><strong>标准答案</strong>  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> sp_rename <span class="string">&#x27;TEACHERS.salary&#x27;</span>, <span class="string">&#x27;baseSalary&#x27;</span>, <span class="string">&#x27;COLUMN&#x27;</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TEACHERS</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> baseSalary <span class="type">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><strong>解析</strong>  </p><ul><li>sp_rename 用于修改列名，参数中需指定原表名.原列名、新列名以及 ‘COLUMN’ 关键字。  </li><li>ALTER TABLE … ALTER COLUMN 修改字段数据类型。  </li><li>注意某些情况下需要保证原字段的数据可兼容新的数据类型。</li></ul><hr><h2 id="20-创建视图-VIEW"><a href="#20-创建视图-VIEW" class="headerlink" title="20. 创建视图 (VIEW)"></a>20. 创建视图 (VIEW)</h2><p><strong>题目描述</strong><br>创建一个名为 vHighScore 的视图，用于查询所有成绩大于等于 90 分的学生姓名、课程名称、成绩。</p><p><strong>标准答案</strong>  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> vHighScore</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> S.sname, C.cname, CH.score</span><br><span class="line"><span class="keyword">FROM</span> CHOICES CH</span><br><span class="line"><span class="keyword">JOIN</span> STUDENTS S <span class="keyword">ON</span> CH.sid <span class="operator">=</span> S.sid</span><br><span class="line"><span class="keyword">JOIN</span> COURSES C <span class="keyword">ON</span> CH.cid <span class="operator">=</span> C.cid</span><br><span class="line"><span class="keyword">WHERE</span> CH.score <span class="operator">&gt;=</span> <span class="number">90</span>;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>  </p><ul><li>视图 (VIEW) 是一个“虚拟表”，可简化查询操作。  </li><li>在 SSMS 中使用 CREATE VIEW 语句，并在 AS 后跟上具体的 SELECT 查询。</li></ul><hr><h2 id="21-删除视图"><a href="#21-删除视图" class="headerlink" title="21. 删除视图"></a>21. 删除视图</h2><p><strong>题目描述</strong><br>删除上一步创建的视图 vHighScore。</p><p><strong>标准答案</strong>  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> vHighScore;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>  </p><ul><li>DROP VIEW 视图名 用于删除已存在的视图。  </li><li>注意删除后无法直接引用该视图。</li></ul><hr><h2 id="22-创建触发器-INSERT-或-UPDATE"><a href="#22-创建触发器-INSERT-或-UPDATE" class="headerlink" title="22. 创建触发器 (INSERT 或 UPDATE)"></a>22. 创建触发器 (INSERT 或 UPDATE)</h2><p><strong>题目描述</strong><br>为 TEACHERS 表创建触发器 T1，当向该表插入或更新记录时，如果 baseSalary（或 salary）低于 3000，则将其自动修改为 3000。</p><p><strong>标准答案</strong><br>下面的示例假设列名已经改为 baseSalary；如果仍是 salary，请相应调整列名。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> T1</span><br><span class="line"><span class="keyword">ON</span> TEACHERS</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 将新插入或更新的记录里 baseSalary &lt; 3000 的部分自动修正为 3000</span></span><br><span class="line">    <span class="keyword">UPDATE</span> TEACHERS</span><br><span class="line">    <span class="keyword">SET</span> TEACHERS.baseSalary <span class="operator">=</span> <span class="number">3000</span></span><br><span class="line">    <span class="keyword">FROM</span> TEACHERS</span><br><span class="line">    <span class="keyword">JOIN</span> Inserted I <span class="keyword">ON</span> TEACHERS.tid <span class="operator">=</span> I.tid</span><br><span class="line">    <span class="keyword">WHERE</span> I.baseSalary <span class="operator">&lt;</span> <span class="number">3000</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>  </p><ul><li>触发器 (TRIGGER) 在某些指定事件 (INSERT、UPDATE、DELETE) 发生时自动执行。  </li><li>Inserted 表是 SQL Server 触发器内的虚拟表，包含新插入或更新的记录。  </li><li>在触发器中可以对 Inserted 中不符合条件的数据做二次处理或拒绝等操作。</li></ul><hr><h2 id="23-创建触发器-DELETE"><a href="#23-创建触发器-DELETE" class="headerlink" title="23. 创建触发器 (DELETE)"></a>23. 创建触发器 (DELETE)</h2><p><strong>题目描述</strong><br>在 STUDENTS 表上创建触发器 T_StuDel，当删除学生记录时，需要先将此学生在 CHOICES 中的学习记录删除，然后才允许删除 STUDENTS 中对应记录。</p><p><strong>题目提示</strong><br>可以在触发器中手动先 DELETE CHOICES 表，再 DELETE STUDENTS，也可以使用其他方式保证清理。  </p><p><strong>标准答案</strong><br>(一种可能实现方式——先删除 CHOICES 中相关记录，再删除 STUDENTS。)</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> T_StuDel</span><br><span class="line"><span class="keyword">ON</span> STUDENTS</span><br><span class="line">INSTEAD <span class="keyword">OF</span> <span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DELETE</span> <span class="keyword">FROM</span> CHOICES</span><br><span class="line">    <span class="keyword">WHERE</span> sid <span class="keyword">IN</span> (<span class="keyword">SELECT</span> sid <span class="keyword">FROM</span> DELETED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">DELETE</span> <span class="keyword">FROM</span> STUDENTS</span><br><span class="line">    <span class="keyword">WHERE</span> sid <span class="keyword">IN</span> (<span class="keyword">SELECT</span> sid <span class="keyword">FROM</span> DELETED);</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>  </p><ul><li>INSTEAD OF DELETE 触发器可拦截原始 DELETE 操作，改为在触发器主体中执行自定义逻辑。  </li><li>DELETED 虚拟表中包含被删除的记录信息，可用 sid 匹配引用。</li></ul><hr><h2 id="24-事务处理-简单示例"><a href="#24-事务处理-简单示例" class="headerlink" title="24. 事务处理 (简单示例)"></a>24. 事务处理 (简单示例)</h2><p><strong>题目描述</strong><br>往 COURSES 表中插入两条记录 (cid、cname、hour)。如果任意一条插入失败，则回滚事务，保证数据一致性。</p><p><strong>标准答案</strong>  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRY</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> COURSES (cid, cname, <span class="keyword">hour</span>)</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;C1005&#x27;</span>, <span class="string">&#x27;Physics&#x27;</span>, <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> COURSES (cid, cname, <span class="keyword">hour</span>)</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;C1006&#x27;</span>, <span class="string">&#x27;Chemistry&#x27;</span>, <span class="number">55</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">COMMIT</span> TRANSACTION;</span><br><span class="line"><span class="keyword">END</span> TRY</span><br><span class="line"><span class="keyword">BEGIN</span> CATCH</span><br><span class="line">    <span class="keyword">ROLLBACK</span> TRANSACTION;</span><br><span class="line">    PRINT <span class="string">&#x27;插入失败，事务已回滚。&#x27;</span>;</span><br><span class="line"><span class="keyword">END</span> CATCH;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>  </p><ul><li>BEGIN TRANSACTION、COMMIT TRANSACTION、ROLLBACK TRANSACTION 结合使用，对操作进行事务保护。  </li><li>BEGIN TRY … BEGIN CATCH 结构便于捕获异常，并在发生异常时回滚。</li></ul><hr><h2 id="25-事务处理-多表操作"><a href="#25-事务处理-多表操作" class="headerlink" title="25. 事务处理 (多表操作)"></a>25. 事务处理 (多表操作)</h2><p><strong>题目描述</strong><br>需要同时往 STUDENTS 表和 CHOICES 表各插入一条相关记录。如果插入 STUDENTS 表成功但插入 CHOICES 表失败，则需回滚所有操作。</p><p><strong>标准答案</strong>  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRY</span><br><span class="line">    <span class="comment">-- 假设待插入学生</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> STUDENTS (sid, sname, email, grade)</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;S1010&#x27;</span>, <span class="string">&#x27;Sun Qi&#x27;</span>, <span class="string">&#x27;sunqi@school.com&#x27;</span>, <span class="number">2003</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 再往 CHOICES 表插入对应选课信息</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> CHOICES (<span class="keyword">no</span>, sid, tid, cid, score)</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="number">1010</span>, <span class="string">&#x27;S1010&#x27;</span>, <span class="string">&#x27;T1001&#x27;</span>, <span class="string">&#x27;C0001&#x27;</span>, <span class="number">85</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">COMMIT</span> TRANSACTION;</span><br><span class="line"><span class="keyword">END</span> TRY</span><br><span class="line"><span class="keyword">BEGIN</span> CATCH</span><br><span class="line">    <span class="keyword">ROLLBACK</span> TRANSACTION;</span><br><span class="line">    PRINT <span class="string">&#x27;出现错误，事务已回滚&#x27;</span>;</span><br><span class="line"><span class="keyword">END</span> CATCH;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>  </p><ul><li>同一事务 (BEGIN TRANSACTION … COMMIT&#x2F;ROLLBACK) 内的多表操作如果有一处失败，需要回滚所有操作。</li></ul><hr><h2 id="26-CHECK-约束"><a href="#26-CHECK-约束" class="headerlink" title="26. CHECK 约束"></a>26. CHECK 约束</h2><p><strong>题目描述</strong><br>在 COURSES 表中新增一个 CHECK 约束，保证课程课时 (hour) 大于 0。</p><p><strong>标准答案</strong>  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> COURSES</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> CK_COURSES_HOUR <span class="keyword">CHECK</span> (<span class="keyword">hour</span> <span class="operator">&gt;</span> <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><strong>解析</strong>  </p><ul><li>ALTER TABLE … ADD CONSTRAINT 来增加约束。  </li><li>CHECK(hour &gt; 0) 可防止插入或更新到非正值课时。</li></ul><hr><h2 id="27-FOREIGN-KEY-约束的创建"><a href="#27-FOREIGN-KEY-约束的创建" class="headerlink" title="27. FOREIGN KEY 约束的创建"></a>27. FOREIGN KEY 约束的创建</h2><p><strong>题目描述</strong><br>尝试在 CHOICES 表上添加一个外键约束 FK_CHOICES_TEACHERS2，要求 tid 必须是 TEACHERS 表中已存在的教师编号 (tid)，一旦在 TEACHERS 中删除记录时，自动删除 CHOICES 中相应的记录 (ON DELETE CASCADE)。</p><p>注意：可能与现有外键 FK_CHOICES_TEACHERS 冲突，需先删除或更改已有外键以作演示。</p><p><strong>标准答案</strong><br>(仅作示例，若已存在外键，需要先 DROP 再 CREATE。)</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> CHOICES</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> FK_CHOICES_TEACHERS2</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (tid) <span class="keyword">REFERENCES</span> TEACHERS(tid)</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>  </p><ul><li>在 CHOICES 中通过外键引用 TEACHERS 的主键，指定 ON DELETE CASCADE 表示当父表记录删除时，子表对应记录也一并删除。  </li><li>需留意与已有外键冲突的问题。</li></ul><hr><h2 id="28-UNIQUE-约束的添加"><a href="#28-UNIQUE-约束的添加" class="headerlink" title="28. UNIQUE 约束的添加"></a>28. UNIQUE 约束的添加</h2><p><strong>题目描述</strong><br>在 TEACHERS 表中为 email 字段添加唯一性约束，保证同一老师邮箱不重复。若 email 字段已有重复值，需要先行修改或删除。</p><p><strong>标准答案</strong>  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TEACHERS</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> UQ_TEACHERS_EMAIL <span class="keyword">UNIQUE</span>(email);</span><br></pre></td></tr></table></figure><p><strong>解析</strong>  </p><ul><li>ALTER TABLE … ADD CONSTRAINT … UNIQUE(字段) 用于添加唯一性约束。  </li><li>注意使用前需确保该字段中不存在重复值，否则会报错。</li></ul><hr><h2 id="29-复杂多表查询-三表连接-聚合"><a href="#29-复杂多表查询-三表连接-聚合" class="headerlink" title="29. 复杂多表查询 (三表连接 + 聚合)"></a>29. 复杂多表查询 (三表连接 + 聚合)</h2><p><strong>题目描述</strong><br>查询各个教师 (tid) 所授课程 (名下 CHOICES 记录) 的平均成绩，结果包含 tid、教师姓名、平均成绩(别名 AvgScore)，并按 AvgScore 降序排序。</p><p><strong>标准答案</strong>  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> T.tid, T.tname, <span class="built_in">AVG</span>(CH.score) <span class="keyword">AS</span> AvgScore</span><br><span class="line"><span class="keyword">FROM</span> TEACHERS T</span><br><span class="line"><span class="keyword">JOIN</span> CHOICES CH <span class="keyword">ON</span> T.tid <span class="operator">=</span> CH.tid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> T.tid, T.tname</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> AvgScore <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>  </p><ul><li>首先使用 TEACHERS 与 CHOICES 进行关联，根据教师id 分组计算平均成绩。  </li><li>GROUP BY T.tid, T.tname 后才能使用聚合函数 AVG(CH.score)。  </li><li>ORDER BY AvgScore DESC 降序显示平均成绩。</li></ul><hr><h2 id="30-子查询"><a href="#30-子查询" class="headerlink" title="30. 子查询"></a>30. 子查询</h2><p><strong>题目描述</strong><br>查询成绩高于 TEACHERS 表平均工资的学生选课记录信息 (sname、课程名称 cname、score)，要求只显示满足“score &gt; 平均 salary”的记录。</p><p>(注意：这里将教师的平均工资与学生的分数做对比仅是题目示例，并不一定具有实际业务逻辑。)</p><p><strong>标准答案</strong>  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sname, C.cname, CH.score</span><br><span class="line"><span class="keyword">FROM</span> CHOICES CH</span><br><span class="line"><span class="keyword">JOIN</span> STUDENTS S <span class="keyword">ON</span> CH.sid <span class="operator">=</span> S.sid</span><br><span class="line"><span class="keyword">JOIN</span> COURSES C <span class="keyword">ON</span> CH.cid <span class="operator">=</span> C.cid</span><br><span class="line"><span class="keyword">WHERE</span> CH.score <span class="operator">&gt;</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">AVG</span>(T.salary) <span class="keyword">FROM</span> TEACHERS T</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>解析</strong>  </p><ul><li>在 WHERE 子句中使用子查询，先求 TEACHERS 表平均工资，再与 CHOICES.score 做比较。  </li><li>子查询返回一个标量值，可直接参与比较运算。</li></ul><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>本套题目共 30 道，覆盖了 SQL Server Management Studio (SSMS) 中常见且重要的操作场景，包括数据库对象创建（表、视图、触发器）、数据操作（增删改）、查询（单表、多表、聚合、子查询）、约束（PRIMARY KEY、FOREIGN KEY、CHECK、UNIQUE）以及事务处理等关键内容。  </li><li>题目设置难度适中，既包含基础语法 (简单增删改查) 又涉及多表连接、外键级联、触发器、事务等稍具复杂性或需要理解机制的考核点。  </li><li>每道题目的“解析”部分对常见的使用场景、语法形式及注意事项进行了简要说明。学生在完成这些题目后，可有效复习并掌握 SQL Server 操作的核心内容。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL Server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Encoding System</title>
      <link href="/2024/12/18/Encoding_System/"/>
      <url>/2024/12/18/Encoding_System/</url>
      
        <content type="html"><![CDATA[<p>以下是对 <strong>ASCII</strong>、<strong>GBK</strong>、<strong>Unicode</strong> 和 <strong>UTF-8</strong> 的详细总结，结合示例来解释它们的工作原理及特点。</p><hr><h2 id="1-ASCII-编码"><a href="#1-ASCII-编码" class="headerlink" title="1. ASCII 编码"></a>1. <strong>ASCII 编码</strong></h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h3><ul><li>ASCII （American Standard Code for Information Interchange）是一种基于拉丁字母的编码系统，用于表示现代英语及西欧语言中的基本字符。</li><li>ASCII 是最早的字符编码方案之一，由 7 位二进制数字组成，可以表示 128 个字符（0x00 ~ 0x7F）。</li></ul><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a><strong>范围</strong></h3><ul><li><strong>控制字符</strong>：0x00 - 0x1F 和 0x7F（如换行 <code>\n</code>、回车 <code>\r</code> 等）。</li><li><strong>可打印字符</strong>：0x20 - 0x7E（如字母、数字、标点符号）。</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li>单字节编码，字节大小为 1 个字节。</li><li>向后兼容所有现代编码方案（如 UTF-8）。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h3><table><thead><tr><th>字符</th><th>十六进制</th><th>二进制</th><th>十进制</th></tr></thead><tbody><tr><td>A</td><td>0x41</td><td>01000001</td><td>65</td></tr><tr><td>a</td><td>0x61</td><td>01100001</td><td>97</td></tr><tr><td>0</td><td>0x30</td><td>00110000</td><td>48</td></tr><tr><td>空格</td><td>0x20</td><td>00100000</td><td>32</td></tr><tr><td>!</td><td>0x21</td><td>00100001</td><td>33</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul><li><strong>优点</strong>：简单、高效，适用于英文。</li><li><strong>缺点</strong>：仅适用于英文，无法表示其他语言字符（如中文）。</li></ul><hr><h2 id="2-GBK-编码"><a href="#2-GBK-编码" class="headerlink" title="2. GBK 编码"></a>2. <strong>GBK 编码</strong></h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a><strong>定义</strong></h3><ul><li>GBK（<strong>国标扩展编码</strong>）是专为中文字符设计的编码方案，向后兼容 ASCII。</li><li>它是 <strong>GB2312</strong> 的扩展版本，支持更多汉字及少数民族文字。</li></ul><h3 id="范围-1"><a href="#范围-1" class="headerlink" title="范围"></a><strong>范围</strong></h3><ul><li><strong>单字节部分</strong>：0x00 - 0x7F，与 ASCII 相同。</li><li><strong>双字节部分</strong>：<ul><li>高字节范围：0x81 - 0xFE。</li><li>低字节范围：0x40 - 0xFE（不包括 0x7F）。</li></ul></li></ul><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li><strong>变长编码</strong>：英文字符占 1 字节，中文字符占 2 字节。</li><li>支持简体中文、繁体中文和部分少数民族文字。</li></ul><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h3><table><thead><tr><th>字符</th><th>GBK 十六进制</th><th>二进制（高低字节）</th></tr></thead><tbody><tr><td>中</td><td>0xD6D0</td><td>11010110 11010000</td></tr><tr><td>文</td><td>0xCEC4</td><td>11001110 11000100</td></tr><tr><td>a</td><td>0x61</td><td>01100001</td></tr><tr><td>空格</td><td>0x20</td><td>00100000</td></tr></tbody></table><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul><li><strong>优点</strong>：支持中文且兼容 ASCII，适合中文本地化。</li><li><strong>缺点</strong>：无法支持多语言，不适合国际化。</li></ul><hr><h2 id="3-Unicode-编码"><a href="#3-Unicode-编码" class="headerlink" title="3. Unicode 编码"></a>3. <strong>Unicode 编码</strong></h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a><strong>定义</strong></h3><ul><li>Unicode 是一种字符集，为每个字符分配一个唯一的码点（码位）。</li><li>Unicode 本身不是一种编码方案，而是字符集的规范。</li><li>Unicode 通过多种编码方案（如 UTF-8、UTF-16、UTF-32）实现存储。</li></ul><h3 id="范围-2"><a href="#范围-2" class="headerlink" title="范围"></a><strong>范围</strong></h3><ul><li>码点范围：0x0000 - 0x10FFFF。</li><li>常用字符范围：<ul><li><strong>基本多文种平面（BMP）</strong>：0x0000 - 0xFFFF。</li><li><strong>扩展平面</strong>：0x10000 - 0x10FFFF。</li></ul></li></ul><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li>能够表示所有语言的字符。</li><li>不同的存储方式（如 UTF-16、UTF-8）具有不同的编码规则。</li></ul><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a><strong>示例</strong></h3><table><thead><tr><th>字符</th><th>Unicode 码点</th><th>十六进制</th><th>二进制</th></tr></thead><tbody><tr><td>中</td><td>0x4E2D</td><td>4E2D</td><td>01001110 00101101</td></tr><tr><td>文</td><td>0x6587</td><td>6587</td><td>01100101 10000111</td></tr><tr><td>A</td><td>0x0041</td><td>0041</td><td>00000000 01000001</td></tr></tbody></table><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul><li><strong>优点</strong>：全球通用字符集，统一编码。</li><li><strong>缺点</strong>：需要结合存储方式（如 UTF-8）才能高效使用。</li></ul><hr><h2 id="4-UTF-8-编码"><a href="#4-UTF-8-编码" class="headerlink" title="4. UTF-8 编码"></a>4. <strong>UTF-8 编码</strong></h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a><strong>定义</strong></h3><ul><li>UTF-8 是 Unicode 的一种存储方式，是一种 <strong>变长编码</strong>。</li><li>适用于互联网与国际化应用。</li></ul><h3 id="范围-3"><a href="#范围-3" class="headerlink" title="范围"></a><strong>范围</strong></h3><ul><li><strong>单字节部分</strong>：0x00 - 0x7F（与 ASCII 相同）。</li><li><strong>多字节部分</strong>：<ul><li>2 字节：0x80 - 0x7FF。</li><li>3 字节：0x800 - 0xFFFF。</li><li>4 字节：0x10000 - 0x10FFFF。</li></ul></li></ul><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li>英文字符占 1 字节，中文字符占 3 字节，生僻字符占 4 字节。</li><li>向后兼容 ASCII，适合多语言环境。</li></ul><h3 id="编码规则"><a href="#编码规则" class="headerlink" title="编码规则"></a><strong>编码规则</strong></h3><ul><li>1 字节：<code>0xxxxxxx</code>（ASCII 范围）。</li><li>2 字节：<code>110xxxxx 10xxxxxx</code>。</li><li>3 字节：<code>1110xxxx 10xxxxxx 10xxxxxx</code>。</li><li>4 字节：<code>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</code>。</li></ul><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a><strong>示例</strong></h3><p>以汉字“严”为例：</p><ul><li>Unicode 码点：0x4E25（二进制 <code>100111000100101</code>）。</li><li>UTF-8 编码：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11100100 10111000 10100101</span><br><span class="line">E4 B8 A5</span><br></pre></td></tr></table></figure></li></ul><table><thead><tr><th>字符</th><th>UTF-8 十六进制</th><th>二进制</th></tr></thead><tbody><tr><td>严</td><td>0xE4B8A5</td><td>11100100 10111000 10100101</td></tr><tr><td>a</td><td>0x61</td><td>01100001</td></tr><tr><td>空格</td><td>0x20</td><td>00100000</td></tr></tbody></table><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul><li><strong>优点</strong>：国际化支持广泛，兼容 ASCII，存储高效。</li><li><strong>缺点</strong>：中文字符占用空间比 GBK 大（3 字节 vs 2 字节）。</li></ul><hr><h2 id="5-ASCII、GBK、Unicode-和-UTF-8-的对比"><a href="#5-ASCII、GBK、Unicode-和-UTF-8-的对比" class="headerlink" title="5. ASCII、GBK、Unicode 和 UTF-8 的对比"></a>5. <strong>ASCII、GBK、Unicode 和 UTF-8 的对比</strong></h2><table><thead><tr><th><strong>编码方式</strong></th><th><strong>字节数</strong></th><th><strong>范围</strong></th><th><strong>适用语言</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><strong>ASCII</strong></td><td>1 字节</td><td>0x00 - 0x7F</td><td>英文</td><td>简单高效，但无法表示中文等语言。</td></tr><tr><td><strong>GBK</strong></td><td>1-2 字节</td><td>0x81 - 0xFE</td><td>中文</td><td>支持中文，兼容 ASCII，不适合多语言环境。</td></tr><tr><td><strong>Unicode</strong></td><td>2 字节及以上</td><td>0x0000 - 0x10FFFF</td><td>所有语言</td><td>统一字符集，需结合具体存储方案。</td></tr><tr><td><strong>UTF-8</strong></td><td>1-4 字节</td><td>0x0000 - 0x10FFFF</td><td>所有语言</td><td>国际化支持最佳，变长编码，向后兼容 ASCII。</td></tr></tbody></table><hr><h2 id="6-编码在实际中的应用"><a href="#6-编码在实际中的应用" class="headerlink" title="6. 编码在实际中的应用"></a>6. <strong>编码在实际中的应用</strong></h2><ol><li><p><strong>ASCII</strong></p><ul><li>用于存储英文文本，如 <code>.txt</code> 文件。</li><li>适用于早期的计算机系统和设备。</li></ul></li><li><p><strong>GBK</strong></p><ul><li>中文环境下的早期标准，如 Windows 中文操作系统。</li><li>适配中文软件，如旧版 Word 文档（.doc）。</li></ul></li><li><p><strong>Unicode</strong></p><ul><li>内存中的统一字符集。</li><li>用于跨语言文本显示和处理（如浏览器、数据库）。</li></ul></li><li><p><strong>UTF-8</strong></p><ul><li>互联网的通用编码，如网页、API 数据传输。</li><li>Web 开发中指定编码：<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>。</li></ul></li></ol><hr><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. <strong>总结</strong></h2><ul><li><strong>ASCII</strong>：历史悠久，简单高效，适用于英文环境。</li><li><strong>GBK</strong>：中文环境的本地化编码，已逐渐被 Unicode 替代。</li><li><strong>Unicode</strong>：统一字符集，解决了多语言字符冲突问题。</li><li><strong>UTF-8</strong>：Unicode 的最佳实现方式，适合互联网与国际化应用。</li></ul><p>通过选择合适的编码方式，可以有效避免乱码问题，提升存储与传输效率！</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASCII </tag>
            
            <tag> GBK </tag>
            
            <tag> Unicode </tag>
            
            <tag> UTF-8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Base64</title>
      <link href="/2024/12/18/Base64/"/>
      <url>/2024/12/18/Base64/</url>
      
        <content type="html"><![CDATA[<h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Base64是一种<strong>二进制到文本的编码方式</strong>，用于将二进制数据编码为仅包含ASCII基础字符的字符串。Base64的主要特点是它将<strong>每三个字节（24位）转换为四个Base64字符</strong>，使其可以安全地在各种文本协议中传输。</p><p>例如，字符串<code>Lavoisier707</code>对应的Base64编码是<code>TGF2b2lzYWlyNzA3</code>。其中的<code>=</code>是填充符号，用于保证编码后的字符数量是4的倍数。</p><p>需要注意的是，<strong>Base64并不是加密算法</strong>。它仅仅是一种编码方式，其算法是公开的，因此不能用于保护数据的机密性。</p><hr><h3 id="Base64字符与二进制对照表"><a href="#Base64字符与二进制对照表" class="headerlink" title="Base64字符与二进制对照表"></a>Base64字符与二进制对照表</h3><p>Base64得名于其编码方式中使用的<strong>64个字符</strong>。这些字符由以下几组组成：</p><ul><li>大写字母：<code>A-Z</code>（26个）</li><li>小写字母：<code>a-z</code>（26个）</li><li>数字：<code>0-9</code>（10个）</li><li>两个特殊符号：<code>+</code> 和 <code>/</code></li></ul><p>在编码过程中，Base64将二进制数据每6位一组，对应上面64个字符中的一个。因此，这种编码方式基于64个字符，因此称为Base64。</p><p>以下是Base64编码中每个字符与其二进制值的对照表：</p><table><thead><tr><th>Base64字符</th><th>二进制值</th><th>Base64字符</th><th>二进制值</th><th>Base64字符</th><th>二进制值</th><th>Base64字符</th><th>二进制值</th></tr></thead><tbody><tr><td>A</td><td>000000</td><td>Q</td><td>010000</td><td>g</td><td>100000</td><td>w</td><td>110000</td></tr><tr><td>B</td><td>000001</td><td>R</td><td>010001</td><td>h</td><td>100001</td><td>x</td><td>110001</td></tr><tr><td>C</td><td>000010</td><td>S</td><td>010010</td><td>i</td><td>100010</td><td>y</td><td>110010</td></tr><tr><td>D</td><td>000011</td><td>T</td><td>010011</td><td>j</td><td>100011</td><td>z</td><td>110011</td></tr><tr><td>E</td><td>000100</td><td>U</td><td>010100</td><td>k</td><td>100100</td><td>0</td><td>110100</td></tr><tr><td>F</td><td>000101</td><td>V</td><td>010101</td><td>l</td><td>100101</td><td>1</td><td>110101</td></tr><tr><td>G</td><td>000110</td><td>W</td><td>010110</td><td>m</td><td>100110</td><td>2</td><td>110110</td></tr><tr><td>H</td><td>000111</td><td>X</td><td>010111</td><td>n</td><td>100111</td><td>3</td><td>110111</td></tr><tr><td>I</td><td>001000</td><td>Y</td><td>011000</td><td>o</td><td>101000</td><td>4</td><td>111000</td></tr><tr><td>J</td><td>001001</td><td>Z</td><td>011001</td><td>p</td><td>101001</td><td>5</td><td>111001</td></tr><tr><td>K</td><td>001010</td><td>a</td><td>011010</td><td>q</td><td>101010</td><td>6</td><td>111010</td></tr><tr><td>L</td><td>001011</td><td>b</td><td>011011</td><td>r</td><td>101011</td><td>7</td><td>111011</td></tr><tr><td>M</td><td>001100</td><td>c</td><td>011100</td><td>s</td><td>101100</td><td>8</td><td>111100</td></tr><tr><td>N</td><td>001101</td><td>d</td><td>011101</td><td>t</td><td>101101</td><td>9</td><td>111101</td></tr><tr><td>O</td><td>001110</td><td>e</td><td>011110</td><td>u</td><td>101110</td><td>+</td><td>111110</td></tr><tr><td>P</td><td>001111</td><td>f</td><td>011111</td><td>v</td><td>101111</td><td>&#x2F;</td><td>111111</td></tr></tbody></table><p><strong>填充符号：</strong> <code>=</code> 用于填充不足的二进制数据，确保编码结果是4的倍数。</p><hr><h3 id="编码原理"><a href="#编码原理" class="headerlink" title="编码原理"></a>编码原理</h3><ol><li><p><strong>数据分组</strong>：</p><ul><li>将原始数据按照每3个字节（24位）一组进行分割。</li></ul></li><li><p><strong>二进制分块</strong>：</p><ul><li>每个分组的24位被拆分成4个6位单元。</li></ul></li><li><p><strong>字符映射</strong>：</p><ul><li>每个6位单元被映射为一个Base64字符。</li></ul></li><li><p><strong>填充机制</strong>：</p><ul><li>如果原始数据的字节数不是3的倍数，用<code>0</code>填充到下一个3字节的边界，并在编码结果中用<code>=</code>表示填充的内容。</li><li>剩余1个字节时，编码后补充2个<code>=</code>；</li><li>剩余2个字节时，编码后补充1个<code>=</code>。</li></ul></li></ol><hr><h3 id="编码示例"><a href="#编码示例" class="headerlink" title="编码示例"></a>编码示例</h3><h4 id="示例：编码字符串-Man"><a href="#示例：编码字符串-Man" class="headerlink" title="示例：编码字符串 Man"></a>示例：编码字符串 <code>Man</code></h4><ul><li>原始数据（ASCII值）：<code>M</code> &#x3D; 77，<code>a</code> &#x3D; 97，<code>n</code> &#x3D; 110</li><li>转为二进制：<code>M</code> &#x3D; <code>01001101</code>，<code>a</code> &#x3D; <code>01100001</code>，<code>n</code> &#x3D; <code>01101110</code></li><li>合并为24位二进制：<code>01001101 01100001 01101110</code></li><li>按6位分组：<code>010011</code> <code>010110</code> <code>000101</code> <code>101110</code></li><li>映射Base64字符：<code>T</code> <code>W</code> <code>F</code> <code>u</code></li></ul><p>编码结果为：<code>TWFu</code></p><h4 id="示例：编码不足3字节的数据"><a href="#示例：编码不足3字节的数据" class="headerlink" title="示例：编码不足3字节的数据"></a>示例：编码不足3字节的数据</h4><ol><li><strong>原始数据</strong>：<code>Ma</code>  <ul><li>ASCII值：<code>M</code> &#x3D; 77，<code>a</code> &#x3D; 97  </li><li>转为二进制：<code>M</code> &#x3D; <code>01001101</code>，<code>a</code> &#x3D; <code>01100001</code>  </li><li>合并为16位：<code>01001101 01100001</code>  </li><li>填充到24位：<code>01001101 01100001 00000000</code>  </li><li>按6位分组：<code>010011</code> <code>010110</code> <code>000100</code> <code>000000</code>  </li><li>映射Base64字符：<code>T</code> <code>W</code> <code>E</code> <code>=</code></li></ul></li></ol><p>编码结果为：<code>TWE=</code></p><ol start="2"><li><strong>原始数据</strong>：<code>M</code>  <ul><li>ASCII值：<code>M</code> &#x3D; 77  </li><li>转为二进制：<code>M</code> &#x3D; <code>01001101</code>  </li><li>合并为8位：<code>01001101</code>  </li><li>填充到24位：<code>01001101 00000000 00000000</code>  </li><li>按6位分组：<code>010011</code> <code>010000</code> <code>000000</code> <code>000000</code>  </li><li>映射Base64字符：<code>T</code> <code>Q</code> <code>=</code> <code>=</code></li></ul></li></ol><p>编码结果为：<code>TQ==</code></p><hr><h3 id="Base64设计意图"><a href="#Base64设计意图" class="headerlink" title="Base64设计意图"></a>Base64设计意图</h3><p>Base64的核心目标是<strong>解决二进制数据在某些系统或环境中无法直接传输和存储的问题</strong>，具体包括：</p><ol><li><p><strong>不可见字符问题</strong>：</p><ul><li>二进制数据可能包含不可见字符或控制字符，无法直接在纯文本协议中传输。</li></ul></li><li><p><strong>跨平台兼容性</strong>：</p><ul><li>不同平台或协议可能对二进制数据的解释不同，而Base64编码后的数据是一串ASCII字符，可以在不同平台间无损传输。</li></ul></li><li><p><strong>文本协议的限制</strong>：</p><ul><li>如SMTP（电子邮件协议）只能传输文本数据，而Base64可以将二进制数据转换为文本形式。</li></ul></li></ol><hr><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li><strong>跨平台兼容</strong>：编码后的文本可以无损传输到不同的平台和协议。</li><li><strong>简单高效</strong>：编码和解码速度快，算法简单。</li><li><strong>数据完整性</strong>：解决了二进制数据在不支持二进制的环境中传输时可能出现的损失问题。</li><li><strong>可读性增强</strong>：虽然Base64编码的数据对人类不可直接阅读，但其文本形式更容易存储和传输。</li></ol><hr><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li><strong>增加数据量</strong>：编码后数据量比原始数据多约33%（4&#x2F;3倍）。</li><li><strong>不提供安全性</strong>：Base64编码的内容可以轻松解码，无法用于保护敏感信息。</li><li><strong>传输效率低</strong>：在大数据传输中，数据量的增加会降低效率。</li></ol><hr><h3 id="Base64编码的应用场景"><a href="#Base64编码的应用场景" class="headerlink" title="Base64编码的应用场景"></a>Base64编码的应用场景</h3><ol><li><strong>电子邮件附件</strong>：SMTP协议中，Base64用于将二进制附件编码为文本格式。</li><li><strong>数字证书</strong>：如PEM格式的证书和密钥。</li><li><strong>网页嵌入小图片</strong>：Base64编码的小图片可以直接嵌入HTML或CSS中，减少网络请求。</li><li><strong>数据URI格式</strong>：如<code>data:image/jpeg;base64,...</code>，用于在网页中嵌入文件数据。</li><li><strong>XML嵌套数据</strong>：在XML中嵌入文件或数据时，Base64用于避免标签冲突。</li><li><strong>URL中的数据</strong>：在HTTP GET请求中传递数据时，使用URL安全的Base64编码。</li></ol><hr><h3 id="Base64-编码程序"><a href="#Base64-编码程序" class="headerlink" title="Base64 编码程序"></a>Base64 编码程序</h3><p>以下程序可以将用户输入的字符串转换为 Base64 编码的字符串：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode_base64</span>():</span><br><span class="line">    <span class="comment"># 输入字符串</span></span><br><span class="line">    original_string = <span class="built_in">input</span>(<span class="string">&quot;请输入要编码的字符串: &quot;</span>)</span><br><span class="line">    <span class="comment"># 将字符串转换为字节</span></span><br><span class="line">    byte_data = original_string.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="comment"># 使用 base64 编码</span></span><br><span class="line">    base64_encoded = base64.b64encode(byte_data)</span><br><span class="line">    <span class="comment"># 将字节转换为字符串</span></span><br><span class="line">    encoded_string = base64_encoded.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Base64 编码结果: <span class="subst">&#123;encoded_string&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">encode_base64()</span><br></pre></td></tr></table></figure><hr><h3 id="Base64-解码程序"><a href="#Base64-解码程序" class="headerlink" title="Base64 解码程序"></a>Base64 解码程序</h3><p>以下程序可以将 Base64 编码的字符串解码为原始字符串：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode_base64</span>():</span><br><span class="line">    <span class="comment"># 输入 Base64 编码的字符串</span></span><br><span class="line">    base64_string = <span class="built_in">input</span>(<span class="string">&quot;请输入要解码的 Base64 字符串: &quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 将字符串转换为字节并解码</span></span><br><span class="line">        byte_data = base64.b64decode(base64_string)</span><br><span class="line">        <span class="comment"># 将字节转换为原始字符串</span></span><br><span class="line">        decoded_string = byte_data.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;解码后的原始字符串: <span class="subst">&#123;decoded_string&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;解码失败: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">decode_base64()</span><br></pre></td></tr></table></figure><hr><h3 id="变种"><a href="#变种" class="headerlink" title="变种"></a>变种</h3><ol><li><p><strong>URL安全的Base64</strong>：</p><ul><li>将<code>+</code>替换为<code>-</code>，<code>/</code>替换为<code>_</code>，去掉填充符号<code>=</code>，避免URL编码问题。</li></ul></li><li><p><strong>正则表达式安全的Base64</strong>：</p><ul><li>将<code>+</code>替换为<code>!</code>，<code>/</code>替换为<code>-</code>，避免正则表达式中的特殊字符冲突。</li></ul></li><li><p><strong>其他变种</strong>：</p><ul><li>替换<code>+/</code>为<code>._</code>、<code>._</code>等，用于满足特定场景或语言的需求。</li></ul></li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Base64是一种将二进制数据编码为文本格式的简单而强大的工具，广泛用于电子邮件、证书、数据嵌入等场景。尽管其增加了数据量且不具备安全性，但它在跨平台兼容性和数据完整性方面有着不可替代的作用。在实际使用中，应根据场景选择适合的编码方案或变种。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Base64 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>书评特辑·第三期</title>
      <link href="/2024/12/11/Book_Review3/"/>
      <url>/2024/12/11/Book_Review3/</url>
      
        <content type="html"><![CDATA[<h1 id="爱情的双生花：无私与自私的千年之辩"><a href="#爱情的双生花：无私与自私的千年之辩" class="headerlink" title="爱情的双生花：无私与自私的千年之辩"></a>爱情的双生花：无私与自私的千年之辩</h1><p><em>我偏要勉强，是最单纯的表白<br>倘若我问心有愧呢，是最复杂的试探<br>终究还是周不如赵可为良配</em></p><p>在敦煌莫高窟第257窟的《须摩提女因缘图》中，佛陀化现的三十四匹神兽踏云而来，恰似爱情在人类文明长河中幻化的万千姿态。从殷商甲骨文中记载的”妃燎于河”祭祀婚约，到元宇宙里虚拟恋人的数据纠缠，人类始终在用不同时代的语言，复述着关于占有与成全的永恒辩题。爱情的双生花，一株扎根于本能的私欲土壤，一株生长在精神的云端，却共享着同一片人性的星空。</p><h2 id="一、刀剑江湖里的红玫瑰与白月光"><a href="#一、刀剑江湖里的红玫瑰与白月光" class="headerlink" title="一、刀剑江湖里的红玫瑰与白月光"></a>一、刀剑江湖里的红玫瑰与白月光</h2><p>金庸在《倚天屠龙记》中埋下惊心动魄的隐喻：周芷若的九阴白骨爪抓碎的是对纯粹之爱的执念，赵敏那句”我偏要勉强”的宣言，实则是将私心炼化成破釜沉舟的勇气。光明顶上，周芷若的”倘若我问心有愧”如同淬毒的银针，刺破了礼教规训下压抑的私欲；而绿柳山庄内地牢之中，赵敏褪去鞋袜的瞬间，早已让江山与江湖都成了爱情的注脚。</p><p>这让人想起《红楼梦》中尤三姐饮剑自刎时溅在湘裙上的桃花血痕，与史湘云醉卧芍药裀时口中喃喃的”泉香酒冽”。中国古典文学中的爱情叙事，总在礼教铁幕下绽放出惊世骇俗的私欲之花。正如赵敏不惜背叛家国也要追随张无忌，这种看似自私的选择，实则完成了对封建伦理最决绝的反叛。</p><h2 id="二、理想国与资本论之间的玫瑰"><a href="#二、理想国与资本论之间的玫瑰" class="headerlink" title="二、理想国与资本论之间的玫瑰"></a>二、理想国与资本论之间的玫瑰</h2><p>在伦敦大英博物馆的水泥地板上，卡尔·马克思的皮鞋磨出的两道凹痕旁，始终徘徊着燕妮的倩影。当这位普鲁士贵族小姐将婚约藏在蔷薇花束中递给贫寒学子时，她选择的不仅是爱情，更是将私人的欢愉升华为人类解放的圣火。他们在流亡途中典当最后一条银餐具时相视而笑的模样，恰似《共产党宣言》中最温柔的注脚——真正的爱情，能在物质世界的废墟上建立精神的丰碑。</p><p>这种超越性的爱恋，在敦煌遗书《搜神记》中早有呼应：敦煌女子阿丑甘愿化作金像，只为守护戍边丈夫的灵魂。当燕妮在马克思手稿的字里行间寻找丈夫的温度时，她的爱早已超越了世俗的占有欲，如同敦煌壁画中的飞天，将私密的絮语编织成普世的精神图谱。</p><h2 id="三、青铜剑与量子纠缠的时空对话"><a href="#三、青铜剑与量子纠缠的时空对话" class="headerlink" title="三、青铜剑与量子纠缠的时空对话"></a>三、青铜剑与量子纠缠的时空对话</h2><p>在湖北云梦睡虎地出土的秦简《日书》里，记载着”戊申疾，得于赤色女子”的古老占卜，而在现代基因测序仪中，科学家发现了催产素受体基因如何影响人类的依恋模式。从青铜时代武士为爱人铸造的鸾鸟纹铜镜，到元宇宙中恋人共享的脑机接口，人类始终在用最新科技具象化最原始的情感冲动。</p><p>三星堆青铜神树上的十二只太阳鸟，与巴黎蒙马特高地电子屏上的心跳曲线，共同诠释着爱情的永恒悖论：我们既渴望《牡丹亭》中”生者可以死，死者可以生”的极致占有，又向往萨特与波伏娃式”必然之爱”的精神共和。就像敦煌《降魔变文》中魔王用私欲幻化的妖女，与佛陀以慈悲化现的飞天，本是人性的一体两面。</p><p>在安阳殷墟妇好墓出土的司母辛方鼎内壁，考古学家发现了三千年前的碳化玫瑰花瓣。这些曾经鲜艳的私欲之火，经过岁月淬炼，最终凝固成见证永恒的无私结晶。当我们在上海天文馆的穹顶下仰望猎户座星云，或许该明白：爱情最动人的模样，不是非此即彼的单选题，而是让自私的星尘在无私的宇宙中，绽放出照亮永恒的光谱。</p><p>正可谓：</p><p><strong>君不见<br>黛玉忧思 宝玉之苦<br>梁祝相约 化蝶为舞<br>有凤求凰 司马相如<br>鹊桥之上 如泣如诉<br>都说三毛癫狂 皆因荷西身故<br>都说卡尔与燕妮那样的爱情才让人羡慕<br>众生皆问 爱情归宿<br>我有一言 点明心路<br>爱本无私 爱要大度<br>君不见<br>梁思成从不问林徽因<br>你与那徐志摩当年如何一见如故<br>话分两头 听我从新表述<br>情本自私 又如何大度<br>纵使粉身碎骨 纵使万劫不复<br>我也待你眉眼如初 这岁月如故</strong></p>]]></content>
      
      
      <categories>
          
          <category> Book Review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 金庸 </tag>
            
            <tag> 《倚天屠龙记》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2024/12/06/Regular_Expression/"/>
      <url>/2024/12/06/Regular_Expression/</url>
      
        <content type="html"><![CDATA[<h2 id="正则表达式详细总结"><a href="#正则表达式详细总结" class="headerlink" title="正则表达式详细总结"></a><strong>正则表达式详细总结</strong></h2><p>正则表达式（Regular Expression，简称 RegEx）是一种强大的工具，用于匹配、查找、替换符合特定规则的字符串。它广泛应用于文本处理、表单验证、数据提取等场景。</p><hr><h3 id="一、正则表达式的组成"><a href="#一、正则表达式的组成" class="headerlink" title="一、正则表达式的组成"></a><strong>一、正则表达式的组成</strong></h3><p>正则表达式由普通字符和具有特殊含义的元字符（metacharacters）组成。普通字符包括字母、数字和其他未被正则表达式解释的字符。而元字符则用来构建匹配规则。</p><hr><h3 id="二、元字符"><a href="#二、元字符" class="headerlink" title="二、元字符"></a><strong>二、元字符</strong></h3><p>元字符是正则表达式中具有特殊含义的字符。以下是常见的元字符及其功能：</p><table><thead><tr><th align="left">元字符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>.</code></td><td align="left">匹配除换行符以外的任意单个字符</td></tr><tr><td align="left"><code>\w</code></td><td align="left">匹配字母、数字、下划线</td></tr><tr><td align="left"><code>\s</code></td><td align="left">匹配空白字符（空格、制表符、换页符等）</td></tr><tr><td align="left"><code>\d</code></td><td align="left">匹配数字（0-9）</td></tr><tr><td align="left"><code>\b</code></td><td align="left">匹配单词边界</td></tr><tr><td align="left"><code>^</code></td><td align="left">匹配字符串的开头（在集合内，如 <code>[^a]</code>，表示“非”）</td></tr><tr><td align="left"><code>$</code></td><td align="left">匹配字符串的结尾</td></tr><tr><td align="left"><code>[]</code></td><td align="left">匹配方括号内的任意字符，例如 <code>[aeiou]</code> 匹配任意元音字母</td></tr><tr><td align="left"><code>[^]</code></td><td align="left">匹配不在括号内的字符，例如 <code>[^aeiou]</code> 匹配非元音字母</td></tr><tr><td align="left"><code>\</code></td><td align="left">转义字符，用于匹配元字符本身（如 <code>\.</code> 匹配字符 <code>.</code>）</td></tr></tbody></table><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h4><ol><li><strong><code>.</code> 匹配任意字符</strong>：<code>a.b</code> 匹配 <code>acb</code>、<code>a1b</code> 等，但不匹配 <code>ab</code>。</li><li><strong><code>\d</code> 匹配数字</strong>：<code>\d&#123;3&#125;</code> 匹配连续的三个数字，如 <code>123</code>。</li><li><strong><code>^</code> 和 <code>$</code> 匹配开头和结尾</strong>：<code>^abc$</code> 匹配整个字符串是 <code>abc</code>。</li></ol><hr><h3 id="三、反义字符"><a href="#三、反义字符" class="headerlink" title="三、反义字符"></a><strong>三、反义字符</strong></h3><p>反义字符用于匹配某类字符的非集合内容。</p><table><thead><tr><th align="left">反义字符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>\W</code></td><td align="left">匹配非字母、数字、下划线的字符</td></tr><tr><td align="left"><code>\S</code></td><td align="left">匹配非空白字符</td></tr><tr><td align="left"><code>\D</code></td><td align="left">匹配非数字字符</td></tr><tr><td align="left"><code>\B</code></td><td align="left">匹配非单词边界</td></tr><tr><td align="left"><code>[^x]</code></td><td align="left">匹配除了 <code>x</code> 以外的任意字符</td></tr><tr><td align="left"><code>[^abc]</code></td><td align="left">匹配除了 <code>a</code>、<code>b</code>、<code>c</code> 以外的任意字符</td></tr></tbody></table><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h4><ol><li><strong><code>\W</code> 匹配非单词字符</strong>：如 <code>+</code>、<code>#</code> 等。</li><li><strong><code>\S</code> 匹配非空白字符</strong>：如 <code>a</code> 或 <code>1</code>。</li></ol><hr><h3 id="四、限定符"><a href="#四、限定符" class="headerlink" title="四、限定符"></a><strong>四、限定符</strong></h3><p>限定符用于指定匹配字符的重复次数。</p><table><thead><tr><th align="left">限定符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>*</code></td><td align="left">匹配前面的字符 0 次或多次</td></tr><tr><td align="left"><code>+</code></td><td align="left">匹配前面的字符 1 次或多次</td></tr><tr><td align="left"><code>?</code></td><td align="left">匹配前面的字符 0 次或 1 次</td></tr><tr><td align="left"><code>&#123;n&#125;</code></td><td align="left">匹配前面的字符恰好 n 次</td></tr><tr><td align="left"><code>&#123;n,&#125;</code></td><td align="left">匹配前面的字符至少 n 次</td></tr><tr><td align="left"><code>&#123;n,m&#125;</code></td><td align="left">匹配前面的字符 n 到 m 次</td></tr></tbody></table><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a><strong>示例</strong></h4><ol><li><strong><code>a*</code> 匹配 0 或多次 a</strong>：可匹配 <code>&quot;&quot;</code>、<code>a</code>、<code>aa</code> 等。</li><li><strong><code>\d&#123;3,5&#125;</code> 匹配 3 到 5 位数字</strong>：如 <code>123</code> 或 <code>12345</code>。</li></ol><hr><h3 id="五、懒惰匹配和贪婪匹配"><a href="#五、懒惰匹配和贪婪匹配" class="headerlink" title="五、懒惰匹配和贪婪匹配"></a><strong>五、懒惰匹配和贪婪匹配</strong></h3><ul><li><strong>贪婪匹配</strong>：默认行为，尽可能多地匹配字符。</li><li><strong>懒惰匹配</strong>：通过添加 <code>?</code>，匹配尽可能少的字符。</li></ul><table><thead><tr><th align="left">贪婪匹配</th><th align="left">懒惰匹配</th></tr></thead><tbody><tr><td align="left"><code>.*</code></td><td align="left"><code>.*?</code></td></tr><tr><td align="left"><code>.+</code></td><td align="left"><code>.+?</code></td></tr><tr><td align="left"><code>.?</code></td><td align="left"><code>??</code></td></tr><tr><td align="left"><code>&#123;n,m&#125;</code></td><td align="left"><code>&#123;n,m&#125;?</code></td></tr></tbody></table><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a><strong>示例</strong></h4><ol><li><strong>贪婪匹配</strong>：<code>a.*b</code> 匹配 <code>a123b456b</code> 的整个字符串。</li><li><strong>懒惰匹配</strong>：<code>a.*?b</code> 匹配 <code>a123b</code>。</li></ol><hr><h3 id="六、分组与分枝"><a href="#六、分组与分枝" class="headerlink" title="六、分组与分枝"></a><strong>六、分组与分枝</strong></h3><h4 id="1-分组"><a href="#1-分组" class="headerlink" title="1. 分组"></a><strong>1. 分组</strong></h4><p>分组通过括号 <code>()</code> 将一部分规则组合为一个整体。</p><table><thead><tr><th align="left">语法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>(exp)</code></td><td align="left">捕获分组，匹配 exp 并捕获到分组</td></tr><tr><td align="left"><code>(?:exp)</code></td><td align="left">非捕获分组，匹配 exp 但不捕获</td></tr><tr><td align="left"><code>(?&lt;name&gt;exp)</code></td><td align="left">命名捕获分组，匹配 exp 并捕获为 name 的组</td></tr></tbody></table><h4 id="2-分枝"><a href="#2-分枝" class="headerlink" title="2. 分枝"></a><strong>2. 分枝</strong></h4><p>分枝通过 <code>|</code> 表示“或”关系。</p><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a><strong>示例</strong></h4><ol><li><strong>捕获分组</strong>：<code>(ab)+</code> 匹配 <code>abab</code>，捕获 <code>ab</code>。</li><li><strong>分枝</strong>：<code>a|b</code> 匹配 <code>a</code> 或 <code>b</code>，例如 <code>cat|dog</code> 匹配 <code>cat</code> 或 <code>dog</code>。</li></ol><hr><h3 id="七、零宽断言"><a href="#七、零宽断言" class="headerlink" title="七、零宽断言"></a><strong>七、零宽断言</strong></h3><p>零宽断言用于匹配满足某些条件的位置，而不消费字符。</p><table><thead><tr><th align="left">语法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>(?=exp)</code></td><td align="left">正向预测断言，匹配后面是 exp 的位置</td></tr><tr><td align="left"><code>(?!exp)</code></td><td align="left">负向预测断言，匹配后面不是 exp 的位置</td></tr><tr><td align="left"><code>(?&lt;=exp)</code></td><td align="left">正向回顾断言，匹配前面是 exp 的位置</td></tr><tr><td align="left"><code>(?&lt;!exp)</code></td><td align="left">负向回顾断言，匹配前面不是 exp 的位置</td></tr></tbody></table><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a><strong>示例</strong></h4><ol><li><strong>正向预测</strong>：<code>\w+(?=ing)</code> 匹配 <code>sing</code> 中的 <code>sing</code>。</li><li><strong>负向回顾</strong>：<code>(?&lt;!not )good</code> 匹配 <code>good</code>，但不匹配 <code>not good</code>。</li></ol><hr><h3 id="八、后向引用"><a href="#八、后向引用" class="headerlink" title="八、后向引用"></a><strong>八、后向引用</strong></h3><p>后向引用可以重复匹配捕获分组内的内容。</p><table><thead><tr><th align="left">语法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>\1</code></td><td align="left">引用第一个捕获分组的内容</td></tr><tr><td align="left"><code>\k&lt;name&gt;</code></td><td align="left">引用命名捕获分组 name 的内容</td></tr></tbody></table><h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a><strong>示例</strong></h4><ol><li>**<code>\1</code>**：<code>\b(\w+)\b\s+\1</code> 匹配重复单词（如 <code>go go</code>）。</li><li>**<code>\k&lt;name&gt;</code>**：<code>(?&lt;word&gt;\w+)\s+\k&lt;word&gt;</code> 匹配命名分组的重复。</li></ol><hr><h3 id="九、转义字符"><a href="#九、转义字符" class="headerlink" title="九、转义字符"></a><strong>九、转义字符</strong></h3><p>转义字符用于匹配元字符本身。</p><table><thead><tr><th align="left">转义字符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>\.</code></td><td align="left">匹配字符 <code>.</code></td></tr><tr><td align="left"><code>\*</code></td><td align="left">匹配字符 <code>*</code></td></tr><tr><td align="left"><code>\?</code></td><td align="left">匹配字符 <code>?</code></td></tr><tr><td align="left"><code>\\</code></td><td align="left">匹配字符 <code>\</code></td></tr></tbody></table><hr><h3 id="十、常用正则表达式"><a href="#十、常用正则表达式" class="headerlink" title="十、常用正则表达式"></a><strong>十、常用正则表达式</strong></h3><table><thead><tr><th align="left">功能</th><th align="left">表达式</th></tr></thead><tbody><tr><td align="left">匹配数字</td><td align="left"><code>^\d+$</code></td></tr><tr><td align="left">匹配邮箱</td><td align="left"><code>^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$</code></td></tr><tr><td align="left">匹配 IP 地址</td><td align="left">&#96;^((25[0-5]</td></tr><tr><td align="left">匹配日期（yyyy-mm-dd）</td><td align="left">&#96;^(19</td></tr><tr><td align="left">匹配中文</td><td align="left"><code>^[\u4e00-\u9fa5]+$</code></td></tr><tr><td align="left">匹配 URL</td><td align="left"><code>^https?:\/\/[\w\-]+(\.[\w\-]+)+[\w\-\.,@?^=%&amp;:/~+#]*$</code></td></tr></tbody></table><hr><h3 id="十一、正则表达式的模式修饰符"><a href="#十一、正则表达式的模式修饰符" class="headerlink" title="十一、正则表达式的模式修饰符"></a><strong>十一、正则表达式的模式修饰符</strong></h3><table><thead><tr><th align="left">修饰符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>i</code></td><td align="left">忽略大小写</td></tr><tr><td align="left"><code>m</code></td><td align="left">多行模式，<code>^</code> 和 <code>$</code> 匹配每行的开头和结尾</td></tr><tr><td align="left"><code>s</code></td><td align="left">单行模式，使 <code>.</code> 匹配包括换行符在内的所有字符</td></tr><tr><td align="left"><code>x</code></td><td align="left">忽略空白符并启用注释</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式系统</title>
      <link href="/2024/12/06/Distributed_System/"/>
      <url>/2024/12/06/Distributed_System/</url>
      
        <content type="html"><![CDATA[<p>本文基于 SYSU-DCS325 的内容，对计算机专业课《分布式系统》进行较为详尽的知识点总结，涵盖少量实例分析。</p><h3 id="1-课程概述"><a href="#1-课程概述" class="headerlink" title="1. 课程概述"></a>1. 课程概述</h3><h4 id="1-1-课程目标"><a href="#1-1-课程目标" class="headerlink" title="1.1 课程目标"></a>1.1 课程目标</h4><ol><li>理解分布式系统的基本概念与核心原理。</li><li>掌握分布式系统的架构设计方法。</li><li>学习分布式系统的编程技术与工具。</li><li>了解分布式系统的运维与管理策略。</li><li>探索分布式系统领域的前沿技术与发展趋势。</li><li>激发学生对分布式系统研究与应用的兴趣。</li></ol><h4 id="1-2-课程内容安排"><a href="#1-2-课程内容安排" class="headerlink" title="1.2 课程内容安排"></a>1.2 课程内容安排</h4><table><thead><tr><th>章节</th><th>内容</th></tr></thead><tbody><tr><td>第1讲</td><td>分布式系统概述</td></tr><tr><td>第2讲</td><td>分布式系统体系架构</td></tr><tr><td>第3讲</td><td>分布式系统进程模型</td></tr><tr><td>第4讲</td><td>分布式系统通信</td></tr><tr><td>第5讲</td><td>分布式系统命名</td></tr><tr><td>第6讲</td><td>时钟与时间同步</td></tr><tr><td>第7讲</td><td>分布式系统同步</td></tr><tr><td>第8讲</td><td>分布式系统一致性</td></tr><tr><td>第9讲</td><td>分布式系统复制</td></tr><tr><td>第10讲</td><td>容错与可靠性保障</td></tr><tr><td>第11讲</td><td>分布式系统共识</td></tr><tr><td>第12讲</td><td>Paxos及RAFT协议</td></tr><tr><td>第13讲</td><td>分布式文件系统与存储系统</td></tr><tr><td>第14讲</td><td>面向大数据与AI的分布式计算框架</td></tr><tr><td>第15讲</td><td>P2P及内容分发网络</td></tr></tbody></table><h3 id="2-分布式系统基础概念"><a href="#2-分布式系统基础概念" class="headerlink" title="2. 分布式系统基础概念"></a>2. 分布式系统基础概念</h3><h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h4><p>分布式系统是由多个自主且独立的计算机通过网络互联而成的集合，对用户而言，这些计算机像是一个单一的整体系统。</p><p><strong>Leslie Lamport</strong> 的著名定义：</p><blockquote><p>“A distributed system is one in which the failure of a computer you didn’t even know existed can render your own computer unusable.”</p></blockquote><h4 id="2-2-特性"><a href="#2-2-特性" class="headerlink" title="2.2 特性"></a>2.2 特性</h4><ol><li><p><strong>自主性</strong></p><ul><li>计算节点的硬件与软件进程独立运行。</li><li>节点在物理上分布，而在逻辑上协调一致。</li></ul></li><li><p><strong>耦合性</strong></p><ul><li>用户感知系统为一个整体，隐藏了内部的分布性。</li><li>节点之间需要协作，共同完成任务。</li></ul></li><li><p><strong>其他特性</strong></p><ul><li>组件由所有用户共享访问。</li><li>系统资源可能分布在不同的物理位置，不一定直接可访问。</li><li>软件运行在不同处理器上的多个并发进程中。</li><li>支持多点控制和多点故障。</li></ul></li></ol><h3 id="3-分布式系统目标"><a href="#3-分布式系统目标" class="headerlink" title="3. 分布式系统目标"></a>3. 分布式系统目标</h3><p>分布式系统设计主要围绕以下四个目标：</p><ol><li><p><strong>资源访问</strong></p><ul><li>提供便捷的资源访问方式，用户无需关注资源的实际存储位置。</li></ul></li><li><p><strong>透明性</strong></p><ul><li>隐藏资源在网络上的分布，包括访问、位置、复制等方面的透明性。</li></ul></li><li><p><strong>开放性</strong></p><ul><li>采用标准化的接口，确保系统的可扩展性和互操作性。</li></ul></li><li><p><strong>可扩展性</strong></p><ul><li>系统能够在规模、地域和管理上灵活扩展，以适应不断增长的需求。</li></ul></li></ol><h4 id="3-1-透明性的详细分类"><a href="#3-1-透明性的详细分类" class="headerlink" title="3.1 透明性的详细分类"></a>3.1 透明性的详细分类</h4><table><thead><tr><th>透明性类型</th><th>说明</th></tr></thead><tbody><tr><td>访问</td><td>隐藏不同的数据表示形式及资源访问方式</td></tr><tr><td>位置</td><td>隐藏资源的实际物理位置</td></tr><tr><td>迁移</td><td>隐藏资源的动态移动，确保资源位置变化对用户透明</td></tr><tr><td>重定位</td><td>隐藏资源在使用过程中可能的迁移动作</td></tr><tr><td>复制</td><td>隐藏资源是否存在多个副本</td></tr><tr><td>并发</td><td>隐藏多个用户对资源的并发访问</td></tr><tr><td>故障</td><td>隐藏系统资源的故障与恢复过程</td></tr><tr><td>持久化</td><td>隐藏数据在主存与磁盘之间的存储细节</td></tr></tbody></table><p><strong>注意</strong>：完全透明性难以实现，且可能带来性能开销。因此，设计时需在透明性与系统性能之间找到平衡。</p><h3 id="4-可扩展性"><a href="#4-可扩展性" class="headerlink" title="4. 可扩展性"></a>4. 可扩展性</h3><h4 id="4-1-可扩展性的三个维度"><a href="#4-1-可扩展性的三个维度" class="headerlink" title="4.1 可扩展性的三个维度"></a>4.1 可扩展性的三个维度</h4><ol><li><p><strong>规模可扩展性</strong></p><ul><li>支持用户数量和处理进程数量的增加。</li></ul></li><li><p><strong>地理可扩展性</strong></p><ul><li>支持节点分布在广泛的地理位置，确保跨地域的数据访问与计算。</li></ul></li><li><p><strong>管理可扩展性</strong></p><ul><li>系统管理结构能够适应管理域和组织结构的扩展。</li></ul></li></ol><h4 id="4-2-扩展技术"><a href="#4-2-扩展技术" class="headerlink" title="4.2 扩展技术"></a>4.2 扩展技术</h4><ol><li><p><strong>隐藏通信延迟</strong></p><ul><li>使用异步通信技术，减少同步等待。</li><li>设计分离的响应消息处理器，提高响应效率。</li><li>将部分计算任务从服务器端迁移至客户端，减轻服务器负载。</li></ul></li><li><p><strong>分布式处理</strong></p><ul><li>将数据和计算任务分布到多个机器上，提升并行处理能力。</li><li>使用分布式命名服务器（如DNS）和分布式信息系统（如WWW）实现资源的全局管理。</li></ul></li><li><p><strong>数据复制</strong></p><ul><li>在多个机器上创建数据副本，提升数据的可用性和访问速度。</li><li>应用场景包括：分布式文件服务器、数据库复制、网站镜像和Web缓存等。</li></ul></li></ol><h3 id="5-分布式系统类型"><a href="#5-分布式系统类型" class="headerlink" title="5. 分布式系统类型"></a>5. 分布式系统类型</h3><h4 id="5-1-集群计算系统"><a href="#5-1-集群计算系统" class="headerlink" title="5.1 集群计算系统"></a>5.1 集群计算系统</h4><ul><li><p><strong>特点</strong>：</p><ul><li>通过局域网（LAN）连接的高性能计算节点。</li><li>同构：相同的操作系统和近似的硬件配置。</li><li>由单一管理节点控制，管理集中。</li></ul></li><li><p><strong>应用案例</strong>：</p><ul><li>高性能计算（HPC）集群，用于科学计算和模拟。</li></ul></li></ul><h4 id="5-2-网格计算系统"><a href="#5-2-网格计算系统" class="headerlink" title="5.2 网格计算系统"></a>5.2 网格计算系统</h4><ul><li><p><strong>特点</strong>：</p><ul><li>节点地理分布广泛，可能跨越不同组织和网络。</li><li>异构：不同节点可能运行不同的操作系统和硬件。</li><li>易扩展至广域网（WAN）环境，适用于大规模分布式计算。</li></ul></li><li><p><strong>应用案例</strong>：</p><ul><li>科学研究中的分布式模拟和数据分析。</li></ul></li></ul><h4 id="5-3-云计算"><a href="#5-3-云计算" class="headerlink" title="5.3 云计算"></a>5.3 云计算</h4><ul><li><p><strong>架构层次</strong>：</p><ol><li><strong>硬件层</strong>：包括处理器、存储设备、网络设备等基础资源。</li><li><strong>基础设施层</strong>：部署虚拟化技术，实现资源的虚拟化与管理。</li><li><strong>平台层</strong>：提供操作系统、数据库等高层次服务。</li><li><strong>应用程序层</strong>：用户实际使用的各类应用软件。</li></ol></li><li><p><strong>主要服务</strong>：</p><ul><li>IaaS（基础设施即服务）、PaaS（平台即服务）、SaaS（软件即服务）。</li></ul></li></ul><h4 id="5-4-普适计算系统"><a href="#5-4-普适计算系统" class="headerlink" title="5.4 普适计算系统"></a>5.4 普适计算系统</h4><ul><li><p><strong>特点</strong>：</p><ul><li>设备通过网络灵活连接，实现高水平的用户与设备交互。</li><li>系统具备上下文感知能力，能够根据用户的环境和需求动态调整。</li><li>设备具有自主性和智能化，支持动态行为和复杂交互。</li></ul></li><li><p><strong>应用案例</strong>：</p><ul><li>智能家居系统、物联网（IoT）应用。</li></ul></li></ul><h4 id="5-5-移动计算系统"><a href="#5-5-移动计算系统" class="headerlink" title="5.5 移动计算系统"></a>5.5 移动计算系统</h4><ul><li><p><strong>特点</strong>：</p><ul><li>大量异构移动设备，位置随时间变化。</li><li>设备间通信存在不确定性和延迟，需应对频繁的网络变化。</li></ul></li><li><p><strong>应用案例</strong>：</p><ul><li>移动应用、车联网（V2X）系统。</li></ul></li></ul><h4 id="5-6-传感网络"><a href="#5-6-传感网络" class="headerlink" title="5.6 传感网络"></a>5.6 传感网络</h4><ul><li><p><strong>特点</strong>：</p><ul><li>节点数量众多（数十至数千）。</li><li>节点计算能力和存储有限，多数由电池供电。</li><li>需要高效的通信和节能机制。</li></ul></li><li><p><strong>应用案例</strong>：</p><ul><li>环境监测、智能农业、智能城市。</li></ul></li></ul><h3 id="6-分布式系统面临的挑战"><a href="#6-分布式系统面临的挑战" class="headerlink" title="6. 分布式系统面临的挑战"></a>6. 分布式系统面临的挑战</h3><ol><li><p><strong>系统设计</strong></p><ul><li>设计正确的接口和抽象层次。</li><li>功能划分与可扩展性设计。</li></ul></li><li><p><strong>一致性</strong></p><ul><li>共享数据的一致性保证。</li><li>处理读写冲突与写写冲突。</li></ul></li><li><p><strong>容错</strong></p><ul><li>确保系统在节点失效情况下的正常运行。</li><li>设计有效的故障检测与恢复机制。</li></ul></li><li><p><strong>部署场景差异</strong></p><ul><li>集群环境、广域网环境、传感网络等不同部署场景带来的设计与实现差异。</li></ul></li><li><p><strong>实现问题</strong></p><ul><li>最大化并行性，消除性能瓶颈。</li><li>负载均衡与资源优化。</li></ul></li></ol><h3 id="7-分布式系统架构"><a href="#7-分布式系统架构" class="headerlink" title="7. 分布式系统架构"></a>7. 分布式系统架构</h3><h4 id="7-1-案例分类"><a href="#7-1-案例分类" class="headerlink" title="7.1 案例分类"></a>7.1 案例分类</h4><ol><li><p><strong>分布式文件系统</strong></p><ul><li>例子：HDFS、NFS、Ceph。</li></ul></li><li><p><strong>分布式数据库</strong></p><ul><li>例子：MongoDB、Cassandra、Elasticsearch。</li></ul></li><li><p><strong>分布式处理框架</strong></p><ul><li>例子：Hadoop、MPI、Spark、Storm。</li></ul></li><li><p><strong>分布式调度器</strong></p><ul><li>例子：YARN、Mesos、Slurm。</li></ul></li><li><p><strong>分布式操作系统</strong></p><ul><li>例子：Kubernetes、OpenStack。</li></ul></li></ol><h4 id="7-2-软件体系结构"><a href="#7-2-软件体系结构" class="headerlink" title="7.2 软件体系结构"></a>7.2 软件体系结构</h4><h5 id="7-2-1-基本概念"><a href="#7-2-1-基本概念" class="headerlink" title="7.2.1 基本概念"></a>7.2.1 基本概念</h5><ul><li><strong>可替换性</strong>：组件具有定义良好的接口，便于替换与扩展。</li><li><strong>互联方式</strong>：组件之间通过何种方式连接与通信。</li><li><strong>数据交换</strong>：组件之间交换的数据格式与协议。</li><li><strong>协同配置</strong>：组件与连接器的配置方式，确保系统协同工作。</li></ul><h5 id="7-2-2-软件体系结构风格"><a href="#7-2-2-软件体系结构风格" class="headerlink" title="7.2.2 软件体系结构风格"></a>7.2.2 软件体系结构风格</h5><ol><li><p><strong>分层体系结构</strong></p><ul><li>分层设计，常用于客户端-服务器模型，如典型的三层架构（表示层、业务逻辑层、数据层）。</li></ul></li><li><p><strong>面向对象的体系结构</strong></p><ul><li>基于对象的设计，适用于分布式对象系统，如CORBA。</li></ul></li><li><p><strong>基于事件的体系结构</strong></p><ul><li>采用发布&#x2F;订阅模式，事件驱动，适用于高并发、高解耦系统。</li></ul></li><li><p><strong>共享数据空间体系结构</strong></p><ul><li>通过共享内存或数据空间，实现进程间的解耦与协作。</li></ul></li></ol><h4 id="7-3-系统体系结构"><a href="#7-3-系统体系结构" class="headerlink" title="7.3 系统体系结构"></a>7.3 系统体系结构</h4><h5 id="7-3-1-类型划分"><a href="#7-3-1-类型划分" class="headerlink" title="7.3.1 类型划分"></a>7.3.1 类型划分</h5><ol><li><p><strong>集中式体系结构（Master-Slave）</strong></p><ul><li>单一控制中心管理整个系统，协调各节点的工作。</li></ul></li><li><p><strong>非集中式体系结构（P2P）</strong></p><ul><li>无中心控制，各节点自主运行，适用于去中心化应用。</li></ul></li><li><p><strong>混合体系结构</strong></p><ul><li>结合集中式与非集中式特点，例如点对点文件共享系统，部分节点充当协调者。</li></ul></li></ol><h5 id="7-3-2-客户端-服务器模型"><a href="#7-3-2-客户端-服务器模型" class="headerlink" title="7.3.2 客户端-服务器模型"></a>7.3.2 客户端-服务器模型</h5><p><strong>特点</strong>：</p><ol><li><p><strong>服务器进程</strong></p><ul><li>提供特定服务的核心进程。</li></ul></li><li><p><strong>客户端进程</strong></p><ul><li>发送请求并等待服务器响应，获取所需服务。</li></ul></li><li><p><strong>通信协议</strong></p><ul><li>常用协议包括HTTP&#x2F;HTTPS（REST API）、AJAX（异步请求）、RPC（如XMLRPC、SOAP、gRPC）。</li></ul></li></ol><h5 id="7-3-3-应用分层"><a href="#7-3-3-应用分层" class="headerlink" title="7.3.3 应用分层"></a>7.3.3 应用分层</h5><p><strong>传统三层架构</strong>：</p><ol><li><p><strong>用户接口层</strong></p><ul><li>系统与用户直接交互的部分，如GUI、管理界面。</li></ul></li><li><p><strong>应用逻辑层</strong></p><ul><li>包含业务逻辑与主要功能，不直接依赖具体数据存储。</li></ul></li><li><p><strong>数据访问层</strong></p><ul><li>管理系统使用的实际数据，如数据库、文件系统。</li></ul></li></ol><h3 id="8-分布式系统通信"><a href="#8-分布式系统通信" class="headerlink" title="8. 分布式系统通信"></a>8. 分布式系统通信</h3><h4 id="8-1-基础网络模型"><a href="#8-1-基础网络模型" class="headerlink" title="8.1 基础网络模型"></a>8.1 基础网络模型</h4><h5 id="8-1-1-网络层次结构"><a href="#8-1-1-网络层次结构" class="headerlink" title="8.1.1 网络层次结构"></a>8.1.1 网络层次结构</h5><ol><li><p><strong>物理层</strong></p><ul><li>负责数据的实际传输，处理物理媒介上的发送和接收。</li></ul></li><li><p><strong>数据链路层</strong></p><ul><li>将数据组织成帧，提供错误检测与流量控制。</li></ul></li><li><p><strong>网络层</strong></p><ul><li>负责数据包在网络中的路由与转发。</li></ul></li><li><p><strong>传输层</strong></p><ul><li>提供端到端的通信服务，主要协议包括TCP（可靠）、UDP（不可靠）、QUIC（基于UDP的高效协议）。</li></ul></li><li><p><strong>中间件层</strong></p><ul><li>提供通用的通信服务和协议支持，如数据封装、命名协议、安全协议等。</li></ul></li></ol><h4 id="8-2-通信类型"><a href="#8-2-通信类型" class="headerlink" title="8.2 通信类型"></a>8.2 通信类型</h4><h5 id="8-2-1-基本分类"><a href="#8-2-1-基本分类" class="headerlink" title="8.2.1 基本分类"></a>8.2.1 基本分类</h5><ol><li><p><strong>瞬时通信 vs 持久通信</strong></p><ul><li>瞬时通信：消息无法传递时直接丢弃。</li><li>持久通信：消息存储在服务器，直到成功传递。</li></ul></li><li><p><strong>同步通信 vs 异步通信</strong></p><ul><li>同步通信：发送方在等待响应期间被阻塞。</li><li>异步通信：发送方无需等待响应，可以继续执行其他任务。</li></ul></li></ol><h5 id="8-2-2-客户端-服务器通信特点"><a href="#8-2-2-客户端-服务器通信特点" class="headerlink" title="8.2.2 客户端-服务器通信特点"></a>8.2.2 客户端-服务器通信特点</h5><p><strong>同步通信缺点</strong>：</p><ul><li>双方必须同时在线。</li><li>客户端请求后被阻塞，影响响应时间。</li><li>必须立即处理故障，增加系统复杂度。</li><li>不适用于需要长时间等待或高并发的应用场景。</li></ul><h4 id="8-3-远程过程调用（RPC）"><a href="#8-3-远程过程调用（RPC）" class="headerlink" title="8.3 远程过程调用（RPC）"></a>8.3 远程过程调用（RPC）</h4><h5 id="8-3-1-基本原理"><a href="#8-3-1-基本原理" class="headerlink" title="8.3.1 基本原理"></a>8.3.1 基本原理</h5><ul><li>隐藏了调用者与被调用者之间的网络通信细节。</li><li>通过过程调用的方式实现分布式通信，使开发者能够像调用本地函数一样调用远程服务。</li></ul><h5 id="8-3-2-参数传递注意事项"><a href="#8-3-2-参数传递注意事项" class="headerlink" title="8.3.2 参数传递注意事项"></a>8.3.2 参数传递注意事项</h5><ol><li><p><strong>数据表示差异</strong></p><ul><li>客户端与服务器可能使用不同的数据表示方式，需要统一编码机制。</li></ul></li><li><p><strong>编码机制</strong></p><ul><li>基本数据类型需统一表示，如整数、字符串。</li><li>复杂数据类型需规范化，如结构体、对象的序列化与反序列化。</li></ul></li></ol><h5 id="8-3-3-RPC类型"><a href="#8-3-3-RPC类型" class="headerlink" title="8.3.3 RPC类型"></a>8.3.3 RPC类型</h5><ol><li><p><strong>同步RPC</strong></p><ul><li>客户端发送请求后阻塞，直到接收到服务器响应。</li></ul></li><li><p><strong>异步RPC</strong></p><ul><li>客户端发送请求后立即返回，后续通过回调或事件处理响应。</li></ul></li><li><p><strong>多RPC调用</strong></p><ul><li>客户端同时向多个服务器发送请求，提高并发与效率。</li></ul></li></ol><h5 id="8-3-4-现代RPC实现：gRPC-Protobuf"><a href="#8-3-4-现代RPC实现：gRPC-Protobuf" class="headerlink" title="8.3.4 现代RPC实现：gRPC &amp; Protobuf"></a>8.3.4 现代RPC实现：gRPC &amp; Protobuf</h5><p><strong>特点</strong>：</p><ol><li>语言无关、平台无关，支持多种编程语言。</li><li>高效，使用二进制序列化协议（Protobuf），体积小、传输快。</li><li>支持流式通信，适合实时数据传输。</li><li>严格的接口约束，确保服务的一致性与兼容性。</li></ol><h4 id="8-4-面向消息的通信"><a href="#8-4-面向消息的通信" class="headerlink" title="8.4 面向消息的通信"></a>8.4 面向消息的通信</h4><h5 id="8-4-1-Berkeley套接字"><a href="#8-4-1-Berkeley套接字" class="headerlink" title="8.4.1 Berkeley套接字"></a>8.4.1 Berkeley套接字</h5><p><strong>主要操作原语</strong>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">socket()   <span class="comment">// 创建通信端点</span></span><br><span class="line">bind()     <span class="comment">// 绑定本地地址</span></span><br><span class="line">listen()   <span class="comment">// 监听连接</span></span><br><span class="line">accept()   <span class="comment">// 接受连接请求</span></span><br><span class="line">connect()  <span class="comment">// 建立连接</span></span><br><span class="line">send()     <span class="comment">// 发送数据</span></span><br><span class="line">recv()     <span class="comment">// 接收数据</span></span><br><span class="line">close()    <span class="comment">// 关闭连接</span></span><br></pre></td></tr></table></figure><h5 id="8-4-2-ZeroMQ高级消息模式"><a href="#8-4-2-ZeroMQ高级消息模式" class="headerlink" title="8.4.2 ZeroMQ高级消息模式"></a>8.4.2 ZeroMQ高级消息模式</h5><ol><li><p><strong>请求-回复模式</strong></p><ul><li>客户端发送请求，服务器回复响应。</li></ul></li><li><p><strong>发布-订阅模式</strong></p><ul><li>发布者广播消息，订阅者接收感兴趣的消息。</li></ul></li><li><p><strong>管道模式</strong></p><ul><li>多生产者与多消费者通过队列交互，实现任务分发与处理。</li></ul></li></ol><h5 id="8-4-3-消息队列系统"><a href="#8-4-3-消息队列系统" class="headerlink" title="8.4.3 消息队列系统"></a>8.4.3 消息队列系统</h5><p><strong>特点</strong>：</p><ol><li>支持异步、持久化消息传递。</li><li>通过队列管理器管理消息的存储与转发。</li><li>提供灵活的消息路由功能，支持多种消息交换模式。</li></ol><h4 id="8-5-Kafka消息系统"><a href="#8-5-Kafka消息系统" class="headerlink" title="8.5 Kafka消息系统"></a>8.5 Kafka消息系统</h4><p><strong>主要组件</strong>：</p><ol><li><strong>Producer</strong> - 消息的生产者，负责发送消息到Kafka集群。</li><li><strong>Consumer</strong> - 消息的消费者，从Kafka集群中读取消息。</li><li><strong>Broker</strong> - Kafka集群中的服务器节点，负责消息的存储与转发。</li><li><strong>Topic</strong> - 消息的主题，Producer发送消息到特定主题，Consumer订阅主题获取消息。</li><li><strong>Partition</strong> - 主题的分区，Kafka通过分区实现消息的并行处理与负载均衡。</li></ol><h4 id="8-6-多播通信"><a href="#8-6-多播通信" class="headerlink" title="8.6 多播通信"></a>8.6 多播通信</h4><h5 id="8-6-1-应用层多播"><a href="#8-6-1-应用层多播" class="headerlink" title="8.6.1 应用层多播"></a>8.6.1 应用层多播</h5><p><strong>组织方式</strong>：</p><ol><li><p><strong>树状结构</strong></p><ul><li>节点间形成唯一路径，结构简单但可靠性较低。</li></ul></li><li><p><strong>网络结构</strong></p><ul><li>节点有多个邻居，结构复杂但具备更高的健壮性。</li></ul></li></ol><h5 id="8-6-2-Gossip协议（流行病协议）"><a href="#8-6-2-Gossip协议（流行病协议）" class="headerlink" title="8.6.2 Gossip协议（流行病协议）"></a>8.6.2 Gossip协议（流行病协议）</h5><p><strong>传播模型</strong>：</p><ol><li><p><strong>反熵（Anti-entropy）模型</strong></p><ul><li>基于数据同步，确保最终一致性。</li></ul></li><li><p><strong>流言传播模型</strong></p><ul><li>随机选择节点进行信息交换，具备良好的扩展性，适用于大规模系统。</li></ul></li></ol><h3 id="9-分布式系统命名系统"><a href="#9-分布式系统命名系统" class="headerlink" title="9. 分布式系统命名系统"></a>9. 分布式系统命名系统</h3><h4 id="9-1-基本概念"><a href="#9-1-基本概念" class="headerlink" title="9.1 基本概念"></a>9.1 基本概念</h4><h5 id="9-1-1-名称"><a href="#9-1-1-名称" class="headerlink" title="9.1.1 名称"></a>9.1.1 名称</h5><ul><li>由字符组成的字符串，用于唯一标识分布式系统中的实体对象。</li><li>标识的实体包括硬件资源（如主机、打印机、磁盘、文件）和抽象资源（如用户、邮箱、消息）。</li></ul><h5 id="9-1-2-访问点（Access-Point）"><a href="#9-1-2-访问点（Access-Point）" class="headerlink" title="9.1.2 访问点（Access Point）"></a>9.1.2 访问点（Access Point）</h5><ul><li>进行实体操作的接口点，访问点的名称称为地址。</li><li>一个实体可以拥有多个访问点，以支持不同的操作接口。</li></ul><h5 id="9-1-3-标识符（Identifiers）"><a href="#9-1-3-标识符（Identifiers）" class="headerlink" title="9.1.3 标识符（Identifiers）"></a>9.1.3 标识符（Identifiers）</h5><p><strong>特性</strong>：</p><ol><li>每个标识符唯一引用一个实体。</li><li>每个实体最多由一个标识符引用。</li><li>标识符一旦分配，永不重用，确保引用的一致性。</li></ol><h4 id="9-2-无层次结构命名"><a href="#9-2-无层次结构命名" class="headerlink" title="9.2 无层次结构命名"></a>9.2 无层次结构命名</h4><h5 id="9-2-1-基于广播-多播的命名解析"><a href="#9-2-1-基于广播-多播的命名解析" class="headerlink" title="9.2.1 基于广播&#x2F;多播的命名解析"></a>9.2.1 基于广播&#x2F;多播的命名解析</h5><ol><li><p><strong>广播方式</strong></p><ul><li>客户端发送广播请求，实体响应当前地址。</li><li><strong>局限性</strong>：难以跨越局域网，需所有进程监听请求，带来带宽浪费。</li></ul></li><li><p><strong>多播方式</strong></p><ul><li>客户端发送多播请求，实体响应。</li><li><strong>优势</strong>：适用于大规模网络，减少不必要的广播流量。</li></ul></li></ol><h5 id="9-2-2-基于转发指针的命名解析"><a href="#9-2-2-基于转发指针的命名解析" class="headerlink" title="9.2.2 基于转发指针的命名解析"></a>9.2.2 基于转发指针的命名解析</h5><p><strong>原理</strong>：</p><ul><li>当实体移动时，在当前位置留下指向新位置的指针，客户端通过指针链查找实体所在位置。</li></ul><p><strong>问题</strong>：</p><ul><li>长指针链可能断开，增加定位开销。</li><li>地理可扩展性差，适用于小规模系统。</li></ul><h5 id="9-2-3-分布式散列表（DHT）"><a href="#9-2-3-分布式散列表（DHT）" class="headerlink" title="9.2.3 分布式散列表（DHT）"></a>9.2.3 分布式散列表（DHT）</h5><p>以Chord为例：</p><p><strong>结构特点</strong>：</p><ol><li>节点组织成环形结构，每个节点有唯一的m位标识符。</li><li>实体通过唯一的m位健值（Key）进行标识，存储在满足<code>ID &gt;= Key</code>的最小标识符节点上。</li><li>每个节点维护m个指针，指向当前节点后的<code>2^(i-1)</code>位置节点，支持对数级别的查找效率。</li></ol><h4 id="9-3-结构化命名"><a href="#9-3-结构化命名" class="headerlink" title="9.3 结构化命名"></a>9.3 结构化命名</h4><h5 id="9-3-1-命名空间"><a href="#9-3-1-命名空间" class="headerlink" title="9.3.1 命名空间"></a>9.3.1 命名空间</h5><ul><li>基于命名图（Naming Graph）组织命名空间。</li><li><strong>叶节点</strong>：表示具体实体，存储实体属性与状态。</li><li><strong>目录节点</strong>：包含指向其他节点的链接，组织命名层级结构。</li></ul><h5 id="9-3-2-名称解析机制"><a href="#9-3-2-名称解析机制" class="headerlink" title="9.3.2 名称解析机制"></a>9.3.2 名称解析机制</h5><ol><li><p><strong>闭包机制</strong></p><ul><li>通过分层命名解析，如<code>www.domain.com</code>由DNS服务器解析，<code>/home/user/file</code>由本地文件服务器解析。</li></ul></li><li><p><strong>链接类型</strong></p><ul><li><strong>硬链接</strong>：直接通过路径名查找。</li><li><strong>软链接</strong>：通过存储绝对路径名实现引用。</li></ul></li></ol><h5 id="9-3-3-命名空间实现的三层结构"><a href="#9-3-3-命名空间实现的三层结构" class="headerlink" title="9.3.3 命名空间实现的三层结构"></a>9.3.3 命名空间实现的三层结构</h5><ol><li><p><strong>全局层</strong></p><ul><li>包含根节点及近根节点，结构稳定，通常代表整个组织或多个组织群体。</li></ul></li><li><p><strong>行政层</strong></p><ul><li>单个组织内部管理的目录节点，变化相对频繁，代表组织内的实体组。</li></ul></li><li><p><strong>管理层</strong></p><ul><li>代表本地主机、文件系统等，节点状态频繁变更，由终端用户维护。</li></ul></li></ol><h4 id="9-4-名称解析方式"><a href="#9-4-名称解析方式" class="headerlink" title="9.4 名称解析方式"></a>9.4 名称解析方式</h4><h5 id="9-4-1-迭代式解析"><a href="#9-4-1-迭代式解析" class="headerlink" title="9.4.1 迭代式解析"></a>9.4.1 迭代式解析</h5><ul><li>客户端依次查询每个解析服务器，每个服务器返回下一步查询的服务器信息，直至获得最终结果。</li></ul><h5 id="9-4-2-递归式解析"><a href="#9-4-2-递归式解析" class="headerlink" title="9.4.2 递归式解析"></a>9.4.2 递归式解析</h5><ul><li>客户端一次性请求，服务器递归查询其他服务器，最终返回结果给客户端。</li></ul><h4 id="9-5-基于属性的命名"><a href="#9-5-基于属性的命名" class="headerlink" title="9.5 基于属性的命名"></a>9.5 基于属性的命名</h4><h5 id="9-5-1-LDAP（轻量级目录访问协议）"><a href="#9-5-1-LDAP（轻量级目录访问协议）" class="headerlink" title="9.5.1 LDAP（轻量级目录访问协议）"></a>9.5.1 LDAP（轻量级目录访问协议）</h5><p><strong>特点</strong>：</p><ul><li>结合数据库实现目录服务，每个目录项包含（属性, 值）对。</li><li>赋予唯一名字，便于基于属性的查询与搜索。</li></ul><h5 id="9-5-2-扩展性考虑"><a href="#9-5-2-扩展性考虑" class="headerlink" title="9.5.2 扩展性考虑"></a>9.5.2 扩展性考虑</h5><ol><li><p><strong>规模扩展性</strong></p><ul><li>服务器需处理大量并发请求，需具备高吞吐量与低延迟。</li></ul></li><li><p><strong>地理扩展性</strong></p><ul><li>通过数据复制提高可用性，采用“就近服务”原则减少延迟。</li></ul></li></ol><h3 id="10-分布式系统协同"><a href="#10-分布式系统协同" class="headerlink" title="10. 分布式系统协同"></a>10. 分布式系统协同</h3><h4 id="10-1-基础概念"><a href="#10-1-基础概念" class="headerlink" title="10.1 基础概念"></a>10.1 基础概念</h4><h5 id="10-1-1-同步与协作"><a href="#10-1-1-同步与协作" class="headerlink" title="10.1.1 同步与协作"></a>10.1.1 同步与协作</h5><ol><li><p><strong>同步类型</strong></p><ul><li><strong>事件同步</strong>：事件在时间上达成一致。</li><li><strong>进程同步</strong>：一个进程等待其他进程完成特定操作。</li><li><strong>数据同步</strong>：保证多个节点的数据集合保持一致。</li></ul></li><li><p><strong>协作定义</strong></p><ul><li>管理系统中各行为之间的交互与依赖关系，分布式系统的协作复杂度高于单节点系统。</li></ul></li></ol><h4 id="10-2-时钟同步"><a href="#10-2-时钟同步" class="headerlink" title="10.2 时钟同步"></a>10.2 时钟同步</h4><h5 id="10-2-1-物理时钟"><a href="#10-2-1-物理时钟" class="headerlink" title="10.2.1 物理时钟"></a>10.2.1 物理时钟</h5><ol><li><p><strong>统一协调时间（UTC）</strong></p><ul><li>基于原子钟的精确时间标准，通过网络时间协议（NTP）同步。</li></ul></li><li><p><strong>时钟精度与准确度</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">精度定义：|Ci(t) - Cj(t)| ≤ ε</span><br><span class="line">准确度定义：|Ci(t) - t| ≤ α</span><br></pre></td></tr></table></figure><ul><li><strong>Ci(t)</strong> 表示机器i在UTC时间t的时钟时间。</li><li><strong>ε</strong> 为精度参数，<strong>α</strong> 为准确度参数。</li></ul></li></ol><h5 id="10-2-2-时钟漂移"><a href="#10-2-2-时钟漂移" class="headerlink" title="10.2.2 时钟漂移"></a>10.2.2 时钟漂移</h5><ol><li><p><strong>时钟规约</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1 - ρ) ≤ F(t)/F ≤ (1 + ρ)</span><br></pre></td></tr></table></figure><ul><li><strong>ρ</strong> 为最大时钟漂移率。</li><li><strong>F(t)</strong> 为t时刻硬件时钟频率，<strong>F</strong> 为理想频率。</li></ul></li><li><p><strong>时钟同步方法</strong></p><p>a) <strong>Berkeley算法</strong></p><ul><li>时间服务器定期收集所有节点时间，计算均值后通知各节点调整时钟。</li></ul><p>b) <strong>参考广播同步化（RBS）</strong></p><ul><li>适用于无线网络，节点定期广播参考时间，接收节点通过线性回归调整本地时钟。</li></ul></li></ol><h4 id="10-3-逻辑时钟"><a href="#10-3-逻辑时钟" class="headerlink" title="10.3 逻辑时钟"></a>10.3 逻辑时钟</h4><h5 id="10-3-1-发生关系（Happen-before）"><a href="#10-3-1-发生关系（Happen-before）" class="headerlink" title="10.3.1 发生关系（Happen-before）"></a>10.3.1 发生关系（Happen-before）</h5><p><strong>定义三条规则</strong>：</p><ol><li>同一进程中，事件a在事件b之前发生，则a → b。</li><li>事件a是消息的发送，事件b是消息的接收，则a → b。</li><li>如果a → b 且 b → c，则a → c。</li></ol><h5 id="10-3-2-Lamport逻辑时钟"><a href="#10-3-2-Lamport逻辑时钟" class="headerlink" title="10.3.2 Lamport逻辑时钟"></a>10.3.2 Lamport逻辑时钟</h5><ol><li><p><strong>时间戳规则</strong></p><ul><li><strong>P1</strong>：同进程事件a → b，则C(a) &lt; C(b)。</li><li><strong>P2</strong>：消息发送事件a和接收事件b，则C(a) &lt; C(b)。</li></ul></li><li><p><strong>实现机制</strong></p><ol><li>每个进程Pi维护本地计数器Ci。</li><li>进程内部事件发生时，Ci &#x3D; Ci + 1。</li><li>发送消息m时，Ci &#x3D; Ci + 1，将时间戳ts &#x3D; Ci附加到消息。</li><li>接收消息m(ts)时，Ci &#x3D; max(Ci, ts) + 1。</li></ol></li></ol><h5 id="10-3-3-向量时钟"><a href="#10-3-3-向量时钟" class="headerlink" title="10.3.3 向量时钟"></a>10.3.3 向量时钟</h5><ol><li><p><strong>数据结构</strong></p><ul><li>每个进程Pi维护一个向量VCi[1…N]。</li><li><strong>VCi[j]</strong> 表示Pi已知的第j个进程的事件数。</li></ul></li><li><p><strong>更新规则</strong></p><ul><li>进程Pi本地事件：VCi[i] &#x3D; VCi[i] + 1。</li><li>Pi发送消息：先执行本地事件更新，再发送消息。</li><li>Pi接收消息m(ts)：<ul><li>对所有j，VCi[j] &#x3D; max(VCi[j], ts[j])。</li><li>VCi[i] &#x3D; VCi[i] + 1。</li></ul></li></ul></li></ol><h4 id="10-4-分布式互斥"><a href="#10-4-分布式互斥" class="headerlink" title="10.4 分布式互斥"></a>10.4 分布式互斥</h4><h5 id="10-4-1-基于许可的方法"><a href="#10-4-1-基于许可的方法" class="headerlink" title="10.4.1 基于许可的方法"></a>10.4.1 基于许可的方法</h5><ol><li><p><strong>集中式方法</strong></p><ul><li>单一协调者控制资源访问，存在单点故障风险。</li></ul></li><li><p><strong>分布式方法（Ricart &amp; Agrawala算法）</strong></p><p>请求访问资源时：</p><ol><li>构造消息（资源名，进程号，逻辑时间）。</li><li>发送给所有其他进程。</li><li>等待所有进程回复OK。</li></ol><p>接收请求时：</p><ol><li>未访问资源：直接返回OK。</li><li>已获得访问权：将请求加入队列。</li><li>想访问但未获得：比较时间戳<ul><li>接收到的消息时间戳早：返回OK。</li><li>自己时间戳早：将请求加入队列。</li></ul></li></ol></li></ol><h5 id="10-4-2-基于令牌的方法"><a href="#10-4-2-基于令牌的方法" class="headerlink" title="10.4.2 基于令牌的方法"></a>10.4.2 基于令牌的方法</h5><p><strong>令牌环算法</strong></p><ul><li>进程组织成逻辑环，令牌在环内传递。</li><li>持有令牌的进程可进入临界区，完成后将令牌传递给下一个进程。</li></ul><h4 id="10-5-选举算法"><a href="#10-5-选举算法" class="headerlink" title="10.5 选举算法"></a>10.5 选举算法</h4><h5 id="10-5-1-Bully算法"><a href="#10-5-1-Bully算法" class="headerlink" title="10.5.1 Bully算法"></a>10.5.1 Bully算法</h5><p><strong>运行机制</strong>：</p><ol><li><p>Pi发起选举：</p><ul><li>向所有ID更大的进程发送ELECTION消息。</li><li>如无人响应，Pi成为新Leader。</li><li>有响应则等待更高ID进程的选举结果。</li></ul></li><li><p>Pj收到ELECTION消息：</p><ul><li>发送OK给Pi。</li><li>向更高ID进程发起新一轮选举。</li></ul></li><li><p>胜出者发送COORDINATOR消息，宣布自己为Leader。</p></li></ol><h5 id="10-5-2-Ring算法"><a href="#10-5-2-Ring算法" class="headerlink" title="10.5.2 Ring算法"></a>10.5.2 Ring算法</h5><p><strong>运行机制</strong>：</p><ol><li>进程按环形结构组织。</li><li>选举发起者将自己的ID加入消息列表。</li><li>消息沿环传递，各进程添加自己的ID。</li><li>消息返回发起者时，选出最大ID作为Leader。</li><li>新Leader通过环形广播通知所有进程。</li></ol><h3 id="11-分布式系统一致性与复制"><a href="#11-分布式系统一致性与复制" class="headerlink" title="11. 分布式系统一致性与复制"></a>11. 分布式系统一致性与复制</h3><h4 id="11-1-基础概念"><a href="#11-1-基础概念" class="headerlink" title="11.1 基础概念"></a>11.1 基础概念</h4><h5 id="11-1-1-复制的原因"><a href="#11-1-1-复制的原因" class="headerlink" title="11.1.1 复制的原因"></a>11.1.1 复制的原因</h5><ol><li><p><strong>性能提升</strong></p><ul><li>通过在多个节点上存储数据副本，提升数据读取速度与系统吞吐量。</li></ul></li><li><p><strong>提高可用性</strong></p><ul><li>数据副本的存在保证了部分节点故障时系统依然可用。</li></ul></li></ol><h5 id="11-1-2-主要挑战"><a href="#11-1-2-主要挑战" class="headerlink" title="11.1.2 主要挑战"></a>11.1.2 主要挑战</h5><ol><li><p><strong>一致性保证</strong></p><ul><li>确保所有副本上的数据在任何时间点保持一致，防止数据冲突与不一致。</li></ul></li><li><p><strong>冲突类型</strong></p><ul><li><strong>读写冲突</strong>：一个进程读取数据，另一个进程同时写入数据。</li><li><strong>写写冲突</strong>：多个进程对同一数据进行并发写操作。</li></ul></li></ol><h4 id="11-2-数据中心一致性模型"><a href="#11-2-数据中心一致性模型" class="headerlink" title="11.2 数据中心一致性模型"></a>11.2 数据中心一致性模型</h4><h5 id="11-2-1-连续一致性模型"><a href="#11-2-1-连续一致性模型" class="headerlink" title="11.2.1 连续一致性模型"></a>11.2.1 连续一致性模型</h5><p><strong>偏差类型</strong>：</p><ol><li><p><strong>数值偏差</strong></p><ul><li>不同副本间的数值存在差异。</li></ul></li><li><p><strong>新旧偏差</strong></p><ul><li>不同副本的数据新旧程度不同。</li></ul></li><li><p><strong>顺序偏差</strong></p><ul><li>不同副本上操作的顺序和数量不一致。</li></ul></li></ol><h5 id="11-2-2-Consistency-Unit（Conit）"><a href="#11-2-2-Consistency-Unit（Conit）" class="headerlink" title="11.2.2 Consistency Unit（Conit）"></a>11.2.2 Consistency Unit（Conit）</h5><p><strong>结构组成</strong>：</p><ol><li>包含多个数据项（如x, y）。</li><li>每个副本维护向量时钟，记录数据状态。</li><li>操作持久化，不允许回滚，确保操作记录的不可更改性。</li></ol><p><strong>偏差度量</strong>：</p><ul><li>数值偏差 &#x3D; 未接收更新次数 × 偏差权重。</li><li>偏差权重 &#x3D; 已提交值与未收到操作结果间差值的最大值。</li></ul><h5 id="11-2-3-顺序一致性"><a href="#11-2-3-顺序一致性" class="headerlink" title="11.2.3 顺序一致性"></a>11.2.3 顺序一致性</h5><p><strong>定义</strong>：所有进程看到的操作执行顺序一致，每个进程自身的操作按程序顺序执行。</p><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">时间轴示意：</span><br><span class="line">P1: W(x)1        R(x)1</span><br><span class="line">P2:     W(x)2    R(x)2   [顺序一致]</span><br></pre></td></tr></table></figure><h5 id="11-2-4-因果一致性"><a href="#11-2-4-因果一致性" class="headerlink" title="11.2.4 因果一致性"></a>11.2.4 因果一致性</h5><p><strong>定义</strong>：具有因果关系的操作必须以相同顺序被所有进程看到，保持操作之间的因果依赖。</p><p><strong>特点</strong>：</p><ul><li>较弱于顺序一致性，允许并发操作以不同顺序被各进程观察。</li><li>保持因果相关操作的顺序一致性。</li></ul><h4 id="11-3-客户端中心一致性模型"><a href="#11-3-客户端中心一致性模型" class="headerlink" title="11.3 客户端中心一致性模型"></a>11.3 客户端中心一致性模型</h4><h5 id="11-3-1-单调读一致性"><a href="#11-3-1-单调读一致性" class="headerlink" title="11.3.1 单调读一致性"></a>11.3.1 单调读一致性</h5><p><strong>定义</strong>：如果一个进程读取了数据项x的值，后续的读取操作不会读到更旧的值。</p><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正确示例：</span><br><span class="line">P1: W(x)1    R(x)1    R(x)1</span><br><span class="line">P2:     W(x)2         R(x)2</span><br><span class="line">   </span><br><span class="line">错误示例：</span><br><span class="line">P1: W(x)1    R(x)2    R(x)1  [违反单调读]</span><br><span class="line">P2:     W(x)2</span><br></pre></td></tr></table></figure><h5 id="11-3-2-单调写一致性"><a href="#11-3-2-单调写一致性" class="headerlink" title="11.3.2 单调写一致性"></a>11.3.2 单调写一致性</h5><p><strong>定义</strong>：一个进程的写操作必须按顺序完成，即后续的写操作不能先于先前的写操作执行。</p><h5 id="11-3-3-读写一致性"><a href="#11-3-3-读写一致性" class="headerlink" title="11.3.3 读写一致性"></a>11.3.3 读写一致性</h5><p><strong>定义</strong>：进程的写操作结果必须对该进程的后续读操作可见，确保读到最新写入的数据。</p><h4 id="11-4-复制管理"><a href="#11-4-复制管理" class="headerlink" title="11.4 复制管理"></a>11.4 复制管理</h4><h5 id="11-4-1-副本放置策略"><a href="#11-4-1-副本放置策略" class="headerlink" title="11.4.1 副本放置策略"></a>11.4.1 副本放置策略</h5><ol><li><p><strong>服务器放置</strong></p><ul><li>从N个位置中选择K个最佳位置，考虑客户端距离最小化。</li><li>常用方法：几何空间划分，如哈希分区、地理分布等。</li></ul></li><li><p><strong>内容放置</strong></p><ul><li>使用多层次的放置策略，如三个同心环：<ul><li><strong>永久副本</strong>（最内环）：关键数据的稳定副本。</li><li><strong>服务器启动副本</strong>（中环）：由服务器自动管理的副本。</li><li><strong>客户端启动副本</strong>（外环）：由客户端主动管理和维护的副本。</li></ul></li></ul></li></ol><h5 id="11-4-2-内容分发策略"><a href="#11-4-2-内容分发策略" class="headerlink" title="11.4.2 内容分发策略"></a>11.4.2 内容分发策略</h5><ol><li><p><strong>传播方式</strong></p><ul><li><strong>更新通知传播</strong>：服务器主动通知客户端更新信息。</li><li><strong>数据传播</strong>：被动复制，通过请求拉取更新数据。</li><li><strong>操作传播</strong>：主动复制，传递操作日志以同步更新。</li></ul></li><li><p><strong>更新方式</strong></p><p>Push方式：</p><ul><li>服务器主动推送更新到客户端。</li><li>适用于频繁更新的数据。</li></ul><p>Pull方式：</p><ul><li>客户端按需主动请求更新。</li><li>适用于低频更新或按需访问的数据。</li></ul></li></ol><h4 id="11-5-一致性协议"><a href="#11-5-一致性协议" class="headerlink" title="11.5 一致性协议"></a>11.5 一致性协议</h4><h5 id="11-5-1-基于主备份的协议"><a href="#11-5-1-基于主备份的协议" class="headerlink" title="11.5.1 基于主备份的协议"></a>11.5.1 基于主备份的协议</h5><ol><li><p><strong>远程写协议</strong></p><p>步骤：</p><ol><li>客户端发送更新请求到主副本。</li><li>主副本转发更新请求到所有备份副本。</li><li>备份副本确认接收更新。</li><li>主副本向客户端返回成功响应。</li></ol></li><li><p><strong>本地写协议</strong></p><p>适用场景：</p><ul><li>离线计算环境、移动计算环境。</li><li>进行数据传输前的本地缓存与更新。</li></ul></li></ol><h5 id="11-5-2-客户端中心一致性协议"><a href="#11-5-2-客户端中心一致性协议" class="headerlink" title="11.5.2 客户端中心一致性协议"></a>11.5.2 客户端中心一致性协议</h5><p><strong>实现机制</strong>：</p><p>每个客户端维护：</p><ol><li>读操作集：与客户端读操作相关的写操作记录。</li><li>写操作集：客户端自身的写操作记录。</li></ol><p>一致性检查：</p><ul><li>单调读&#x2F;写：在处理请求时，依据操作集保持一致性。</li><li>读写一致：读操作前检查写操作集，确保读到最新数据。</li><li>写读一致：写操作前检查读操作集，确保写入前的读操作已完成。</li></ul><h3 id="12-分布式系统容错"><a href="#12-分布式系统容错" class="headerlink" title="12. 分布式系统容错"></a>12. 分布式系统容错</h3><h4 id="12-1-基本概念与术语"><a href="#12-1-基本概念与术语" class="headerlink" title="12.1 基本概念与术语"></a>12.1 基本概念与术语</h4><h5 id="12-1-1-可依赖性相关概念"><a href="#12-1-1-可依赖性相关概念" class="headerlink" title="12.1.1 可依赖性相关概念"></a>12.1.1 可依赖性相关概念</h5><ol><li><p><strong>可靠性（Reliability）</strong></p><p>R(t) &#x3D; P(组件从t&#x3D;0到t时刻正常工作的概率)</p><p>重要指标：</p><ul><li>MTTF（平均失效时间）：组件从工作开始到第一次失效的平均时间。</li><li>MTTR（平均恢复时间）：组件失效后恢复正常工作的平均时间。</li><li>MTBF（平均故障间隔时间）&#x3D; MTTF + MTTR。</li></ul></li><li><p><strong>可用性（Availability）</strong></p><p>A(t) &#x3D; 在[0,t]时间内组件可用时间的比例。<br>长期可用性：A &#x3D; MTTF &#x2F; (MTTF + MTTR)。</p></li></ol><h5 id="12-1-2-故障分类"><a href="#12-1-2-故障分类" class="headerlink" title="12.1.2 故障分类"></a>12.1.2 故障分类</h5><ol><li><p><strong>按持续性分类</strong></p><ul><li><strong>暂时性故障</strong>：仅发生一次，可以通过重试恢复。</li><li><strong>间歇性故障</strong>：周期性发生，需要监控与预测。</li><li><strong>持久性故障</strong>：持续存在，需人工干预或更换组件。</li></ul></li><li><p><strong>按性质分类</strong></p><ul><li><strong>遗漏性失效</strong>：未执行应执行的操作，导致资源状态不可用。</li><li><strong>执行性失效</strong>：执行了不应执行的操作，可能导致资源状态不一致。</li></ul></li></ol><h4 id="12-2-进程恢复机制"><a href="#12-2-进程恢复机制" class="headerlink" title="12.2 进程恢复机制"></a>12.2 进程恢复机制</h4><h5 id="12-2-1-冗余策略"><a href="#12-2-1-冗余策略" class="headerlink" title="12.2.1 冗余策略"></a>12.2.1 冗余策略</h5><ol><li><p><strong>信息冗余</strong></p><ul><li>通过附加校验位或冗余信息，检测与纠错数据传输中的错误。</li></ul></li><li><p><strong>时间冗余</strong></p><ul><li>通过重执行操作或事务处理，确保操作的可靠性。</li></ul></li><li><p><strong>物理冗余</strong></p><ul><li>增加额外的设备或进程，提升系统的容错能力。</li></ul></li></ol><h5 id="12-2-2-K-容错组"><a href="#12-2-2-K-容错组" class="headerlink" title="12.2.2 K-容错组"></a>12.2.2 K-容错组</h5><p>容错度定义：</p><ul><li>停止失效：需要K+1个成员。</li><li>随意失效：需要2K+1个成员。</li></ul><p><strong>假设条件</strong>：</p><ol><li>所有成员同质，具备相同能力。</li><li>所有成员以相同顺序处理命令，确保操作一致性。</li></ol><h4 id="12-3-共识协议"><a href="#12-3-共识协议" class="headerlink" title="12.3 共识协议"></a>12.3 共识协议</h4><h5 id="12-3-1-基于泛洪的共识"><a href="#12-3-1-基于泛洪的共识" class="headerlink" title="12.3.1 基于泛洪的共识"></a>12.3.1 基于泛洪的共识</h5><p><strong>系统模型</strong>：</p><p>组件：</p><ul><li>进程组 P &#x3D; {P1, P2, …, Pn}</li><li>失效模型：Fail-stop（停止失效）</li></ul><p><strong>过程</strong>：</p><ol><li>客户端联系Pi执行命令。</li><li>每个进程维护命令列表，基于轮数进行共识。</li></ol><h5 id="12-3-2-Paxos协议假设"><a href="#12-3-2-Paxos协议假设" class="headerlink" title="12.3.2 Paxos协议假设"></a>12.3.2 Paxos协议假设</h5><ol><li><strong>系统模型</strong>：<ul><li>半同步系统，消息可能延迟但最终会到达。</li><li>通信不可靠，消息可能丢失、重复或乱序。</li><li>能够检测并丢弃损坏的消息。</li><li>操作具有确定性，保证相同输入产生相同输出。</li><li>节点可能出现崩溃失效，但不会发生网络分区。</li><li>节点不会串通欺骗，保持诚实。</li></ul></li></ol><h3 id="13-分布式系统容错"><a href="#13-分布式系统容错" class="headerlink" title="13. 分布式系统容错"></a>13. 分布式系统容错</h3><h4 id="13-1-可靠通信"><a href="#13-1-可靠通信" class="headerlink" title="13.1 可靠通信"></a>13.1 可靠通信</h4><h5 id="13-1-1-可靠RPC机制"><a href="#13-1-1-可靠RPC机制" class="headerlink" title="13.1.1 可靠RPC机制"></a>13.1.1 可靠RPC机制</h5><p><strong>错误类型及解决方案</strong>：</p><ol><li><p><strong>无法定位服务器</strong></p><ul><li>客户端返回错误信息，提示服务器不可达。</li></ul></li><li><p><strong>请求丢失</strong></p><ul><li>客户端重新发送请求，确保最终传递。</li></ul></li><li><p><strong>服务器崩溃</strong></p><ul><li>使用幂等操作，避免重复执行带来的副作用。</li><li>采用事务处理机制，确保操作的原子性。</li></ul></li><li><p><strong>客户端崩溃</strong></p><ul><li>使用孤儿操作消灭、任务再生和超时机制，确保系统状态一致。</li></ul></li></ol><h5 id="13-1-2-可靠组通信"><a href="#13-1-2-可靠组通信" class="headerlink" title="13.1.2 可靠组通信"></a>13.1.2 可靠组通信</h5><p><strong>实现方式</strong>：</p><ol><li><p><strong>基本机制</strong></p><ul><li>确保组内每个进程都能接收到消息。</li><li>区分消息的发送与接收，防止消息丢失或重复。</li></ul></li><li><p><strong>反馈控制</strong></p><ul><li><strong>无等级反馈</strong>：使用多播反馈抑制机制，减少重复反馈。</li><li><strong>分等级反馈</strong>：采用树形结构组织反馈，提高反馈效率。</li></ul></li></ol><h4 id="13-2-分布式提交协议"><a href="#13-2-分布式提交协议" class="headerlink" title="13.2 分布式提交协议"></a>13.2 分布式提交协议</h4><h5 id="13-2-1-两阶段提交（2PC）"><a href="#13-2-1-两阶段提交（2PC）" class="headerlink" title="13.2.1 两阶段提交（2PC）"></a>13.2.1 两阶段提交（2PC）</h5><p>阶段1（投票阶段）：</p><ol><li>协调者发送VOTE_REQUEST给所有参与者。</li><li>参与者返回VOTE_COMMIT或VOTE_ABORT。</li></ol><p>阶段2（提交阶段）：</p><ol><li>协调者根据投票结果发送GLOBAL_COMMIT或GLOBAL_ABORT。</li><li>参与者执行相应操作并返回确认。</li></ol><p><strong>失效处理</strong>：</p><ul><li><strong>参与者失效</strong>：使用日志记录以便恢复。</li><li><strong>协调者失效</strong>：可能导致整个提交过程阻塞，需要恢复机制。</li></ul><h5 id="13-2-2-恢复机制"><a href="#13-2-2-恢复机制" class="headerlink" title="13.2.2 恢复机制"></a>13.2.2 恢复机制</h5><ol><li><p><strong>检查点机制</strong></p><p>特点：</p><ul><li>定期记录进程状态，便于恢复。</li><li>需要协调所有进程找到一致的恢复点。</li><li>可能导致多米诺效应，即多个进程必须同时回滚。</li></ul><p>类型：</p><ul><li>独立检查点：每个进程独立记录状态。</li><li>协调检查点：全局同步记录一致的状态。</li></ul></li><li><p><strong>日志消息机制</strong></p><p>优势：</p><ul><li>记录操作日志，支持通过重放达到一致状态。</li><li>实现成本低于全面检查点。</li></ul><p>实现方式：</p><ul><li>持久化重要消息日志。</li><li>保证消息的顺序一致性。</li></ul></li><li><p><strong>面向恢复的计算（RoC）</strong></p><p>特点：</p><ul><li>只重启系统的部分组件，减少恢复时间。</li><li>系统组件高度分离，组件间依赖关系简单。</li><li>支持增量恢复，提高恢复效率。</li></ul></li></ol><h3 id="14-分布式系统共识机制"><a href="#14-分布式系统共识机制" class="headerlink" title="14. 分布式系统共识机制"></a>14. 分布式系统共识机制</h3><h4 id="14-1-基础概念"><a href="#14-1-基础概念" class="headerlink" title="14.1 基础概念"></a>14.1 基础概念</h4><h5 id="14-1-1-背景"><a href="#14-1-1-背景" class="headerlink" title="14.1.1 背景"></a>14.1.1 背景</h5><ul><li><strong>分布式系统协作</strong>：多个组件协同工作，对外呈现为一个整体系统。</li><li><strong>一致性</strong>：确保系统中各个副本的数据对象保持一致。</li><li><strong>共识</strong>：在分布式系统中，多节点就某个操作或值达成一致的过程。</li></ul><h5 id="14-1-2-系统特性"><a href="#14-1-2-系统特性" class="headerlink" title="14.1.2 系统特性"></a>14.1.2 系统特性</h5><p>基于BASE理论：</p><ul><li><strong>Basically Available</strong>（基本可用）：系统保证部分功能持续可用。</li><li><strong>Soft-state</strong>（软状态）：系统状态可以通过交互动态变化。</li><li><strong>Eventual Consistency</strong>（最终一致性）：所有副本最终将达到一致状态。</li></ul><h4 id="14-2-Paxos算法"><a href="#14-2-Paxos算法" class="headerlink" title="14.2 Paxos算法"></a>14.2 Paxos算法</h4><h5 id="14-2-1-基本概念"><a href="#14-2-1-基本概念" class="headerlink" title="14.2.1 基本概念"></a>14.2.1 基本概念</h5><p>角色定义：</p><ol><li>Proposer（提议者）：提出共识值的节点。</li><li>Acceptor（接受者）：接收并投票的节点。</li><li>Learner（学习者）：学习最终共识值的节点。</li></ol><p><strong>消息类型</strong>：</p><ol><li>**Prepare(n)**：准备请求，提议编号n。</li><li>**Promise(n, v)**：承诺响应，承诺不接受编号小于n的提案，并返回已接受的最高编号提案值v。</li><li>**Accept(n, v)**：接受请求，提议编号n和提议值v。</li><li>**Accepted(n, v)**：接受响应，表示接受了提议编号n的值v。</li></ol><h5 id="14-2-2-算法流程"><a href="#14-2-2-算法流程" class="headerlink" title="14.2.2 算法流程"></a>14.2.2 算法流程</h5><p><strong>阶段1（Prepare）</strong>：</p><p>Proposer：</p><ol><li>选择一个提案编号n。</li><li>向所有Acceptor发送Prepare(n)消息。</li></ol><p>Acceptor：</p><ol><li>如果n大于已承诺的所有编号：<ul><li>承诺不再接受编号小于n的提案。</li><li>返回Promise(n, 已接受的最高编号提案值v)。</li></ul></li><li>否则，拒绝Prepare请求。</li></ol><p><strong>阶段2（Accept）</strong>：</p><p>Proposer：</p><ol><li>如果收到大多数Promise响应：<ul><li>选择最高编号已接受的值v（如无则自由选择）。</li><li>向所有Acceptor发送Accept(n, v)消息。</li></ul></li></ol><p>Acceptor：</p><ol><li>如果未对更大编号做出承诺：<ul><li>接受提案，并发送Accepted(n, v)响应。</li></ul></li><li>否则，拒绝Accept请求。</li></ol><h5 id="14-2-3-算法特性与示例"><a href="#14-2-3-算法特性与示例" class="headerlink" title="14.2.3 算法特性与示例"></a>14.2.3 算法特性与示例</h5><ol><li><strong>无冲突情况</strong>：</li></ol><ul><li>Proposer P1提出值v1。</li><li>多数Acceptor接受v1。</li><li>共识达成，值v1被选定。</li></ul><ol start="2"><li><strong>并发提案冲突</strong>：</li></ol><ul><li>Proposer P1和P2同时提出不同的值。</li><li>较大编号的提案获胜，确保只有一个值被选定。</li></ul><ol start="3"><li><strong>安全性保证</strong>：</li></ol><ul><li>已确定的值不会被修改。</li><li>较新的提案会继承已接受的值，保持一致性。</li></ul><h4 id="14-3-Raft算法"><a href="#14-3-Raft算法" class="headerlink" title="14.3 Raft算法"></a>14.3 Raft算法</h4><h5 id="14-3-1-核心概念"><a href="#14-3-1-核心概念" class="headerlink" title="14.3.1 核心概念"></a>14.3.1 核心概念</h5><p>角色定义：</p><ol><li>Leader（领导者）：负责处理所有客户端请求，并管理日志复制。</li><li>Follower（跟随者）：被动响应Leader的请求或选举。</li><li>Candidate（候选者）：在Leader失效时发起选举的节点。</li></ol><p>任期：</p><ul><li>时间被划分为任期，每个任期有唯一的递增编号。</li><li>每个任期至多有一个Leader。</li></ul><h5 id="14-3-2-选举过程"><a href="#14-3-2-选举过程" class="headerlink" title="14.3.2 选举过程"></a>14.3.2 选举过程</h5><ol><li>Follower在超时未收到Leader心跳后，转换为Candidate。</li><li>Candidate增加当前任期编号，向其他节点发送选票请求。</li><li>如果Candidate获得多数选票，成为新的Leader。</li><li>Leader定期发送心跳消息，维持领导地位。</li><li>如果其他Candidate在选举过程中发现更高任期的Leader，转换为Follower。</li></ol><h5 id="14-3-3-日志复制"><a href="#14-3-3-日志复制" class="headerlink" title="14.3.3 日志复制"></a>14.3.3 日志复制</h5><ul><li>Leader接收客户端请求，追加到自己的日志。</li><li>Leader将日志条目复制到所有Follower。</li><li>当日志条目被大多数节点确认后，Leader提交该条目。</li><li>Leader通过心跳消息通知Follower提交日志条目。</li></ul><h5 id="14-3-4-一致性保证"><a href="#14-3-4-一致性保证" class="headerlink" title="14.3.4 一致性保证"></a>14.3.4 一致性保证</h5><ul><li>所有Leader的财产集必须一致。</li><li>日志条目顺序一致，保证数据一致性。</li><li>即使在Leader失效后，新Leader也能正确恢复日志状态。</li></ul><h4 id="14-4-PBFT（实用拜占庭容错）"><a href="#14-4-PBFT（实用拜占庭容错）" class="headerlink" title="14.4 PBFT（实用拜占庭容错）"></a>14.4 PBFT（实用拜占庭容错）</h4><h5 id="14-4-1-系统模型"><a href="#14-4-1-系统模型" class="headerlink" title="14.4.1 系统模型"></a>14.4.1 系统模型</h5><p>假设条件：</p><ul><li>系统由n个节点组成，其中最多f个节点可能是恶意的（拜占庭故障）。</li><li>系统运行在异步网络环境，消息可能延迟、丢失。</li><li>需要n ≥ 3f + 1以确保容错性。</li></ul><h5 id="14-4-2-协议流程"><a href="#14-4-2-协议流程" class="headerlink" title="14.4.2 协议流程"></a>14.4.2 协议流程</h5><ol><li><p><strong>请求阶段</strong>：</p><ul><li>客户端发送请求消息到主节点。</li></ul></li><li><p><strong>预准备阶段</strong>：</p><ul><li>主节点为请求分配序号，并广播预准备消息给所有节点。</li></ul></li><li><p><strong>准备阶段</strong>：</p><ul><li>节点验证预准备消息，确认消息的合法性。</li><li>节点广播准备消息给所有参与节点。</li></ul></li><li><p><strong>提交阶段</strong>：</p><ul><li>节点在收到2f+1个准备消息后，广播提交消息。</li></ul></li><li><p><strong>执行阶段</strong>：</p><ul><li>节点在收到2f+1个提交消息后，执行请求并向客户端发送响应。</li></ul></li></ol><h5 id="14-4-3-视图变更"><a href="#14-4-3-视图变更" class="headerlink" title="14.4.3 视图变更"></a>14.4.3 视图变更</h5><p>触发条件：</p><ul><li>主节点失效或通信故障。</li><li>网络分区导致Leader通信中断。</li><li>超时未收到心跳或响应。</li></ul><p>过程：</p><ol><li>副本节点广播视图变更请求。</li><li>在接收到至少2f+1个视图变更请求后，开始选举新的主节点。</li><li>选举出新主节点后，同步全局状态，恢复共识流程。</li></ol><p><strong>总结</strong>：</p><ul><li><strong>Paxos</strong>：理论完备，适用于高一致性要求场景，但实现复杂。</li><li><strong>Raft</strong>：易于理解与实现，适用于实际工程项目。</li><li><strong>PBFT</strong>：能够处理拜占庭故障，适用于对安全性要求高的分布式系统，但开销较大。</li></ul><p><strong>选择依据</strong>：系统需求（如一致性强度、容错类型）、性能要求与实现复杂度等。</p><h3 id="15-分布式文件系统"><a href="#15-分布式文件系统" class="headerlink" title="15. 分布式文件系统"></a>15. 分布式文件系统</h3><h4 id="15-1-问题背景与概述"><a href="#15-1-问题背景与概述" class="headerlink" title="15.1 问题背景与概述"></a>15.1 问题背景与概述</h4><ul><li><strong>问题</strong>：如何在分布式环境下高效、安全地存储和共享数据。</li><li><strong>背景</strong>：<ul><li>文件系统从本地（如FAT、NTFS、EXT）发展到集中式（如NFS、HDFS、Ceph），再到分布式文件系统（如GFS、DFS、Lustre）。</li><li><strong>分布式文件系统</strong>旨在实现数据的高可用性、可扩展性与高性能访问，是分布式系统的重要组成部分。</li></ul></li></ul><h4 id="15-2-分布式文件系统的重要属性"><a href="#15-2-分布式文件系统的重要属性" class="headerlink" title="15.2 分布式文件系统的重要属性"></a>15.2 分布式文件系统的重要属性</h4><ul><li><strong>网络互连</strong>：通过网络实现文件的共享与访问。</li><li><strong>分布式</strong>：文件存储与客户端分布在不同的物理节点上。</li><li><strong>透明性</strong>：用户无需感知文件的实际存储位置，使用方式与本地文件系统类似。</li><li><strong>性能要求</strong>：高效的数据访问速度，满足服务质量（QoS）的要求。</li><li><strong>并发支持</strong>：支持多用户对同一文件的并发访问与修改。</li></ul><h4 id="15-3-分布式文件系统的体系结构"><a href="#15-3-分布式文件系统的体系结构" class="headerlink" title="15.3 分布式文件系统的体系结构"></a>15.3 分布式文件系统的体系结构</h4><h5 id="15-3-1-客户端-服务器体系结构"><a href="#15-3-1-客户端-服务器体系结构" class="headerlink" title="15.3.1 客户端-服务器体系结构"></a>15.3.1 客户端-服务器体系结构</h5><ul><li><p><strong>特点</strong>：</p><ul><li>典型代表：NFS（Network File System）。</li><li>采用客户端-服务器模型，服务器提供统一的文件视图。</li></ul></li><li><p><strong>NFS架构</strong>：</p><ul><li>服务器使用虚拟文件系统（VFS）层，隐藏本地与远程文件系统的差异。</li><li>支持类似UNIX的文件操作，包括硬链接和符号链接。</li><li>提供高效的远程文件访问，适用于网络环境下的文件共享。</li></ul></li></ul><h5 id="15-3-2-基于集群的分布式文件系统"><a href="#15-3-2-基于集群的分布式文件系统" class="headerlink" title="15.3.2 基于集群的分布式文件系统"></a>15.3.2 基于集群的分布式文件系统</h5><ul><li><p><strong>适用场景</strong>：大规模数据集的存储与访问，如大数据分析、科学计算。</p></li><li><p><strong>关键技术</strong>：</p><ul><li><strong>文件分片</strong>：将大文件分割为多个小块，分布存储在不同节点上，实现并行访问。</li><li><strong>大块存储</strong>：将文件划分为较大的数据块（如64MB），分布到多个存储节点，提高存储与读取效率。</li></ul></li><li><p><strong>案例</strong>：</p><ul><li>Hadoop Distributed File System（HDFS）、Google File System（GFS）。</li></ul></li></ul><h5 id="15-3-3-Google文件系统（GFS）特点"><a href="#15-3-3-Google文件系统（GFS）特点" class="headerlink" title="15.3.3 Google文件系统（GFS）特点"></a>15.3.3 Google文件系统（GFS）特点</h5><ul><li><p><strong>主服务器功能</strong>：</p><ul><li>维护文件名至块服务器的映射表，保持在内存中以提高访问速度。</li><li>记录数据更新日志，定期生成检查点以防日志过大。</li></ul></li><li><p><strong>数据复制</strong>：</p><ul><li>采用主备模式复制文件块，确保数据的高可用性与容错性。</li><li>主服务器通过协调块服务器避免数据循环复制。</li></ul></li><li><p><strong>扩展性</strong>：</p><ul><li>主服务器设计避免成为性能瓶颈，能够管理数百个块服务器。</li></ul></li></ul><h5 id="15-3-4-对称式体系结构"><a href="#15-3-4-对称式体系结构" class="headerlink" title="15.3.4 对称式体系结构"></a>15.3.4 对称式体系结构</h5><ul><li><p><strong>特点</strong>：</p><ul><li>基于点对点（P2P）技术的完全对称体系结构。</li><li>所有节点地位平等，资源分布均匀，无单点控制。</li></ul></li><li><p><strong>优势</strong>：</p><ul><li>高容错性与可靠性，适合大规模分布式环境。</li></ul></li><li><p><strong>应用案例</strong>：</p><ul><li>Lustre文件系统，广泛应用于高性能计算集群。</li></ul></li></ul><h4 id="15-4-文件系统中的进程"><a href="#15-4-文件系统中的进程" class="headerlink" title="15.4 文件系统中的进程"></a>15.4 文件系统中的进程</h4><h5 id="15-4-1-NFS的有状态与无状态模式"><a href="#15-4-1-NFS的有状态与无状态模式" class="headerlink" title="15.4.1 NFS的有状态与无状态模式"></a>15.4.1 NFS的有状态与无状态模式</h5><ol><li><p><strong>无状态NFS</strong>：</p><ul><li><strong>优点</strong>：<ul><li>服务器实现简单，易于扩展。</li><li>即使服务器崩溃，客户端无需恢复状态。</li></ul></li><li><strong>缺点</strong>：<ul><li>无法实现文件锁定，容易导致并发访问冲突。</li></ul></li></ul></li><li><p><strong>有状态NFS</strong>：</p><ul><li><strong>优点</strong>：<ul><li>支持文件锁定，确保并发访问的一致性。</li></ul></li><li><strong>缺点</strong>：<ul><li>服务器需要维护客户端的状态信息，增加实现复杂度。</li><li>服务器崩溃后需恢复状态，影响系统可用性。</li></ul></li></ul></li></ol><h5 id="15-4-2-分布式文件系统中的RPC"><a href="#15-4-2-分布式文件系统中的RPC" class="headerlink" title="15.4.2 分布式文件系统中的RPC"></a>15.4.2 分布式文件系统中的RPC</h5><ul><li><p><strong>选择RPC的原因</strong>：</p><ul><li>隐藏底层通信细节，使系统独立于具体操作系统和网络协议。</li></ul></li><li><p><strong>问题与解决方案</strong>：</p><ul><li><strong>性能瓶颈</strong>：跨网络的RPC调用性能较低，通过并行RPC和本地缓存机制提升效率。</li></ul></li></ul><h4 id="15-5-NFS的命名与挂载"><a href="#15-5-NFS的命名与挂载" class="headerlink" title="15.5 NFS的命名与挂载"></a>15.5 NFS的命名与挂载</h4><h5 id="15-5-1-命名原则"><a href="#15-5-1-命名原则" class="headerlink" title="15.5.1 命名原则"></a>15.5.1 命名原则</h5><ul><li><strong>实现方式</strong>：通过在本地文件系统中挂载远程文件系统，实现用户对远程文件的透明访问。</li><li><strong>目标</strong>：用户无需关心文件的实际存储位置，像操作本地文件一样操作远程文件。</li></ul><h5 id="15-5-2-自动挂载"><a href="#15-5-2-自动挂载" class="headerlink" title="15.5.2 自动挂载"></a>15.5.2 自动挂载</h5><ul><li><strong>按需挂载</strong>：仅在用户访问时才挂载远程文件系统，节省资源。</li><li><strong>潜在问题</strong>：自动挂载策略需谨慎设计，避免因意外挂载带来的性能和安全问题。</li></ul><h5 id="15-5-3-全局名称空间"><a href="#15-5-3-全局名称空间" class="headerlink" title="15.5.3 全局名称空间"></a>15.5.3 全局名称空间</h5><ul><li><strong>功能</strong>：通过全局名称空间服务（GNS），将多个分布式文件系统整合为一个统一的名称空间。</li><li><strong>需求</strong>：对于大型分布式系统，提供全局统一的文件访问视图，简化用户操作与数据管理。</li></ul><h4 id="15-6-文件同步"><a href="#15-6-文件同步" class="headerlink" title="15.6 文件同步"></a>15.6 文件同步</h4><h5 id="15-6-1-文件共享语义"><a href="#15-6-1-文件共享语义" class="headerlink" title="15.6.1 文件共享语义"></a>15.6.1 文件共享语义</h5><ul><li><strong>挑战</strong>：处理分布式文件系统中多个用户对同一文件的并发读写操作，保证数据一致性与操作顺序。</li></ul><h5 id="15-6-2-同步方案"><a href="#15-6-2-同步方案" class="headerlink" title="15.6.2 同步方案"></a>15.6.2 同步方案</h5><ol><li><p><strong>立即传播改动</strong></p><ul><li><strong>优点</strong>：简单直接，确保所有副本实时一致。</li><li><strong>缺点</strong>：效率低下，增加网络带宽消耗。</li></ul></li><li><p><strong>会话语义</strong></p><ul><li><strong>特点</strong>：文件修改仅对修改进程可见，文件关闭后对其他进程可见，降低同步频率。</li><li><strong>适用场景</strong>：适用于需要中间状态不可见的应用，如文本编辑器。</li></ul></li><li><p><strong>只读文件</strong></p><ul><li><strong>特点</strong>：文件仅支持创建与读取，避免写操作带来的同步问题。</li><li><strong>适用场景</strong>：适用于日志文件、备份文件等仅需读操作的场景。</li></ul></li><li><p><strong>原子事务</strong></p><ul><li><strong>特点</strong>：通过事务机制，保证共享文件的操作具有原子性，即操作要么全部成功，要么全部失败。</li><li><strong>适用场景</strong>：需要确保操作一致性与完整性的应用，如数据库系统。</li></ul></li></ol><h5 id="15-6-3-文件锁定"><a href="#15-6-3-文件锁定" class="headerlink" title="15.6.3 文件锁定"></a>15.6.3 文件锁定</h5><ul><li><p><strong>背景</strong>：</p><ul><li>在无状态NFS中，需额外机制协调对共享文件的访问，防止并发写操作导致数据不一致。</li></ul></li><li><p><strong>实现方式</strong>：</p><ul><li>使用锁管理器，通过文件级或更细粒度的锁，实现对文件的同步访问控制。</li></ul></li></ul><h5 id="15-6-4-共享预约"><a href="#15-6-4-共享预约" class="headerlink" title="15.6.4 共享预约"></a>15.6.4 共享预约</h5><ul><li><strong>定义</strong>：客户端在打开文件时指定访问类型（如读、写），服务器根据预约情况决定是否允许访问，确保不同访问类型的安全性与一致性。</li></ul><h3 id="16-分布式系统一致性与复制"><a href="#16-分布式系统一致性与复制" class="headerlink" title="16. 分布式系统一致性与复制"></a>16. 分布式系统一致性与复制</h3><h4 id="16-1-一致性模型"><a href="#16-1-一致性模型" class="headerlink" title="16.1 一致性模型"></a>16.1 一致性模型</h4><h5 id="16-1-1-连续一致性与顺序一致性"><a href="#16-1-1-连续一致性与顺序一致性" class="headerlink" title="16.1.1 连续一致性与顺序一致性"></a>16.1.1 连续一致性与顺序一致性</h5><ul><li><p><strong>连续一致性</strong>：系统保证所有客户端看到的数据更新是按某一全局顺序执行的。</p></li><li><p><strong>顺序一致性</strong>：</p><ul><li><strong>定义</strong>：所有进程按照某个全局顺序执行操作，且每个进程的操作按程序顺序执行。</li><li><strong>特点</strong>：简化了理解与设计，但在高延迟网络环境下实现复杂。</li></ul></li></ul><h5 id="16-1-2-因果一致性"><a href="#16-1-2-因果一致性" class="headerlink" title="16.1.2 因果一致性"></a>16.1.2 因果一致性</h5><ul><li><p><strong>定义</strong>：满足因果关系的操作必须按相同的顺序被所有节点看到，非因果关系的操作可以任意顺序。</p></li><li><p><strong>特点</strong>：</p><ul><li>保证数据依赖关系的一致性。</li><li>允许并发操作，提高系统的吞吐量与性能。</li></ul></li></ul><h4 id="16-2-一致性协议"><a href="#16-2-一致性协议" class="headerlink" title="16.2 一致性协议"></a>16.2 一致性协议</h4><h5 id="16-2-1-Paxos协议"><a href="#16-2-1-Paxos协议" class="headerlink" title="16.2.1 Paxos协议"></a>16.2.1 Paxos协议</h5><ul><li><strong>特点</strong>：<ul><li>理论完备，能够在有部分节点失效情况下达成一致。</li><li>实现复杂，适用于高一致性要求的系统。</li></ul></li></ul><h5 id="16-2-2-Raft协议"><a href="#16-2-2-Raft协议" class="headerlink" title="16.2.2 Raft协议"></a>16.2.2 Raft协议</h5><ul><li><strong>特点</strong>：<ul><li>设计易于理解与实现，适用于实际工程项目。</li><li>通过角色划分与日志复制机制，确保日志的一致性与可靠性。</li></ul></li></ul><h5 id="16-2-3-PBFT（实用拜占庭容错）"><a href="#16-2-3-PBFT（实用拜占庭容错）" class="headerlink" title="16.2.3 PBFT（实用拜占庭容错）"></a>16.2.3 PBFT（实用拜占庭容错）</h5><ul><li><strong>特点</strong>：<ul><li>能够处理拜占庭故障，适用于安全性要求高的系统。</li><li>开销较大，适用于节点数量有限但安全性要求高的应用场景。</li></ul></li></ul><h3 id="17-分布式文件系统实例"><a href="#17-分布式文件系统实例" class="headerlink" title="17. 分布式文件系统实例"></a>17. 分布式文件系统实例</h3><h4 id="17-1-HDFS（Hadoop-Distributed-File-System）"><a href="#17-1-HDFS（Hadoop-Distributed-File-System）" class="headerlink" title="17.1 HDFS（Hadoop Distributed File System）"></a>17.1 HDFS（Hadoop Distributed File System）</h4><ul><li><p><strong>架构特点</strong>：</p><ul><li>主从架构，NameNode负责元数据管理，DataNode负责数据存储。</li><li>数据块（默认128MB）在多个DataNode上复制存储，保证数据高可用性。</li></ul></li><li><p><strong>优势</strong>：</p><ul><li>高容错性与可扩展性，适用于大规模数据存储与处理。</li><li>与Hadoop生态系统紧密集成，支持大数据分析与计算任务。</li></ul></li></ul><h4 id="17-2-Ceph文件系统"><a href="#17-2-Ceph文件系统" class="headerlink" title="17.2 Ceph文件系统"></a>17.2 Ceph文件系统</h4><ul><li><p><strong>架构特点</strong>：</p><ul><li>无中心化的设计，通过CRUSH算法实现数据分布与副本管理。</li><li>提供对象存储、块存储与文件系统存储多种接口。</li></ul></li><li><p><strong>优势</strong>：</p><ul><li>高度可扩展性，适应大规模分布式存储需求。</li><li>强一致性与高性能，支持复杂的存储应用场景。</li></ul></li></ul><h4 id="17-3-Lustre文件系统"><a href="#17-3-Lustre文件系统" class="headerlink" title="17.3 Lustre文件系统"></a>17.3 Lustre文件系统</h4><ul><li><p><strong>架构特点</strong>：</p><ul><li>高性能的并行文件系统，广泛应用于高性能计算（HPC）领域。</li><li>灵活的元数据服务器（MDS）与对象存储服务器（OSS）分离设计。</li></ul></li><li><p><strong>优势</strong>：</p><ul><li>具有极高的吞吐量与低延迟，适用于需要高带宽的应用，如科学模拟、渲染等。</li><li>支持大规模集群，具备良好的扩展性与容错能力。</li></ul></li></ul><h3 id="18-面向大数据与AI的分布式计算框架"><a href="#18-面向大数据与AI的分布式计算框架" class="headerlink" title="18. 面向大数据与AI的分布式计算框架"></a>18. 面向大数据与AI的分布式计算框架</h3><h4 id="18-1-分布式计算框架概述"><a href="#18-1-分布式计算框架概述" class="headerlink" title="18.1 分布式计算框架概述"></a>18.1 分布式计算框架概述</h4><ul><li><strong>目标</strong>：处理大规模数据集，支持分布式计算任务，提高计算效率与数据处理能力。</li><li><strong>关键技术</strong>：分布式存储、并行计算、任务调度、容错机制。</li></ul><h4 id="18-2-著名分布式计算框架"><a href="#18-2-著名分布式计算框架" class="headerlink" title="18.2 著名分布式计算框架"></a>18.2 著名分布式计算框架</h4><ol><li><p><strong>Hadoop</strong></p><ul><li><strong>组件</strong>：HDFS（分布式存储）、MapReduce（计算模型）、YARN（资源管理）。</li><li><strong>特点</strong>：适用于批处理大数据任务，具备高容错性与可扩展性。</li></ul></li><li><p><strong>Spark</strong></p><ul><li><strong>特点</strong>：内存计算框架，支持多种计算模式（批处理、流处理、机器学习、图计算）。</li><li><strong>优势</strong>：高性能、易用性，广泛应用于实时数据分析与机器学习任务。</li></ul></li><li><p><strong>MPI（Message Passing Interface）</strong></p><ul><li><strong>特点</strong>：面向高性能计算的并行编程模型，适用于需要低延迟、密集通信的应用。</li><li><strong>应用</strong>：科学计算、工程模拟、大规模并行应用。</li></ul></li><li><p><strong>Storm</strong></p><ul><li><strong>特点</strong>：实时流处理框架，适用于实时数据分析与事件处理。</li><li><strong>优势</strong>：低延迟、高吞吐，广泛应用于流数据处理系统。</li></ul></li></ol><h4 id="18-3-分布式机器学习平台"><a href="#18-3-分布式机器学习平台" class="headerlink" title="18.3 分布式机器学习平台"></a>18.3 分布式机器学习平台</h4><ol><li><p><strong>Parameter Server（参数服务器）</strong></p><ul><li><strong>功能</strong>：管理和存储机器学习模型的参数，实现高效的参数访问与更新。</li><li><strong>技术</strong>：采用一致性哈希进行参数分区，支持分布式并行训练。</li></ul></li><li><p><strong>分布式训练策略</strong></p><ul><li><strong>数据并行</strong>：将数据集划分为多个子集，分布到不同的训练节点并行处理。</li><li><strong>模型并行</strong>：将模型划分为不同部分，分布到多个节点进行并行计算。</li></ul></li><li><p><strong>容错机制</strong></p><ul><li><strong>任务重试</strong>：在节点失效时，重新分配任务以保证任务完成。</li><li><strong>参数恢复</strong>：通过日志或快照机制，恢复模型参数状态，确保模型一致性。</li></ul></li></ol><h4 id="18-4-深度学习在分布式环境中的应用"><a href="#18-4-深度学习在分布式环境中的应用" class="headerlink" title="18.4 深度学习在分布式环境中的应用"></a>18.4 深度学习在分布式环境中的应用</h4><h5 id="18-4-1-分布式深度学习的挑战"><a href="#18-4-1-分布式深度学习的挑战" class="headerlink" title="18.4.1 分布式深度学习的挑战"></a>18.4.1 分布式深度学习的挑战</h5><ol><li><p><strong>计算复杂度高</strong></p><ul><li>深度学习模型包含大量参数，训练过程需要高性能计算资源。</li><li>需要高效的计算资源管理与任务调度策略。</li></ul></li><li><p><strong>通信瓶颈</strong></p><ul><li>模型参数的同步与更新会占用大量网络带宽，影响训练速度。</li><li>需要优化通信协议与算法，减少带宽占用。</li></ul></li></ol><h5 id="18-4-2-分布式深度学习平台"><a href="#18-4-2-分布式深度学习平台" class="headerlink" title="18.4.2 分布式深度学习平台"></a>18.4.2 分布式深度学习平台</h5><ol><li><p><strong>FloydHub</strong>：<a href="https://www.floydhub.com/">https://www.floydhub.com/</a></p><ul><li>提供全托管的深度学习训练与部署服务，简化分布式训练流程。</li></ul></li><li><p><strong>OpenPAI</strong>：<a href="https://github.com/Microsoft/pai">https://github.com/Microsoft/pai</a></p><ul><li>微软开源的分布式人工智能平台，支持大规模分布式训练与模型管理。</li></ul></li><li><p><strong>PaddlePaddle</strong>：<a href="http://www.paddlepaddle.org/">http://www.paddlepaddle.org/</a></p><ul><li>百度开发的深度学习平台，支持高效的分布式训练与大规模模型部署。</li></ul></li><li><p><strong>Kubeflow</strong>：<a href="https://www.kubeflow.org/">https://www.kubeflow.org/</a></p><ul><li>基于Kubernetes的机器学习平台，支持分布式训练、模型部署与管理。</li></ul></li><li><p><strong>Polyaxon</strong>：<a href="https://polyaxon.com/">https://polyaxon.com/</a></p><ul><li>开源实验管理与分布式部署平台，支持机器学习模型的训练与调优。</li></ul></li></ol><h3 id="19-分布式文件系统案例分析"><a href="#19-分布式文件系统案例分析" class="headerlink" title="19. 分布式文件系统案例分析"></a>19. 分布式文件系统案例分析</h3><h4 id="19-1-HDFS（Hadoop-Distributed-File-System）"><a href="#19-1-HDFS（Hadoop-Distributed-File-System）" class="headerlink" title="19.1 HDFS（Hadoop Distributed File System）"></a>19.1 HDFS（Hadoop Distributed File System）</h4><ul><li><p><strong>架构特点</strong>：</p><ul><li><strong>NameNode</strong>：管理文件系统的元数据，如文件名与数据块的映射关系。</li><li><strong>DataNode</strong>：负责实际数据块的存储与管理。</li><li><strong>数据复制</strong>：默认情况下，每个数据块在多个DataNode上复制，确保数据高可用性与容错性。</li></ul></li><li><p><strong>优势</strong>：</p><ul><li>高容错性，通过数据冗余机制保障数据不丢失。</li><li>可扩展性强，支持数千个节点的集群。</li><li>与Hadoop生态系统紧密集成，支持大规模数据处理与分析任务。</li></ul></li></ul><h4 id="19-2-Ceph文件系统"><a href="#19-2-Ceph文件系统" class="headerlink" title="19.2 Ceph文件系统"></a>19.2 Ceph文件系统</h4><ul><li><p><strong>架构特点</strong>：</p><ul><li><strong>无中心化设计</strong>：通过CRUSH算法实现数据在集群中的均匀分布，无需中心协调者。</li><li><strong>多接口支持</strong>：支持对象存储、块存储与文件系统存储，适应多种应用场景。</li></ul></li><li><p><strong>优势</strong>：</p><ul><li>高度可扩展，支持大规模存储与高并发访问。</li><li>强一致性与高性能，满足复杂存储需求。</li><li>自愈能力强，能自动检测与修复数据故障。</li></ul></li></ul><h4 id="19-3-Lustre文件系统"><a href="#19-3-Lustre文件系统" class="headerlink" title="19.3 Lustre文件系统"></a>19.3 Lustre文件系统</h4><ul><li><p><strong>架构特点</strong>：</p><ul><li><strong>高性能并行文件系统</strong>，广泛应用于高性能计算（HPC）领域。</li><li><strong>元数据服务器（MDS）</strong>与<strong>对象存储服务器（OSS）</strong>分离，提升系统性能与扩展性。</li></ul></li><li><p><strong>优势</strong>：</p><ul><li>极高的吞吐量与低延迟，适用于需要高速数据访问的应用场景。</li><li>灵活的扩展性，能够支持数万个客户端并发访问。</li><li>高容错性，通过镜像与冗余机制保障数据安全。</li></ul></li></ul><h3 id="20-安全性在分布式系统中的应用"><a href="#20-安全性在分布式系统中的应用" class="headerlink" title="20. 安全性在分布式系统中的应用"></a>20. 安全性在分布式系统中的应用</h3><h4 id="20-1-NFS的安全性"><a href="#20-1-NFS的安全性" class="headerlink" title="20.1 NFS的安全性"></a>20.1 NFS的安全性</h4><ul><li><p><strong>主要关注点</strong>：</p><ul><li>客户端与服务器之间的通信安全，防止数据被未授权访问或篡改。</li></ul></li><li><p><strong>常用策略</strong>：</p><ul><li>使用基于Kerberos的认证机制，确保通信双方身份合法。</li><li>加密数据传输，防止数据在传输过程中被截获或篡改。</li></ul></li></ul><h4 id="20-2-安全的RPC"><a href="#20-2-安全的RPC" class="headerlink" title="20.2 安全的RPC"></a>20.2 安全的RPC</h4><ul><li><strong>身份认证方法</strong>：<ul><li><strong>密钥交换</strong>：通过公钥基础设施（PKI）交换密钥，建立安全通信会话。</li><li><strong>Kerberos协议</strong>：通过票据机制进行身份验证，防止未授权访问。</li></ul></li></ul><h4 id="20-3-安全的对等文件共享系统"><a href="#20-3-安全的对等文件共享系统" class="headerlink" title="20.3 安全的对等文件共享系统"></a>20.3 安全的对等文件共享系统</h4><ul><li><strong>基于DHT的安全查找</strong>：<ul><li><strong>防范Sybil攻击</strong>：限制每个实体的身份数量，确保网络中节点的真实性。</li><li><strong>防范Eclipse攻击</strong>：通过多路径路由与节点验证，防止攻击者控制路由表。</li><li><strong>安全传输</strong>：确保节点间的数据查找请求经过加密与认证，防止数据窃取与篡改。</li></ul></li></ul><h3 id="21-总结"><a href="#21-总结" class="headerlink" title="21. 总结"></a>21. 总结</h3><p>本课程全面涵盖了分布式系统的核心概念、架构设计、通信机制、一致性与复制、容错与可靠性保障以及分布式文件系统的实际应用。通过理论学习与案例分析，能够深入理解分布式系统的复杂性与设计挑战，掌握解决这些问题的关键技术与方法，为未来的研究与实际应用奠定坚实基础。</p><p><strong>学习建议</strong>：</p><ul><li><strong>实践操作</strong>：通过搭建分布式系统实验环境，亲自体验分布式系统的部署与管理。</li><li><strong>案例分析</strong>：深入分析HDFS、Ceph、Lustre等分布式文件系统的架构与实现，理解其设计理念与优势。</li><li><strong>前沿探索</strong>：关注分布式系统领域的最新研究与技术发展，如分布式一致性协议的改进、新型分布式存储方案等。</li></ul><p>通过系统学习与实践，将具备设计、实现与维护高性能、高可用性分布式系统的能力，满足现代计算与大数据时代的需求。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operation System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Computer Architecture</title>
      <link href="/2024/11/26/Computer_Architecture/"/>
      <url>/2024/11/26/Computer_Architecture/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="一、课程基本信息"><a href="#一、课程基本信息" class="headerlink" title="一、课程基本信息"></a>一、课程基本信息</h3><h4 id="1-课程定位与目标"><a href="#1-课程定位与目标" class="headerlink" title="1. 课程定位与目标"></a>1. 课程定位与目标</h4><ul><li>面向对象：高年级本科生或研究生，特别是计划从事计算机体系结构研究的学生</li><li>教学目标：<ul><li>了解计算机体系结构基础和当代主流计算机系统</li><li>掌握存储顺序性、Cache一致性、流水线和片上网络等内容</li><li>掌握高性能处理器设计与分析方法</li><li>了解异构计算和领域专用体系结构</li></ul></li></ul><h4 id="2-课程内容结构"><a href="#2-课程内容结构" class="headerlink" title="2. 课程内容结构"></a>2. 课程内容结构</h4><p>八大章节：</p><ol><li>绪论</li><li>基准评测集</li><li>高性能计算机体系结构</li><li>高性能处理器并行计算技术</li><li>高性能计算机存储层次</li><li>高性能计算机互连网络</li><li>异构计算体系结构</li><li>领域专用体系结构</li></ol><h3 id="二、量化设计与分析基础"><a href="#二、量化设计与分析基础" class="headerlink" title="二、量化设计与分析基础"></a>二、量化设计与分析基础</h3><h4 id="重点内容："><a href="#重点内容：" class="headerlink" title="重点内容："></a>重点内容：</h4><ol><li>计算机技术发展的关键转折点</li><li>丹纳德缩放定律(Dennard Scaling)及其终结</li><li>摩尔定律及其面临的挑战</li><li>单处理器性能发展历程</li></ol><h4 id="难点："><a href="#难点：" class="headerlink" title="难点："></a>难点：</h4><ol><li>理解处理器性能增长放缓的深层原因</li><li>掌握能耗墙、内存墙等技术瓶颈的本质</li></ol><h4 id="关键概念："><a href="#关键概念：" class="headerlink" title="关键概念："></a>关键概念：</h4><ol><li><p>摩尔定律：</p><ul><li>定义：晶体管数量每18-24个月翻倍，成本减半</li><li>现状：增长开始放缓</li><li>面临挑战：物理极限、成本效益、散热问题</li></ul></li><li><p>丹纳德缩放定律：</p><ul><li>核心内容：功率密度随面积保持不变</li><li>终结时间：2004年</li><li>影响：推动了多核处理器的发展</li></ul></li></ol><h3 id="三、高性能计算机发展史"><a href="#三、高性能计算机发展史" class="headerlink" title="三、高性能计算机发展史"></a>三、高性能计算机发展史</h3><h4 id="重点内容：-1"><a href="#重点内容：-1" class="headerlink" title="重点内容："></a>重点内容：</h4><ol><li>高性能计算机四个发展阶段</li><li>中国超级计算机发展历程</li><li>超级计算机应用领域</li></ol><h4 id="实例分析："><a href="#实例分析：" class="headerlink" title="实例分析："></a>实例分析：</h4><p>重要里程碑机器：</p><ol><li>CDC 6600 (1964)：第一台真正的超级计算机</li><li>Cray-1 (1976)：首次使用向量处理器架构</li><li>天河一号(2009)：中国首台千万亿次超级计算机</li><li>神威·太湖之光(2016)：首个使用国产芯片的世界最快超算</li></ol><h4 id="超级计算机应用领域："><a href="#超级计算机应用领域：" class="headerlink" title="超级计算机应用领域："></a>超级计算机应用领域：</h4><ol><li>科学计算：气候环境、天文物理、材料化工</li><li>工程应用：航空航天、石油勘探、工程设计</li><li>新兴领域：智慧城市、人工智能、精准医疗</li></ol><h4 id="重要图表位置标注："><a href="#重要图表位置标注：" class="headerlink" title="重要图表位置标注："></a>重要图表位置标注：</h4><ol><li>超级计算机性能发展曲线：P139</li><li>CPU性能发展趋势图：P140</li><li>超算应用领域分布图：P145</li></ol><h4 id="关键结论："><a href="#关键结论：" class="headerlink" title="关键结论："></a>关键结论：</h4><ol><li>“并行”是实现超级计算的唯一途径</li><li>未来发展趋势：<ul><li>E级向Z级计算发展</li><li>与AI、大数据融合</li><li>探索非冯·诺依曼架构</li></ul></li></ol><h2 id="基准评测集"><a href="#基准评测集" class="headerlink" title="基准评测集"></a>基准评测集</h2><h3 id="一、计算机性能基础"><a href="#一、计算机性能基础" class="headerlink" title="一、计算机性能基础"></a>一、计算机性能基础</h3><h4 id="1-性能指标"><a href="#1-性能指标" class="headerlink" title="1. 性能指标"></a>1. 性能指标</h4><h5 id="重点：CPU性能评估方法"><a href="#重点：CPU性能评估方法" class="headerlink" title="重点：CPU性能评估方法"></a>重点：CPU性能评估方法</h5><ul><li>CPU时间计算公式：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPU Time = Instructions × CPI × Clock Cycle Time</span><br></pre></td></tr></table></figure></li><li>主要影响因素：<ul><li>指令数(Instructions)</li><li>每指令周期数(CPI)</li><li>时钟周期时间(Clock Cycle Time)</li></ul></li></ul><h5 id="性能度量标准："><a href="#性能度量标准：" class="headerlink" title="性能度量标准："></a>性能度量标准：</h5><ol><li><p>MIPS (每秒百万指令数)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MIPS = Instructions Number/(Execution Time × 10^6)</span><br></pre></td></tr></table></figure></li><li><p>FLOPS (每秒浮点运算次数)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MFLOPS = Float Instructions Number/(Execution Time × 10^6)</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-并行系统性能评估"><a href="#2-并行系统性能评估" class="headerlink" title="2. 并行系统性能评估"></a>2. 并行系统性能评估</h4><h4 id="重点概念："><a href="#重点概念：" class="headerlink" title="重点概念："></a>重点概念：</h4><ol><li>加速比(Speedup)：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S = Ts/Tp</span><br></pre></td></tr></table></figure>其中：</li></ol><ul><li>Ts：串行执行时间</li><li>Tp：并行执行时间</li></ul><ol start="2"><li>效率(Efficiency)：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E = S/p</span><br></pre></td></tr></table></figure>其中p为处理器数量</li></ol><h5 id="难点：Amdahl定律"><a href="#难点：Amdahl定律" class="headerlink" title="难点：Amdahl定律"></a>难点：Amdahl定律</h5><ol><li>核心公式：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S = 1/(f + (1-f)/p)</span><br></pre></td></tr></table></figure>其中：</li></ol><ul><li>f：串行部分比例</li><li>p：处理器数量</li></ul><ol start="2"><li>关键结论：</li></ol><ul><li>加速比存在上限：1&#x2F;f</li><li>串行部分成为性能瓶颈</li></ul><h5 id="Gustafson定律"><a href="#Gustafson定律" class="headerlink" title="Gustafson定律"></a>Gustafson定律</h5><ol><li>公式：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S&#x27; = p - f(p-1)</span><br></pre></td></tr></table></figure></li><li>特点：</li></ol><ul><li>考虑问题规模随处理器数量增长</li><li>突破了Amdahl定律的限制</li></ul><h3 id="二、基准测试程序"><a href="#二、基准测试程序" class="headerlink" title="二、基准测试程序"></a>二、基准测试程序</h3><h4 id="主要类型："><a href="#主要类型：" class="headerlink" title="主要类型："></a>主要类型：</h4><ol><li>商用基准测试(TPC系列)：</li></ol><ul><li>TPC-C：在线事务处理</li><li>TPC-H：决策支持系统</li><li>TPC-E：证券交易系统</li></ul><ol start="2"><li>SPEC测试程序：</li></ol><ul><li>SPECint：整数运算</li><li>SPECfp：浮点运算</li><li>特点：标准化、可比性强</li></ul><ol start="3"><li>HPC特定测试：</li></ol><ul><li>Linpack：稠密矩阵运算</li><li>HPCG：稀疏矩阵求解</li><li>Graph500：图算法性能</li></ul><h4 id="实例分析：-1"><a href="#实例分析：-1" class="headerlink" title="实例分析："></a>实例分析：</h4><p>以龙芯3A5000处理器为例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SPEC CPU2006测试结果：</span><br><span class="line">- SPECint2006：27.87</span><br><span class="line">- SPECfp2006：30.29</span><br></pre></td></tr></table></figure><p>性能分析表明：</p><ul><li>定点性能接近同代x86处理器</li><li>浮点性能仍有提升空间</li></ul><h3 id="三、性能提升方法"><a href="#三、性能提升方法" class="headerlink" title="三、性能提升方法"></a>三、性能提升方法</h3><h4 id="主要策略："><a href="#主要策略：" class="headerlink" title="主要策略："></a>主要策略：</h4><ol><li>利用并行性</li><li>遵循局部性原理</li><li>关注常见情况优化</li></ol><h4 id="并行算法设计步骤："><a href="#并行算法设计步骤：" class="headerlink" title="并行算法设计步骤："></a>并行算法设计步骤：</h4><ol><li>任务划分</li><li>通信分析</li><li>任务组合</li><li>处理器映射</li></ol><h4 id="重要图表位置："><a href="#重要图表位置：" class="headerlink" title="重要图表位置："></a>重要图表位置：</h4><ul><li>CPU性能影响因素表：P12</li><li>处理器性能方程：P9-10</li><li>性能评测指标汇总：P16</li></ul><h2 id="高性能计算机的体系结构"><a href="#高性能计算机的体系结构" class="headerlink" title="高性能计算机的体系结构"></a>高性能计算机的体系结构</h2><h3 id="一、超级计算机硬件组成"><a href="#一、超级计算机硬件组成" class="headerlink" title="一、超级计算机硬件组成"></a>一、超级计算机硬件组成</h3><h4 id="1-五大核心子系统"><a href="#1-五大核心子系统" class="headerlink" title="1. 五大核心子系统"></a>1. 五大核心子系统</h4><ol><li>计算阵列：</li></ol><ul><li>处理器节点的集合</li><li>例子：天河一号(7168个节点)、天河二号(17920个节点)</li><li>每个节点通常包含CPU和加速器(如GPU、Intel Xeon Phi)</li></ul><ol start="2"><li>存储阵列：</li></ol><ul><li>采用层次式混合共享存储架构</li><li>特点：大容量、高带宽、低延迟</li><li>实例数据：<ul><li>天河一号：262TB内存，2PB磁盘</li><li>天河二号：1.408PB内存，12.4PB外存</li></ul></li></ul><ol start="3"><li>服务阵列：</li></ol><ul><li>基于商用服务器</li><li>属于大容量胖节点</li><li>物理组织：多个机架组成<ul><li>天河一号：140个机架</li><li>天河二号：125个机柜，500个机架</li></ul></li></ul><ol start="4"><li>互连通信子系统：</li></ol><ul><li>是大规模并行系统的核心</li><li>典型拓扑：胖树结构</li><li>支持硬件实现的集体操作(如多播、广播)</li></ul><ol start="5"><li>监控诊断子系统：</li></ol><ul><li>功能：实时监控、控制、诊断系统状态</li><li>监控对象：健康状态、功耗、温度等</li></ul><h3 id="二、计算机体系结构分类"><a href="#二、计算机体系结构分类" class="headerlink" title="二、计算机体系结构分类"></a>二、计算机体系结构分类</h3><h4 id="1-Flynn分类法"><a href="#1-Flynn分类法" class="headerlink" title="1. Flynn分类法"></a>1. Flynn分类法</h4><h5 id="重点概念：-1"><a href="#重点概念：-1" class="headerlink" title="重点概念："></a>重点概念：</h5><ol><li>指令流(I)：执行的指令序列</li><li>数据流(D)：被处理的数据序列</li><li>多倍性(M)：同时处理的指令&#x2F;数据数量</li></ol><h5 id="四种基本类型："><a href="#四种基本类型：" class="headerlink" title="四种基本类型："></a>四种基本类型：</h5><ol><li>SISD(单指令流单数据流)：</li></ol><ul><li>传统串行计算机</li><li>代表：早期PC机、8086处理器</li></ul><ol start="2"><li>SIMD(单指令流多数据流)：</li></ol><ul><li>特点：对多个数据并行执行相同操作</li><li>两个主要分支：<ul><li>阵列计算机(如ILLIAC IV)</li><li>向量计算机(如Cray-1)</li></ul></li></ul><ol start="3"><li>MISD(多指令流单数据流)：</li></ol><ul><li>存在争议</li><li>可能的例子：流水线结构</li></ul><ol start="4"><li>MIMD(多指令流多数据流)：</li></ol><ul><li>最广泛使用的并行架构</li><li>两种主要实现：<ul><li>共享内存系统</li><li>分布式内存系统</li></ul></li></ul><h5 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h5><h6 id="Cray-1向量计算机结构："><a href="#Cray-1向量计算机结构：" class="headerlink" title="Cray-1向量计算机结构："></a>Cray-1向量计算机结构：</h6><ul><li>向量寄存器组(V0-V7)：每个可存64个元素</li><li>标量寄存器(S0-S7)</li><li>后援寄存器(T0-T63)</li></ul><h4 id="2-MIMD细分类型"><a href="#2-MIMD细分类型" class="headerlink" title="2. MIMD细分类型"></a>2. MIMD细分类型</h4><h5 id="A-共享内存系统"><a href="#A-共享内存系统" class="headerlink" title="A. 共享内存系统"></a>A. 共享内存系统</h5><ol><li>集中共享内存(CSM&#x2F;SMP&#x2F;UMA)：</li></ol><ul><li>特点：所有处理器访问延迟相同</li><li>优点：编程简单</li><li>缺点：扩展性有限</li></ul><ol start="2"><li>分布式共享内存(DSM&#x2F;NUMA)：</li></ol><ul><li>特点：本地访问快，远程访问慢</li><li>两种类型：<ul><li>NC-NUMA：无缓存</li><li>CC-NUMA：带缓存一致性</li></ul></li></ul><h5 id="B-分布式内存系统"><a href="#B-分布式内存系统" class="headerlink" title="B. 分布式内存系统"></a>B. 分布式内存系统</h5><ol><li>MPP(大规模并行处理器)：</li></ol><ul><li>特点：专用高速互连网络</li><li>应用：科学计算</li><li>节点特征：共享磁盘系统</li></ul><ol start="2"><li>COW(工作站集群)：</li></ol><ul><li>特点：商用网络连接</li><li>应用：云计算数据中心</li><li>每节点独立完整</li></ul><h3 id="三、非冯诺依曼体系结构"><a href="#三、非冯诺依曼体系结构" class="headerlink" title="三、非冯诺依曼体系结构"></a>三、非冯诺依曼体系结构</h3><h4 id="1-主要类型："><a href="#1-主要类型：" class="headerlink" title="1. 主要类型："></a>1. 主要类型：</h4><ul><li>归约机</li><li>数据流计算机</li><li>量子计算机</li><li>光子计算机</li></ul><h4 id="2-数据流计算机特点："><a href="#2-数据流计算机特点：" class="headerlink" title="2. 数据流计算机特点："></a>2. 数据流计算机特点：</h4><ul><li>数据就绪驱动执行</li><li>打破串行执行限制</li><li>现代应用：云计算、大数据分析系统</li></ul><h5 id="重要图表位置标注：-1"><a href="#重要图表位置标注：-1" class="headerlink" title="重要图表位置标注："></a>重要图表位置标注：</h5><ul><li>Flynn分类法示意图：P29</li><li>共享内存系统架构图：P64-65</li><li>分布式内存系统架构图：P74</li><li>冯诺依曼架构图：P83</li></ul><h2 id="高性能处理器的并行计算技术-指令级并行"><a href="#高性能处理器的并行计算技术-指令级并行" class="headerlink" title="高性能处理器的并行计算技术-指令级并行"></a>高性能处理器的并行计算技术-指令级并行</h2><h3 id="一、指令级并行基础"><a href="#一、指令级并行基础" class="headerlink" title="一、指令级并行基础"></a>一、指令级并行基础</h3><h4 id="1-并行性类型"><a href="#1-并行性类型" class="headerlink" title="1. 并行性类型"></a>1. 并行性类型</h4><ol><li>数据级并行(DLP)</li></ol><ul><li>同时对多个数据项进行操作</li></ul><ol start="2"><li>任务级并行(TLP)</li></ol><ul><li>多个独立任务并行执行</li></ul><h4 id="2-硬件利用并行性的四种方式："><a href="#2-硬件利用并行性的四种方式：" class="headerlink" title="2. 硬件利用并行性的四种方式："></a>2. 硬件利用并行性的四种方式：</h4><h5 id="A-指令级并行-ILP-："><a href="#A-指令级并行-ILP-：" class="headerlink" title="A. 指令级并行(ILP)："></a>A. 指令级并行(ILP)：</h5><ul><li>通过流水线和投机执行等方式利用DLP</li><li>主要特征：深度流水线、多功能部件、多发射</li></ul><h5 id="B-向量架构和GPU："><a href="#B-向量架构和GPU：" class="headerlink" title="B. 向量架构和GPU："></a>B. 向量架构和GPU：</h5><ul><li>单指令操作多个数据集合</li></ul><h5 id="C-线程级并行："><a href="#C-线程级并行：" class="headerlink" title="C. 线程级并行："></a>C. 线程级并行：</h5><ul><li>利用多线程执行</li></ul><h5 id="D-请求级并行："><a href="#D-请求级并行：" class="headerlink" title="D. 请求级并行："></a>D. 请求级并行：</h5><ul><li>处理独立的程序请求</li></ul><h3 id="二、指令级并行的挑战"><a href="#二、指令级并行的挑战" class="headerlink" title="二、指令级并行的挑战"></a>二、指令级并行的挑战</h3><h4 id="1-三种基本冒险："><a href="#1-三种基本冒险：" class="headerlink" title="1. 三种基本冒险："></a>1. 三种基本冒险：</h4><h5 id="A-结构冒险："><a href="#A-结构冒险：" class="headerlink" title="A. 结构冒险："></a>A. 结构冒险：</h5><ul><li>原因：多条指令竞争同一硬件资源</li><li>示例：内存端口争用</li><li>解决方案：资源复制(如分离的数据Cache和指令Cache)</li></ul><h5 id="B-数据冒险："><a href="#B-数据冒险：" class="headerlink" title="B. 数据冒险："></a>B. 数据冒险：</h5><ol><li><p>RAW(Read After Write)：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I1: add r1,r2,r3</span><br><span class="line">I2: sub r4,r1,r3  // 等待r1</span><br></pre></td></tr></table></figure></li><li><p>WAR(Write After Read)：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I1: sub r4,r1,r3</span><br><span class="line">I2: add r1,r2,r3  // 必须等I1读完r1</span><br></pre></td></tr></table></figure></li><li><p>WAW(Write After Write)：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I1: sub r1,r4,r3</span><br><span class="line">I2: add r1,r2,r3  // 写入次序不能颠倒</span><br></pre></td></tr></table></figure></li></ol><h5 id="C-控制冒险："><a href="#C-控制冒险：" class="headerlink" title="C. 控制冒险："></a>C. 控制冒险：</h5><ul><li>由分支指令引起</li><li>影响严重：每3-6条指令就有一个分支</li><li>解决方案：分支预测</li></ul><h4 id="2-解决数据冒险的基本方法："><a href="#2-解决数据冒险的基本方法：" class="headerlink" title="2. 解决数据冒险的基本方法："></a>2. 解决数据冒险的基本方法：</h4><h5 id="A-转发（Forward）："><a href="#A-转发（Forward）：" class="headerlink" title="A. 转发（Forward）："></a>A. 转发（Forward）：</h5><ul><li>将计算结果直接转发给需要的功能部件</li><li>优点：减少等待时间</li><li>局限：不能解决所有RAW冒险</li></ul><h3 id="三、循环展开优化"><a href="#三、循环展开优化" class="headerlink" title="三、循环展开优化"></a>三、循环展开优化</h3><h4 id="重点概念：-2"><a href="#重点概念：-2" class="headerlink" title="重点概念："></a>重点概念：</h4><ol><li>循环展开目的：</li></ol><ul><li>减少循环控制开销</li><li>增加指令级并行机会</li></ul><ol start="2"><li>基本步骤：</li></ol><ul><li>确认循环迭代间独立性</li><li>使用不同寄存器避免名字相关</li><li>去除多余分支指令</li><li>调整循环终止条件</li><li>分析存储地址相关性</li><li>进行指令调度</li></ul><h5 id="实例分析：-2"><a href="#实例分析：-2" class="headerlink" title="实例分析："></a>实例分析：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原始循环：</span><br><span class="line">Loop: fld f0,0(x1)</span><br><span class="line">      fadd.d f4,f0,f2</span><br><span class="line">      fsd f4,0(x1)</span><br><span class="line">      addi x1,x1,-8</span><br><span class="line">      bne x1,x2,Loop</span><br></pre></td></tr></table></figure><p>展开优化后：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Loop: fld f0,0(x1)</span><br><span class="line">      fld f6,8(x1)</span><br><span class="line">      fld f10,16(x1)</span><br><span class="line">      fld f14,24(x1)</span><br><span class="line">      fadd.d f4,f0,f2</span><br><span class="line">      fadd.d f8,f6,f2</span><br><span class="line">      fadd.d f12,f0,f2</span><br><span class="line">      fadd.d f16,f14,f2</span><br><span class="line">      fsd f4,0(x1)</span><br><span class="line">      fsd f8,8(x1)</span><br><span class="line">      addi x1,x1,32</span><br><span class="line">      fsd f12,16(x1)</span><br><span class="line">      bne x1,x2,Loop</span><br><span class="line">      fsd f16,24(x1)</span><br></pre></td></tr></table></figure><p>优化效果：</p><ul><li>未优化：每循环10个时钟周期</li><li>优化后：每原始循环3.5个时钟周期</li><li>加速比：2.86倍</li></ul><h3 id="四、分支预测"><a href="#四、分支预测" class="headerlink" title="四、分支预测"></a>四、分支预测</h3><h4 id="1-基本概念与重要性"><a href="#1-基本概念与重要性" class="headerlink" title="1. 基本概念与重要性"></a>1. 基本概念与重要性</h4><h5 id="重点："><a href="#重点：" class="headerlink" title="重点："></a>重点：</h5><ul><li>分支指令频率：每3-6条指令就有一个分支</li><li>影响程序性能：10%-30%的性能损失</li><li>对ILP的影响：指令级并行度越高，分支预测的重要性越大</li></ul><h4 id="2-分支预测技术分类"><a href="#2-分支预测技术分类" class="headerlink" title="2. 分支预测技术分类"></a>2. 分支预测技术分类</h4><h5 id="A-静态预测："><a href="#A-静态预测：" class="headerlink" title="A. 静态预测："></a>A. 静态预测：</h5><ol><li>基于编译时信息</li><li>典型方法：</li></ol><ul><li>总是预测分支不跳转</li><li>总是预测分支跳转</li><li>延迟分支（Delayed Branch）</li></ul><h5 id="B-动态预测："><a href="#B-动态预测：" class="headerlink" title="B. 动态预测："></a>B. 动态预测：</h5><ol><li>简单的1位预测器：</li></ol><ul><li>记录最近一次分支结果</li></ul><ol start="2"><li>2位预测器：</li></ol><ul><li>使用饱和计数器</li><li>需要连续两次预测错误才改变预测方向</li></ul><ol start="3"><li>相关预测器（两级预测器）：</li></ol><ul><li>(m,n)预测器：<ul><li>m位历史记录</li><li>n位预测器</li></ul></li><li>实例：(2,2)预测器<ul><li>全局历史：2位</li><li>每个分支2位预测器</li></ul></li></ul><ol start="4"><li>竞赛预测器（Tournament Predictor）：</li></ol><ul><li>结合局部预测和全局预测</li><li>动态选择更准确的预测器</li></ul><h4 id="3-分支目标缓存-BTB"><a href="#3-分支目标缓存-BTB" class="headerlink" title="3. 分支目标缓存(BTB)"></a>3. 分支目标缓存(BTB)</h4><h5 id="重要组成："><a href="#重要组成：" class="headerlink" title="重要组成："></a>重要组成：</h5><ol><li>基本结构：</li></ol><ul><li>分支指令PC</li><li>预测标志</li><li>目标地址</li></ul><ol start="2"><li><p>工作流程：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (PC in BTB) &#123;</span><br><span class="line">    next_PC = predicted_target;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    next_PC = PC + 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>失效代价：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BTB失效类型   预测   实际   惩罚周期</span><br><span class="line">命中          跳转   跳转   0</span><br><span class="line">命中          跳转   不跳转 2</span><br><span class="line">未命中        -      跳转   2</span><br><span class="line">未命中        -      不跳转 0</span><br></pre></td></tr></table></figure></li></ol><h3 id="五、推测执行"><a href="#五、推测执行" class="headerlink" title="五、推测执行"></a>五、推测执行</h3><h4 id="1-重排序缓冲区-ROB"><a href="#1-重排序缓冲区-ROB" class="headerlink" title="1. 重排序缓冲区(ROB)"></a>1. 重排序缓冲区(ROB)</h4><h5 id="重点概念：-3"><a href="#重点概念：-3" class="headerlink" title="重点概念："></a>重点概念：</h5><ol><li>ROB的基本功能：</li></ol><ul><li>按序发射</li><li>乱序执行</li><li>按序提交</li></ul><ol start="2"><li>ROB条目构成：</li></ol><ul><li>指令类型</li><li>目标寄存器</li><li>值</li><li>就绪标志</li></ul><h5 id="重要机制："><a href="#重要机制：" class="headerlink" title="重要机制："></a>重要机制：</h5><ol><li>指令发射：</li></ol><ul><li>分配ROB和保留站</li><li>读取可用操作数</li></ul><ol start="2"><li>指令执行：</li></ol><ul><li>操作数就绪即可执行</li><li>结果暂存ROB</li></ul><ol start="3"><li>写回结果：</li></ol><ul><li>通过CDB广播结果</li><li>更新等待该结果的条目</li></ul><ol start="4"><li>提交过程：</li></ol><ul><li>按程序顺序提交</li><li>确保精确中断</li><li>处理预测错误</li></ul><h4 id="2-实例分析"><a href="#2-实例分析" class="headerlink" title="2. 实例分析"></a>2. 实例分析</h4><h5 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L.D F6,34(R2)</span><br><span class="line">L.D F2,45(R3)</span><br><span class="line">MUL.D F0,F2,F4</span><br><span class="line">SUB.D F8,F6,F2</span><br><span class="line">DIV.D F10,F0,F6</span><br><span class="line">ADD.D F6,F8,F2</span><br></pre></td></tr></table></figure><h5 id="执行过程："><a href="#执行过程：" class="headerlink" title="执行过程："></a>执行过程：</h5><ol><li>Load指令:</li></ol><ul><li>立即发射</li><li>等待内存访问</li><li>按序提交</li></ul><ol start="2"><li>计算指令：</li></ol><ul><li>等待操作数就绪</li><li>乱序执行</li><li>按序提交</li></ul><ol start="3"><li>分支预测错误处理：</li></ol><ul><li>清除ROB中错误路径指令</li><li>恢复正确的程序状态</li></ul><p>【重要图表位置】</p><ul><li>两级预测器结构图：P25</li><li>BTB结构图：P37</li><li>ROB组织结构图：P47</li></ul><h3 id="六、超标量-Superscalar-处理器"><a href="#六、超标量-Superscalar-处理器" class="headerlink" title="六、超标量(Superscalar)处理器"></a>六、超标量(Superscalar)处理器</h3><h4 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1. 基本原理"></a>1. 基本原理</h4><ol><li>核心特征：</li></ol><ul><li>每个时钟周期发射多条指令</li><li>动态检测指令间依赖</li><li>硬件负责调度</li></ul><ol start="2"><li>关键组件：</li></ol><ul><li>多个功能部件</li><li>复杂的发射逻辑</li><li>动态依赖检测</li></ul><h4 id="2-主要挑战"><a href="#2-主要挑战" class="headerlink" title="2. 主要挑战"></a>2. 主要挑战</h4><h5 id="A-结构复杂度："><a href="#A-结构复杂度：" class="headerlink" title="A. 结构复杂度："></a>A. 结构复杂度：</h5><ul><li>检测W条待发射指令与L组执行指令间的依赖</li><li>复杂度：O(W * (W*L))</li></ul><h5 id="B-性能瓶颈："><a href="#B-性能瓶颈：" class="headerlink" title="B. 性能瓶颈："></a>B. 性能瓶颈：</h5><ol><li>指令发射带宽限制</li><li>功能部件数量限制</li><li>转发(Forward)复杂度增加</li></ol><h4 id="3-实例分析"><a href="#3-实例分析" class="headerlink" title="3. 实例分析"></a>3. 实例分析</h4><p>双发射MIPS处理器示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Loop: L.D F0,0(R1)</span><br><span class="line">      ADD.D F4,F0,F2</span><br><span class="line">      S.D F4,0(R1)</span><br><span class="line">      DADDIU R1,R1,#-8</span><br><span class="line">      BNE R1,R2,Loop</span><br></pre></td></tr></table></figure><p>执行效率：</p><ul><li>IPC(Instructions Per Clock)：1.67</li><li>每3个时钟完成一次循环迭代</li></ul><h3 id="二、超长指令字-VLIW"><a href="#二、超长指令字-VLIW" class="headerlink" title="二、超长指令字(VLIW)"></a>二、超长指令字(VLIW)</h3><h4 id="1-基本特征："><a href="#1-基本特征：" class="headerlink" title="1. 基本特征："></a>1. 基本特征：</h4><ol><li>编译时调度：</li></ol><ul><li>编译器负责发现并行性</li><li>将多条独立指令打包</li></ul><ol start="2"><li>指令包格式：</li></ol><ul><li>长度：112-168位</li><li>典型组成：<ul><li>2个整数运算</li><li>2个浮点运算</li><li>2个访存操作</li><li>1个分支指令</li></ul></li></ul><h4 id="2-优缺点分析"><a href="#2-优缺点分析" class="headerlink" title="2. 优缺点分析"></a>2. 优缺点分析</h4><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ol><li>硬件简单</li><li>执行效率高</li><li>功耗低</li></ol><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ol><li>代码膨胀</li><li>可移植性差</li><li>Lock-step限制</li></ol><h5 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h5><ol><li>代码压缩</li><li>动态调度</li><li>目标代码转换</li></ol><h3 id="七、同时多线程-SMT"><a href="#七、同时多线程-SMT" class="headerlink" title="七、同时多线程(SMT)"></a>七、同时多线程(SMT)</h3><h4 id="1-基本概念："><a href="#1-基本概念：" class="headerlink" title="1. 基本概念："></a>1. 基本概念：</h4><ul><li>多个线程共享处理器资源</li><li>每个线程有独立的上下文</li><li>支持快速线程切换</li></ul><h4 id="2-实现方式："><a href="#2-实现方式：" class="headerlink" title="2. 实现方式："></a>2. 实现方式：</h4><h5 id="A-细粒度多线程："><a href="#A-细粒度多线程：" class="headerlink" title="A. 细粒度多线程："></a>A. 细粒度多线程：</h5><ul><li>每个时钟切换线程</li><li>优点：资源利用率高</li><li>缺点：单线程延迟增加</li></ul><h5 id="B-粗粒度多线程："><a href="#B-粗粒度多线程：" class="headerlink" title="B. 粗粒度多线程："></a>B. 粗粒度多线程：</h5><ul><li>长延迟事件触发切换</li><li>优点：单线程性能好</li><li>缺点：资源利用率较低</li></ul><h5 id="C-同时多线程-SMT-："><a href="#C-同时多线程-SMT-：" class="headerlink" title="C. 同时多线程(SMT)："></a>C. 同时多线程(SMT)：</h5><ul><li>多个线程同时执行</li><li>结合超标量技术</li><li>需要更多硬件资源</li></ul><h3 id="八、ILP限制因素"><a href="#八、ILP限制因素" class="headerlink" title="八、ILP限制因素"></a>八、ILP限制因素</h3><h4 id="1-理想处理器假设："><a href="#1-理想处理器假设：" class="headerlink" title="1. 理想处理器假设："></a>1. 理想处理器假设：</h4><ol><li>无限虚拟寄存器</li><li>完美分支预测</li><li>完美值预测</li><li>无限缓存</li></ol><h4 id="2-实际限制："><a href="#2-实际限制：" class="headerlink" title="2. 实际限制："></a>2. 实际限制：</h4><h5 id="A-指令窗口大小："><a href="#A-指令窗口大小：" class="headerlink" title="A. 指令窗口大小："></a>A. 指令窗口大小：</h5><ul><li>实际窗口大小：数百条指令</li><li>影响IPC显著</li></ul><h5 id="B-分支预测："><a href="#B-分支预测：" class="headerlink" title="B. 分支预测："></a>B. 分支预测：</h5><ul><li>完美预测vs实际预测</li><li>预测错误代价高</li></ul><h5 id="C-寄存器数量："><a href="#C-寄存器数量：" class="headerlink" title="C. 寄存器数量："></a>C. 寄存器数量：</h5><ul><li>256个寄存器基本足够</li><li>更多寄存器收益递减</li></ul><h5 id="重要图表位置：-1"><a href="#重要图表位置：-1" class="headerlink" title="重要图表位置："></a>重要图表位置：</h5><ul><li>窗口大小影响：P60-61</li><li>分支预测影响：P64-65</li><li>寄存器数量影响：P67-68</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elective </tag>
            
            <tag> CA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Database Principle</title>
      <link href="/2024/11/25/Database_Principle/"/>
      <url>/2024/11/25/Database_Principle/</url>
      
        <content type="html"><![CDATA[<p>本文基于《Database System Concepts, 7th Ed.》的课本内容，对 SYSU-CSE DCS281 计算机专业课《数据库系统原理》进行较为详尽的知识点总结，涵盖少量实例分析。</p><h2 id="第一章-数据库系统概述"><a href="#第一章-数据库系统概述" class="headerlink" title="第一章 数据库系统概述"></a>第一章 数据库系统概述</h2><h3 id="1-1-数据库应用实例"><a href="#1-1-数据库应用实例" class="headerlink" title="1.1 数据库应用实例"></a>1.1 数据库应用实例</h3><p><strong>重点：</strong></p><ul><li>了解数据库在各行业中的应用，如企业信息管理、制造业、银行与金融、大学系统、航空公司、电信、网络服务等。</li></ul><p><strong>难点：</strong></p><ul><li>理解不同应用场景下数据库系统的具体需求和实现方式。</li></ul><p><strong>实例分析：</strong></p><ul><li><strong>银行与金融</strong>：管理客户信息、账户、贷款及交易。</li><li><strong>航空公司</strong>：处理预订和航班时刻表。</li><li><strong>电信</strong>：记录通话、短信和数据使用情况，生成月度账单。</li></ul><h3 id="1-2-数据与数据库系统"><a href="#1-2-数据与数据库系统" class="headerlink" title="1.2 数据与数据库系统"></a>1.2 数据与数据库系统</h3><p><strong>重点：</strong></p><ul><li>区分数据与信息，理解数据库系统的定义及其目的。</li></ul><p><strong>难点：</strong></p><ul><li>理解数据抽象及其在数据库系统中的作用。</li></ul><p><strong>实例分析：</strong></p><ul><li><strong>数据</strong>：符号化的信息，如学生成绩、图片的像素点。</li><li><strong>信息</strong>：数据的语义解释，如“学生A的数学成绩为90分”。</li></ul><h3 id="1-3-数据库系统组件"><a href="#1-3-数据库系统组件" class="headerlink" title="1.3 数据库系统组件"></a>1.3 数据库系统组件</h3><p><strong>重点：</strong></p><ul><li>数据库系统的组成部分：硬件、软件、数据、用户。</li></ul><p><strong>难点：</strong></p><ul><li>理解各组件在数据库系统中的角色及其相互关系。</li></ul><p><strong>实例分析：</strong></p><ul><li><strong>硬件</strong>：大容量内存、外存设备（如磁盘、磁带）。</li><li><strong>软件</strong>：操作系统、DBMS、编程接口。</li><li><strong>数据</strong>：目标数据与描述数据。</li><li><strong>用户</strong>：最终用户、应用程序员、系统分析员、数据库管理员（DBA）。</li></ul><h3 id="1-4-数据库设计"><a href="#1-4-数据库设计" class="headerlink" title="1.4 数据库设计"></a>1.4 数据库设计</h3><p><strong>重点：</strong></p><ul><li>理解数据库设计的逻辑设计与物理设计。</li><li>理解模式（Schema）与实例（Instance）的区别。</li></ul><p><strong>难点：</strong></p><ul><li>如何进行有效的数据库模式设计，确保数据的一致性和完整性。</li></ul><p><strong>实例分析：</strong></p><ul><li><strong>逻辑设计</strong>：定义关系模式，如 <code>instructor(ID, name, dept_name, salary)</code>。</li><li><strong>物理设计</strong>：决定数据在存储介质上的实际存储方式。</li></ul><h3 id="1-5-数据定义语言（DDL）与数据操作语言（DML）"><a href="#1-5-数据定义语言（DDL）与数据操作语言（DML）" class="headerlink" title="1.5 数据定义语言（DDL）与数据操作语言（DML）"></a>1.5 数据定义语言（DDL）与数据操作语言（DML）</h3><p><strong>重点：</strong></p><ul><li>DDL用于定义数据库模式，如创建表。</li><li>DML用于访问和操作数据库中的数据，如查询、插入、更新、删除。</li></ul><p><strong>难点：</strong></p><ul><li>理解DDL与DML的区别及其在实际操作中的应用。</li></ul><p><strong>实例分析：</strong></p><ul><li><p><strong>DDL 示例</strong>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> instructor (</span><br><span class="line">    ID <span class="type">CHAR</span>(<span class="number">5</span>),</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    dept_name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    salary <span class="type">NUMERIC</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p><strong>DML 示例</strong>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> instructor</span><br><span class="line"><span class="keyword">WHERE</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Comp. Sci.&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-6-SQL查询语言"><a href="#1-6-SQL查询语言" class="headerlink" title="1.6 SQL查询语言"></a>1.6 SQL查询语言</h3><p><strong>重点：</strong></p><ul><li>SQL作为非过程化查询语言的基本语法和使用方法。</li></ul><p><strong>难点：</strong></p><ul><li>编写复杂的SQL查询，包括多表联接、子查询等。</li></ul><p><strong>实例分析：</strong></p><ul><li><p><strong>查询示例</strong>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> instructor</span><br><span class="line"><span class="keyword">WHERE</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Physics&#x27;</span> <span class="keyword">AND</span> salary <span class="operator">&gt;</span> <span class="number">90000</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-7-数据库系统架构"><a href="#1-7-数据库系统架构" class="headerlink" title="1.7 数据库系统架构"></a>1.7 数据库系统架构</h3><p><strong>重点：</strong></p><ul><li>理解集中式数据库、客户端-服务器架构、并行数据库和分布式数据库的区别。</li></ul><p><strong>难点：</strong></p><ul><li>选择适合特定应用场景的数据库架构。</li></ul><p><strong>实例分析：</strong></p><ul><li><strong>三层架构</strong>：客户端、应用服务器、数据库服务器。</li><li><strong>分布式数据库</strong>：支持地理分布的数据存储和访问。</li></ul><h3 id="1-8-数据库系统的发展历史"><a href="#1-8-数据库系统的发展历史" class="headerlink" title="1.8 数据库系统的发展历史"></a>1.8 数据库系统的发展历史</h3><p><strong>重点：</strong></p><ul><li>数据库系统的发展历程，从磁带时代到关系模型，再到现代的NoSQL和大数据系统。</li></ul><p><strong>难点：</strong></p><ul><li>理解不同历史阶段数据库技术的演进及其驱动因素。</li></ul><p><strong>实例分析：</strong></p><ul><li><strong>关系模型的提出</strong>：E.F. Codd在1970年提出关系模型，奠定了现代关系数据库的基础。</li><li><strong>NoSQL系统</strong>：如Google BigTable、Amazon Dynamo，适用于大规模分布式数据存储。</li></ul><hr><h2 id="第二章-关系模型与关系代数"><a href="#第二章-关系模型与关系代数" class="headerlink" title="第二章 关系模型与关系代数"></a>第二章 关系模型与关系代数</h2><h3 id="2-1-关系模型基础"><a href="#2-1-关系模型基础" class="headerlink" title="2.1 关系模型基础"></a>2.1 关系模型基础</h3><p><strong>重点：</strong></p><ul><li>关系模型的三要素：关系、属性、元组。</li><li>理解关系数据库的模式与实例。</li></ul><p><strong>难点：</strong></p><ul><li>理解关系的数学定义及其在数据库中的应用。</li></ul><p><strong>实例分析：</strong></p><ul><li><p><strong>关系定义</strong>：</p><p>关系R定义在D1, D2, …, Dn上的笛卡尔积 D1×D2×…×Dn 的一个命名子集。</p></li><li><p><strong>示例关系</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">student (student_no, sex, name)</span><br><span class="line">-------------------------------</span><br><span class="line">1 | Male | Jones</span><br><span class="line">2 | Male | Smith</span><br><span class="line">3 | Female | Kate</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2-关系的性质"><a href="#2-2-关系的性质" class="headerlink" title="2.2 关系的性质"></a>2.2 关系的性质</h3><p><strong>重点：</strong></p><ul><li>关系的基本性质：列同质性、行唯一性、无序性、原子性。</li></ul><p><strong>难点：</strong></p><ul><li>理解并应用第一范式（1NF）概念。</li></ul><p><strong>实例分析：</strong></p><ul><li><p><strong>违反1NF的例子</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A | B | A</span><br><span class="line">------------</span><br><span class="line">1 | &quot;abc&quot; | &quot;c&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>满足1NF的例子</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A | B | C</span><br><span class="line">------------</span><br><span class="line">1 | &quot;abc&quot; | &quot;c&quot;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3-关键字概念"><a href="#2-3-关键字概念" class="headerlink" title="2.3 关键字概念"></a>2.3 关键字概念</h3><p><strong>重点：</strong></p><ul><li>主键、外键、候选键、超键的定义与区别。</li></ul><p><strong>难点：</strong></p><ul><li>理解外键的引用机制，不依赖于属性名称相同。</li></ul><p><strong>实例分析：</strong></p><ul><li><p><strong>外键示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">student (dept_no, student_no, name, sex)</span><br><span class="line">department (dept_no, dept_name)</span><br></pre></td></tr></table></figure><p><code>dept_no</code>在<code>student</code>中作为外键，引用<code>department</code>中的主键<code>dept_no</code>。</p></li></ul><h3 id="2-4-关系代数操作"><a href="#2-4-关系代数操作" class="headerlink" title="2.4 关系代数操作"></a>2.4 关系代数操作</h3><p><strong>重点：</strong></p><ul><li>关系代数的基本操作：选择（σ）、投影（π）、并（∪）、差（−）、笛卡尔积（×）、重命名（ρ）。</li></ul><p><strong>难点：</strong></p><ul><li>组合多个关系代数操作以构建复杂查询。</li></ul><p><strong>实例分析：</strong></p><ul><li><p><strong>选择操作</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">σ dept_name=&quot;Physics&quot; (instructor)</span><br></pre></td></tr></table></figure></li><li><p><strong>投影操作</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">π name (σ dept_name=&quot;Physics&quot; (instructor))</span><br></pre></td></tr></table></figure></li><li><p><strong>联合操作</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">π course_id (σ semester=&quot;Fall&quot; AND year=2017 (section)) </span><br><span class="line">∪ </span><br><span class="line">π course_id (σ semester=&quot;Spring&quot; AND year=2018 (section))</span><br></pre></td></tr></table></figure></li><li><p><strong>差集操作</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">π course_id (σ semester=&quot;Fall&quot; AND year=2017 (section)) </span><br><span class="line">− </span><br><span class="line">π course_id (σ semester=&quot;Spring&quot; AND year=2018 (section))</span><br></pre></td></tr></table></figure></li><li><p><strong>笛卡尔积与选择的结合</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">σ instructor.id = teaches.id (instructor × teaches)</span><br></pre></td></tr></table></figure></li><li><p><strong>重命名操作</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ρ boy (σ sex=&quot;Male&quot; (student))</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-5-关系操作实例"><a href="#2-5-关系操作实例" class="headerlink" title="2.5 关系操作实例"></a>2.5 关系操作实例</h3><p><strong>重点：</strong></p><ul><li>理解并能具体化关系代数操作的结果。</li></ul><p><strong>难点：</strong></p><ul><li>解析复杂关系代数表达式的执行步骤与结果。</li></ul><p><strong>实例分析：</strong></p><ul><li><p><strong>删除操作</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R ← R − E</span><br></pre></td></tr></table></figure><p>示例：从<code>student</code>中删除满足特定条件的元组。</p></li><li><p><strong>插入操作</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R ← R ∪ &#123; r &#125;</span><br></pre></td></tr></table></figure><p>示例：向<code>student</code>表中插入一个新元组。</p></li><li><p><strong>全部更新</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r ← π F1, F2, …, Fn (r)</span><br></pre></td></tr></table></figure><p>示例：对<code>Emp</code>表中所有职工的工资上调10%。</p></li><li><p><strong>部分更新</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r ← π F1, F2, …, Fn (σ p(r)) ∪ (r − σ p(r))</span><br></pre></td></tr></table></figure><p>示例：仅更新<code>Emp</code>表中姓名为“小张”的职工工资。</p></li></ul><h3 id="2-6-关系代数运算示例解析"><a href="#2-6-关系代数运算示例解析" class="headerlink" title="2.6 关系代数运算示例解析"></a>2.6 关系代数运算示例解析</h3><p><strong>重点：</strong></p><ul><li>熟练掌握关系代数运算的具体操作及其结果。</li></ul><p><strong>难点：</strong></p><ul><li>理解运算顺序及其对结果的影响。</li></ul><p><strong>实例分析：</strong></p><ul><li><p><strong>例1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">σ 1=1 (student)</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：返回<code>student</code>表中的所有元组，因为条件始终为真。</p></li><li><p><strong>例2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">σ 1=2 (student)</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：返回空集，因为条件始终为假。</p></li></ul><hr><h3 id="2-7-重点与难点总结"><a href="#2-7-重点与难点总结" class="headerlink" title="2.7 重点与难点总结"></a>2.7 重点与难点总结</h3><h4 id="重点："><a href="#重点：" class="headerlink" title="重点："></a>重点：</h4><ol><li><strong>关系模型的基本概念</strong>：关系、属性、元组、主键与外键。</li><li><strong>关系代数的基本操作</strong>：选择、投影、并、差、笛卡尔积、重命名。</li><li><strong>数据库设计</strong>：逻辑设计与物理设计，模式与实例的区别。</li><li><strong>SQL语言</strong>：DDL与DML的使用，编写复杂查询。</li><li><strong>数据库系统架构与组件</strong>：存储管理器、查询处理器、事务管理。</li></ol><h4 id="难点："><a href="#难点：" class="headerlink" title="难点："></a>难点：</h4><ol><li><strong>关系代数的复杂操作</strong>：多步操作的组合理解与应用。</li><li><strong>数据库设计中的范式</strong>：确保数据库设计符合高范式以避免数据冗余。</li><li><strong>事务管理与ACID特性</strong>：理解事务的原子性、一致性、隔离性与持久性。</li><li><strong>SQL的高级查询</strong>：子查询、联接操作、优化查询性能。</li></ol><hr><h3 id="2-8-关键术语解释"><a href="#2-8-关键术语解释" class="headerlink" title="2.8 关键术语解释"></a>2.8 关键术语解释</h3><ul><li><strong>关系（Relation）</strong>：一个二维表，由行（元组）和列（属性）组成。</li><li><strong>属性（Attribute）</strong>：关系中的列，具有唯一的名称和定义良好的域。</li><li><strong>元组（Tuple）</strong>：关系中的行，代表数据项的一个实例。</li><li><strong>主键（Primary Key）</strong>：唯一标识关系中每个元组的属性或属性组合。</li><li><strong>外键（Foreign Key）</strong>：一个关系中的属性或属性组合，用于引用另一个关系的主键。</li><li><strong>关系代数（Relational Algebra）</strong>：一种过程化查询语言，用于对关系进行操作和查询。</li><li><strong>范式（Normal Form）</strong>：数据库设计中的规范，用以减少数据冗余和确保数据一致性。</li><li><strong>事务（Transaction）</strong>：一组操作，要么全部执行成功，要么全部失败，确保数据库的一致性。</li></ul><hr><h3 id="2-9-图表与图示描述"><a href="#2-9-图表与图示描述" class="headerlink" title="2.9 图表与图示描述"></a>2.9 图表与图示描述</h3><p>由于文本性质，以下为关键图表和图示的文字描述：</p><ol><li><p><strong>数据库系统架构图</strong>：</p><ul><li>分为三个层次：<ul><li><strong>物理层</strong>：描述数据在存储介质上的存储方式。</li><li><strong>逻辑层</strong>：描述数据库中的数据结构和关系。</li><li><strong>视图层</strong>：不同用户视角的数据展示，隐藏底层细节。</li></ul></li></ul></li><li><p><strong>关系模型示意图</strong>：</p><ul><li>展示一个关系的二维表结构，包括属性名、元组行，以及主键与外键的标识。</li></ul></li><li><p><strong>关系代数操作流程图</strong>：</p><ul><li>例如，选择操作σ的流程：输入关系 → 应用选择条件 → 输出满足条件的子集关系。</li></ul></li><li><p><strong>事务管理流程图</strong>：</p><ul><li>展示事务的开始、执行、提交或回滚的过程，确保ACID特性。</li></ul></li></ol><hr><h3 id="2-10-实例分析详解"><a href="#2-10-实例分析详解" class="headerlink" title="2.10 实例分析详解"></a>2.10 实例分析详解</h3><h4 id="实例1：关系代数的选择操作"><a href="#实例1：关系代数的选择操作" class="headerlink" title="实例1：关系代数的选择操作"></a>实例1：关系代数的选择操作</h4><p><strong>问题描述：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">σ dept_name=&quot;Physics&quot; AND salary &gt; 90000 (instructor)</span><br></pre></td></tr></table></figure><p><strong>步骤解析：</strong></p><ol><li><strong>输入关系</strong>：<code>instructor</code>表。</li><li><strong>选择条件</strong>：<code>dept_name</code>等于”Physics”且<code>salary</code>大于90000。</li><li><strong>执行操作</strong>：遍历<code>instructor</code>表中的每个元组，筛选符合条件的元组。</li><li><strong>输出结果</strong>：所有属于”Physics”系且工资超过90000的教员信息。</li></ol><p><strong>SQL等效语句：</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> instructor</span><br><span class="line"><span class="keyword">WHERE</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Physics&#x27;</span> <span class="keyword">AND</span> salary <span class="operator">&gt;</span> <span class="number">90000</span>;</span><br></pre></td></tr></table></figure><h4 id="实例2：关系代数的联合操作"><a href="#实例2：关系代数的联合操作" class="headerlink" title="实例2：关系代数的联合操作"></a>实例2：关系代数的联合操作</h4><p><strong>问题描述：</strong><br>查找所有在2017年秋季和2018年春季教授的课程。</p><p><strong>关系代数表达式：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">π course_id (σ semester=&quot;Fall&quot; AND year=2017 (section))</span><br><span class="line">∪</span><br><span class="line">π course_id (σ semester=&quot;Spring&quot; AND year=2018 (section))</span><br></pre></td></tr></table></figure><p><strong>步骤解析：</strong></p><ol><li><strong>第一部分</strong>：选择<code>semester</code>为”Fall”且<code>year</code>为2017的<code>section</code>表中的<code>course_id</code>。</li><li><strong>第二部分</strong>：选择<code>semester</code>为”Spring”且<code>year</code>为2018的<code>section</code>表中的<code>course_id</code>。</li><li><strong>执行联合操作</strong>：将两部分结果合并，去除重复的<code>course_id</code>。</li><li><strong>输出结果</strong>：所有在指定学期教授过的课程编号。</li></ol><p><strong>SQL等效语句：</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> course_id</span><br><span class="line"><span class="keyword">FROM</span> section</span><br><span class="line"><span class="keyword">WHERE</span> semester <span class="operator">=</span> <span class="string">&#x27;Fall&#x27;</span> <span class="keyword">AND</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2017</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> course_id</span><br><span class="line"><span class="keyword">FROM</span> section</span><br><span class="line"><span class="keyword">WHERE</span> semester <span class="operator">=</span> <span class="string">&#x27;Spring&#x27;</span> <span class="keyword">AND</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2018</span>;</span><br></pre></td></tr></table></figure><h4 id="实例3：SQL插入操作"><a href="#实例3：SQL插入操作" class="headerlink" title="实例3：SQL插入操作"></a>实例3：SQL插入操作</h4><p><strong>问题描述：</strong><br>向<code>student</code>表中插入一个新学生，学号为4，姓名“小周”，性别“女”。</p><p><strong>关系代数表达式：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S ← S ∪ &#123; (4, &quot;小周&quot;, &quot;女&quot;) &#125;</span><br></pre></td></tr></table></figure><p><strong>SQL语句：</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student (student_no, name, sex) <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;小周&#x27;</span>, <span class="string">&#x27;女&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>执行步骤：</strong></p><ol><li><strong>指定目标关系</strong>：<code>student</code>表。</li><li><strong>定义新元组</strong>：学号为4，姓名“小周”，性别“女”。</li><li><strong>执行插入操作</strong>：将新元组添加到<code>student</code>表中。</li></ol><p><strong>结果：</strong><br><code>student</code>表新增一条记录：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">student_no | name | sex</span><br><span class="line">---------- | ---- | ---</span><br><span class="line">4          | 小周 | 女</span><br></pre></td></tr></table></figure><h4 id="实例4：关系代数的笛卡尔积与选择"><a href="#实例4：关系代数的笛卡尔积与选择" class="headerlink" title="实例4：关系代数的笛卡尔积与选择"></a>实例4：关系代数的笛卡尔积与选择</h4><p><strong>问题描述：</strong><br>将<code>instructor</code>与<code>teaches</code>表进行笛卡尔积，并筛选出匹配的教员与课程。</p><p><strong>关系代数表达式：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">σ instructor.id = teaches.id (instructor × teaches)</span><br></pre></td></tr></table></figure><p><strong>步骤解析：</strong></p><ol><li><strong>笛卡尔积</strong>：生成<code>instructor</code>与<code>teaches</code>表的所有可能行组合。</li><li><strong>选择操作</strong>：仅保留<code>instructor.id</code>等于<code>teaches.id</code>的元组。</li><li><strong>输出结果</strong>：教员与其教授课程的对应关系。</li></ol><p><strong>SQL等效语句：</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> instructor</span><br><span class="line"><span class="keyword">JOIN</span> teaches <span class="keyword">ON</span> instructor.id <span class="operator">=</span> teaches.id;</span><br></pre></td></tr></table></figure><p><strong>结果示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">instructor.ID | instructor.name | teaches.course_id</span><br><span class="line">------------- | --------------- | -----------------</span><br><span class="line">1             | 张三            | CS101</span><br><span class="line">2             | 李四            | CS102</span><br></pre></td></tr></table></figure><hr><h2 id="第三章-SQL查询语言概述"><a href="#第三章-SQL查询语言概述" class="headerlink" title="第三章 SQL查询语言概述"></a>第三章 SQL查询语言概述</h2><h3 id="3-1-重点"><a href="#3-1-重点" class="headerlink" title="3.1 重点"></a>3.1 重点</h3><ol><li><p><strong>SQL语言的组成</strong>：</p><ul><li><strong>数据定义语言（DDL）</strong>：包括创建、修改和删除数据库对象（如表、视图、索引等）。</li><li><strong>数据操纵语言（DML）</strong>：用于查询、插入、更新和删除数据。</li><li><strong>数据控制语言（DCL）</strong>：用于授权和管理用户权限。</li></ul></li><li><p><strong>SQL数据类型与模式</strong>：</p><ul><li>常用数据类型包括<code>char(n)</code>、<code>varchar(n)</code>、<code>int</code>、<code>smallint</code>、<code>numeric(p,d)</code>、<code>real</code>、<code>double precision</code>、<code>float(n)</code>等。</li><li>模式定义了数据库中各关系的结构，包括属性名、数据类型、完整性约束等。</li></ul></li><li><p><strong>SQL语句结构</strong>：</p><ul><li><strong>SELECT语句</strong>：包含<code>SELECT</code>、<code>FROM</code>、<code>WHERE</code>、<code>GROUP BY</code>、<code>HAVING</code>、<code>ORDER BY</code>等子句。</li><li><strong>JOIN操作</strong>：包括自然连接、内连接和外连接，理解不同类型的连接及其应用。</li></ul></li><li><p><strong>完整性约束</strong>：</p><ul><li><strong>实体完整性</strong>：主键不允许为<code>NULL</code>，确保每个元组的唯一性。</li><li><strong>参照完整性</strong>：外键必须引用另一个关系的主键或唯一键。</li><li><strong>用户定义完整性</strong>：通过<code>CHECK</code>约束等自定义规则确保数据的合理性。</li></ul></li></ol><h3 id="3-2-难点"><a href="#3-2-难点" class="headerlink" title="3.2 难点"></a>3.2 难点</h3><ol><li><strong>子查询与嵌套查询</strong>：理解相关子查询与非相关子查询的区别及其在<code>SELECT</code>、<code>WHERE</code>、<code>FROM</code>子句中的应用。</li><li><strong>复杂连接操作</strong>：掌握多表连接、不同类型的外连接及其在实际问题中的应用，如避免错误的自然连接导致的数据失配。</li><li><strong>聚集函数与分组</strong>：正确使用<code>GROUP BY</code>和<code>HAVING</code>子句，理解聚集函数的作用及其在查询优化中的重要性。</li><li><strong>视图的创建与管理</strong>：理解视图的本质、创建复杂视图的条件以及视图的更新限制。</li></ol><h3 id="3-3-实例分析"><a href="#3-3-实例分析" class="headerlink" title="3.3 实例分析"></a>3.3 实例分析</h3><p><strong>例1：查找所有导师的姓名</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> instructor;</span><br></pre></td></tr></table></figure><p><strong>解答：</strong><br>该查询语句选择<code>instructor</code>关系中的<code>name</code>属性，返回所有导师的姓名。</p><hr><p><strong>例2：查找计算机科学系的导师姓名和课程编号</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, course_id</span><br><span class="line"><span class="keyword">FROM</span> instructor, teaches</span><br><span class="line"><span class="keyword">WHERE</span> instructor.ID <span class="operator">=</span> teaches.ID</span><br><span class="line">  <span class="keyword">AND</span> instructor.dept_name <span class="operator">=</span> <span class="string">&#x27;Comp. Sci.&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>解答：</strong><br>该查询通过连接<code>instructor</code>和<code>teaches</code>关系，筛选计算机科学系的导师，并返回他们的姓名及所教授的课程编号。</p><hr><p><strong>例3：删除数学成绩不及格的学生选修信息</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> takes</span><br><span class="line"><span class="keyword">WHERE</span> grade <span class="operator">&lt;</span> <span class="string">&#x27;60&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>解答：</strong><br>该语句从<code>takes</code>关系中删除所有成绩低于60的记录，假设60为及格线。</p><hr><p><strong>例4：增加所有导师的薪水5%</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> instructor</span><br><span class="line"><span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.05</span>;</span><br></pre></td></tr></table></figure><p><strong>解答：</strong><br>该语句将<code>instructor</code>关系中所有导师的薪水增加5%。</p><hr><p><strong>例5：使用子查询查找平均薪水以上的导师</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> instructor</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> instructor);</span><br></pre></td></tr></table></figure><p><strong>解答：</strong><br>该查询返回薪水高于所有导师平均薪水的导师姓名。</p><hr><p><strong>例6：创建视图显示不包含薪水的导师信息</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> faculty <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> ID, name, dept_name</span><br><span class="line"><span class="keyword">FROM</span> instructor;</span><br></pre></td></tr></table></figure><p><strong>解答：</strong><br>该视图<code>faculty</code>仅包含导师的<code>ID</code>、<code>name</code>和<code>dept_name</code>，隐藏了<code>salary</code>属性，提高了数据的安全性。</p><hr><p><strong>例7：使用JOIN操作查找学生及其班主任</strong></p><p>假设有两个关系：</p><ul><li><code>Stu</code>（学生）</li><li><code>Class</code>（班级）</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Stu.name, Class.ban_zhuren</span><br><span class="line"><span class="keyword">FROM</span> Stu</span><br><span class="line"><span class="keyword">JOIN</span> Class <span class="keyword">ON</span> Stu.ban_hao <span class="operator">=</span> Class.ban_hao;</span><br></pre></td></tr></table></figure><p><strong>解答：</strong><br>该查询通过<code>JOIN</code>操作连接<code>Stu</code>和<code>Class</code>关系，返回每个学生的姓名及其对应的班主任。</p><hr><h2 id="第四章-访问SQL与触发器"><a href="#第四章-访问SQL与触发器" class="headerlink" title="第四章 访问SQL与触发器"></a>第四章 访问SQL与触发器</h2><h3 id="4-1-重点"><a href="#4-1-重点" class="headerlink" title="4.1 重点"></a>4.1 重点</h3><ol><li><p><strong>访问SQL的两种方法</strong>：</p><ul><li><strong>动态SQL</strong>：在运行时生成和执行SQL语句，适合需要根据条件动态改变查询的场景。</li><li><strong>嵌入式SQL</strong>：将SQL语句嵌入到一般编程语言中，编译时转换为函数调用，提高执行效率。</li></ul></li><li><p><strong>JDBC（Java数据库连接）</strong>：</p><ul><li><strong>核心操作流程</strong>：加载驱动、建立连接、创建语句、执行查询、处理结果、关闭连接。</li><li><strong>特点</strong>：跨平台、支持对象-关系映射、网络独立性、数据库独立性等。</li></ul></li><li><p><strong>完整性约束与事务管理</strong>：</p><ul><li><strong>事务的ACID特性</strong>：原子性、一致性、隔离性、持久性。</li><li><strong>事务控制语句</strong>：<code>BEGIN TRANSACTION</code>、<code>COMMIT</code>、<code>ROLLBACK</code>等。</li></ul></li><li><p><strong>触发器</strong>：</p><ul><li><strong>定义与作用</strong>：在特定事件（如<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>）发生时自动执行的存储过程。</li><li><strong>类型</strong>：<code>AFTER</code>触发器、<code>INSTEAD OF</code>触发器。</li><li><strong>应用实例</strong>：维护数据一致性、自动更新相关表、日志记录等。</li></ul></li></ol><h3 id="4-2-难点"><a href="#4-2-难点" class="headerlink" title="4.2 难点"></a>4.2 难点</h3><ol><li><strong>触发器的设计与实现</strong>：如何正确设计触发器的触发条件和执行动作，避免递归触发和性能问题。</li><li><strong>事务的并发控制与隔离级别</strong>：理解不同隔离级别（如读未提交、读已提交、可重复读、串行化）的特点及其对数据库性能与一致性的影响。</li><li><strong>JDBC的高级特性</strong>：如批处理、预编译语句、元数据获取等，需要深入理解其API的使用方法和最佳实践。</li><li><strong>权限管理与安全性</strong>：正确配置用户权限，理解角色的创建与分配，以及视图在数据安全中的应用。</li></ol><h3 id="4-3-实例分析"><a href="#4-3-实例分析" class="headerlink" title="4.3 实例分析"></a>4.3 实例分析</h3><p><strong>例1：使用JDBC连接数据库并查询导师信息</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">JDBCexample</span><span class="params">(String dbid, String userid, String passwd)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(</span><br><span class="line">            <span class="string">&quot;jdbc:oracle:thin:@db.yale.edu:2000:univdb&quot;</span>, userid, passwd);</span><br><span class="line">         <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement()) &#123;</span><br><span class="line">        <span class="comment">// 执行查询</span></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(<span class="string">&quot;SELECT * FROM instructor&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">            System.out.println(rs.getString(<span class="string">&quot;name&quot;</span>) + <span class="string">&quot; &quot;</span> + rs.getFloat(<span class="string">&quot;salary&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException sqle) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SQLException : &quot;</span> + sqle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解答：</strong><br>该Java方法使用JDBC连接到Oracle数据库，查询<code>instructor</code>关系中的所有记录，并输出导师姓名和薪水。使用了<code>try-with-resources</code>语法确保资源自动关闭。</p><hr><p><strong>例2：创建一个AFTER触发器，更新学生总学分</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> credits_earned</span><br><span class="line">AFTER <span class="keyword">UPDATE</span> <span class="keyword">OF</span> takes.grade</span><br><span class="line"><span class="keyword">ON</span> takes</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">NEW</span> <span class="type">ROW</span> <span class="keyword">AS</span> nrow <span class="keyword">OLD</span> <span class="type">ROW</span> <span class="keyword">AS</span> orow</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span> (nrow.grade <span class="operator">&lt;&gt;</span> <span class="string">&#x27;F&#x27;</span> <span class="keyword">AND</span> nrow.grade <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">AND</span> (orow.grade <span class="operator">=</span> <span class="string">&#x27;F&#x27;</span> <span class="keyword">OR</span> orow.grade <span class="keyword">IS</span> <span class="keyword">NULL</span>))</span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span></span><br><span class="line">    <span class="keyword">UPDATE</span> student</span><br><span class="line">    <span class="keyword">SET</span> tot_cred <span class="operator">=</span> tot_cred <span class="operator">+</span></span><br><span class="line">        (<span class="keyword">SELECT</span> credits <span class="keyword">FROM</span> course <span class="keyword">WHERE</span> course.course_id <span class="operator">=</span> nrow.course_id)</span><br><span class="line">    <span class="keyword">WHERE</span> student.id <span class="operator">=</span> nrow.id;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p><strong>解答：</strong><br>该触发器在<code>takes</code>关系的<code>grade</code>属性更新后执行。当新成绩不为<code>F</code>且不为空，且原成绩为<code>F</code>或为空时，触发器将相应课程的学分加到学生的总学分<code>tot_cred</code>中，确保学生的学分信息实时更新。</p><hr><p><strong>例3：使用JDBC执行INSERT操作并处理潜在的SQL注入风险</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO instructor (ID, name, dept_name, salary) VALUES (?, ?, ?, ?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">pstmt.setString(<span class="number">1</span>, <span class="string">&quot;88877&quot;</span>);</span><br><span class="line">pstmt.setString(<span class="number">2</span>, <span class="string">&quot;Perry&quot;</span>);</span><br><span class="line">pstmt.setString(<span class="number">3</span>, <span class="string">&quot;Finance&quot;</span>);</span><br><span class="line">pstmt.setInt(<span class="number">4</span>, <span class="number">125000</span>);</span><br><span class="line">pstmt.executeUpdate();</span><br></pre></td></tr></table></figure><p><strong>解答：</strong><br>该Java代码使用预编译语句<code>PreparedStatement</code>插入新导师记录，避免了通过字符串拼接可能引发的SQL注入风险。确保了数据的安全性和完整性。</p><h3 id="4-4-第三章与第四章中提及的重要图示描述"><a href="#4-4-第三章与第四章中提及的重要图示描述" class="headerlink" title="4.4 第三章与第四章中提及的重要图示描述"></a>4.4 第三章与第四章中提及的重要图示描述</h3><ol><li><p><strong>视图的依赖关系图</strong>：</p><ul><li><strong>说明</strong>：图中展示了视图之间的依赖关系，如视图<code>physics_fall_2017_watson</code>依赖于视图<code>physics_fall_2017</code>，而<code>physics_fall_2017</code>又依赖于基础关系<code>course</code>和<code>section</code>。</li><li><strong>关键点</strong>：展示了视图层次结构，强调视图定义的递归展开过程，确保视图定义不是递归的以避免无限循环。</li></ul></li><li><p><strong>触发器执行过程图</strong>：</p><ul><li><strong>说明</strong>：图示展示了当执行<code>INSERT</code>、<code>UPDATE</code>或<code>DELETE</code>操作时，系统如何创建<code>inserted</code>和<code>deleted</code>临时表，并在触发器中使用这些表进行相应的数据操作。</li><li><strong>关键点</strong>：强调触发器在特定事件发生时自动执行，并利用临时表维护数据的前后状态。</li></ul></li><li><p><strong>JDBC操作流程图</strong>：</p><ul><li><strong>说明</strong>：图中展示了JDBC的典型操作流程，包括加载驱动、建立连接、创建语句、执行查询、处理结果集以及关闭连接的步骤。</li><li><strong>关键点</strong>：帮助理解JDBC在Java应用中与数据库交互的整体流程，提高编程实践的准确性。</li></ul></li><li><p><strong>联合查询与子查询示意图</strong>：</p><ul><li><strong>说明</strong>：图示展示了如何通过<code>JOIN</code>操作和嵌套<code>SELECT</code>子查询在多个关系间进行数据整合。</li><li><strong>关键点</strong>：帮助理解复杂查询的结构和执行顺序，增强对多表联结与子查询逻辑的掌握。</li></ul></li></ol><hr><h2 id="第五章-高级SQL"><a href="#第五章-高级SQL" class="headerlink" title="第五章 高级SQL"></a>第五章 高级SQL</h2><h3 id="5-1-重点"><a href="#5-1-重点" class="headerlink" title="5.1 重点"></a>5.1 重点</h3><ol><li><p><strong>SQL与编程语言的集成</strong>：</p><ul><li>理解如何通过不同的编程语言（如Java、Python、PHP等）访问和操作数据库。</li></ul></li><li><p><strong>JDBC的使用</strong>：</p><ul><li>掌握Java应用程序中使用JDBC连接数据库、执行SQL语句以及处理结果集的流程。</li></ul></li><li><p><strong>函数与存储过程</strong>：</p><ul><li>理解数据库中的函数和存储过程的定义与调用，掌握其在业务逻辑封装中的应用。</li></ul></li><li><p><strong>触发器的设计与应用</strong>：</p><ul><li>学会设计DML触发器（AFTER和INSTEAD OF），并理解其在自动执行副作用操作中的作用。</li></ul></li></ol><h3 id="5-2-难点"><a href="#5-2-难点" class="headerlink" title="5.2 难点"></a>5.2 难点</h3><ol><li><p><strong>事务管理与连接池</strong>：</p><ul><li>理解事务的概念，掌握如何在应用程序中正确管理事务，避免数据不一致。</li></ul></li><li><p><strong>安全性问题</strong>：</p><ul><li>理解SQL注入攻击的原理及防范措施，如使用预编译语句（Prepared Statements）。</li></ul></li><li><p><strong>元数据的使用</strong>：</p><ul><li>熟悉如何通过JDBC获取数据库及结果集的元数据，以动态处理不同的数据库结构。</li></ul></li></ol><h3 id="5-3-实例分析"><a href="#5-3-实例分析" class="headerlink" title="5.3 实例分析"></a>5.3 实例分析</h3><p><strong>例1：JDBC 连接与查询</strong></p><p><strong>任务：</strong> 使用JDBC连接到SQL Server数据库，执行查询并处理结果集。</p><p><strong>示例代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dbURL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:sqlserver://localhost:1433;databaseName=univdb&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;userid&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;passwd&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(dbURL, user, password);</span><br><span class="line">             <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT dept_name, AVG(salary) as avg_salary FROM instructor GROUP BY dept_name&quot;</span>;</span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">deptName</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;dept_name&quot;</span>);</span><br><span class="line">                <span class="type">float</span> <span class="variable">avgSalary</span> <span class="operator">=</span> rs.getFloat(<span class="string">&quot;avg_salary&quot;</span>);</span><br><span class="line">                System.out.println(deptName + <span class="string">&quot; &quot;</span> + avgSalary);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rs.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;SQLException: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>使用<code>DriverManager.getConnection</code>建立连接。</li><li>创建<code>Statement</code>对象执行SQL查询。</li><li>使用<code>ResultSet</code>处理查询结果。</li></ul><hr><p><strong>例2：使用预编译语句防止SQL注入</strong></p><p><strong>任务：</strong> 安全地向<code>instructor</code>表插入数据，防止SQL注入攻击。</p><p><strong>示例代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecureInsertExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dbURL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:sqlserver://localhost:1433;databaseName=univdb&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;userid&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;passwd&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">insertSQL</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO instructor (ID, name, dept_name, salary) VALUES (?, ?, ?, ?)&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(dbURL, user, password);</span><br><span class="line">             <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(insertSQL)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置参数</span></span><br><span class="line">            pstmt.setString(<span class="number">1</span>, <span class="string">&quot;88877&quot;</span>);</span><br><span class="line">            pstmt.setString(<span class="number">2</span>, <span class="string">&quot;Perry&quot;</span>);</span><br><span class="line">            pstmt.setString(<span class="number">3</span>, <span class="string">&quot;Finance&quot;</span>);</span><br><span class="line">            pstmt.setInt(<span class="number">4</span>, <span class="number">125000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行插入</span></span><br><span class="line">            pstmt.executeUpdate();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 插入另一条记录</span></span><br><span class="line">            pstmt.setString(<span class="number">1</span>, <span class="string">&quot;88878&quot;</span>);</span><br><span class="line">            pstmt.setString(<span class="number">2</span>, <span class="string">&quot;John&quot;</span>);</span><br><span class="line">            pstmt.setString(<span class="number">3</span>, <span class="string">&quot;Marketing&quot;</span>);</span><br><span class="line">            pstmt.setInt(<span class="number">4</span>, <span class="number">110000</span>);</span><br><span class="line">            pstmt.executeUpdate();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;数据插入成功。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;SQLException: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>使用<code>PreparedStatement</code>预编译SQL语句，防止恶意用户通过输入构造SQL注入攻击。</li><li>通过<code>set</code>方法动态设置参数值。</li></ul><hr><p><strong>例3：触发器的创建与使用</strong></p><p><strong>任务：</strong> 为<code>student</code>表创建一个AFTER INSERT触发器，更新<code>student_sum</code>表中的学生总数。</p><p><strong>示例SQL代码：</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建student表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">    stu_id <span class="type">INT</span> <span class="keyword">IDENTITY</span>(<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    stu_name <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    stu_gender <span class="type">CHAR</span>(<span class="number">2</span>),</span><br><span class="line">    stu_age <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建student_sum表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student_sum (</span><br><span class="line">    stuCount <span class="type">INT</span> <span class="keyword">DEFAULT</span>(<span class="number">0</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建AFTER INSERT触发器</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trig_insert</span><br><span class="line"><span class="keyword">ON</span> student</span><br><span class="line">AFTER <span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> <span class="variable">@stuNumber</span> <span class="type">INT</span>;</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="variable">@stuNumber</span> <span class="operator">=</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> student;</span><br><span class="line"></span><br><span class="line">    IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student_sum)</span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> student_sum <span class="keyword">VALUES</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">UPDATE</span> student_sum <span class="keyword">SET</span> stuCount <span class="operator">=</span> <span class="variable">@stuNumber</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建删除触发器</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trig_delete</span><br><span class="line"><span class="keyword">ON</span> student</span><br><span class="line">AFTER <span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> stu_id <span class="keyword">AS</span> 已删除的学生编号, stu_name, stu_gender, stu_age</span><br><span class="line">    <span class="keyword">FROM</span> deleted;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建更新触发器</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trig_update</span><br><span class="line"><span class="keyword">ON</span> student</span><br><span class="line">AFTER <span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> <span class="variable">@stuCount</span> <span class="type">INT</span>;</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="variable">@stuCount</span> <span class="operator">=</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> student;</span><br><span class="line">    <span class="keyword">UPDATE</span> student_sum <span class="keyword">SET</span> stuCount <span class="operator">=</span> <span class="variable">@stuCount</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">SELECT</span> stu_id <span class="keyword">AS</span> 更新前学生编号, stu_name <span class="keyword">AS</span> 更新前学生姓名 <span class="keyword">FROM</span> deleted;</span><br><span class="line">    <span class="keyword">SELECT</span> stu_id <span class="keyword">AS</span> 更新后学生编号, stu_name <span class="keyword">AS</span> 更新后学生姓名 <span class="keyword">FROM</span> inserted;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>触发器<code>trig_insert</code>在向<code>student</code>表插入新记录后执行，更新<code>student_sum</code>表中的学生总数。</li><li>触发器<code>trig_delete</code>在删除<code>student</code>表中的记录后执行，显示已删除的学生信息。</li><li>触发器<code>trig_update</code>在更新<code>student</code>表中的记录后执行，更新<code>student_sum</code>表并显示更新前后的学生信息。</li></ul><p><strong>注意事项：</strong></p><ul><li>确保在SQL Server中执行上述SQL语句时，具有相应的权限。</li><li>触发器中的<code>deleted</code>和<code>inserted</code>表是SQL Server中特殊的临时表，用于存储被删除和插入的元组。</li></ul><hr><h3 id="4-4-第三章与第四章中提及的重要图示描述-1"><a href="#4-4-第三章与第四章中提及的重要图示描述-1" class="headerlink" title="4.4 第三章与第四章中提及的重要图示描述"></a>4.4 第三章与第四章中提及的重要图示描述</h3><ol><li><p><strong>视图的依赖关系图</strong>：</p><ul><li><strong>说明</strong>：图中展示了视图之间的依赖关系，如视图<code>physics_fall_2017_watson</code>依赖于视图<code>physics_fall_2017</code>，而<code>physics_fall_2017</code>又依赖于基础关系<code>course</code>和<code>section</code>。</li><li><strong>关键点</strong>：展示了视图层次结构，强调视图定义的递归展开过程，确保视图定义不是递归的以避免无限循环。</li></ul></li><li><p><strong>触发器执行过程图</strong>：</p><ul><li><strong>说明</strong>：图示展示了当执行<code>INSERT</code>、<code>UPDATE</code>或<code>DELETE</code>操作时，系统如何创建<code>inserted</code>和<code>deleted</code>临时表，并在触发器中使用这些表进行相应的数据操作。</li><li><strong>关键点</strong>：强调触发器在特定事件发生时自动执行，并利用临时表维护数据的前后状态。</li></ul></li><li><p><strong>JDBC操作流程图</strong>：</p><ul><li><strong>说明</strong>：图中展示了JDBC的典型操作流程，包括加载驱动、建立连接、创建语句、执行查询、处理结果集以及关闭连接的步骤。</li><li><strong>关键点</strong>：帮助理解JDBC在Java应用中与数据库交互的整体流程，提高编程实践的准确性。</li></ul></li><li><p><strong>联合查询与子查询示意图</strong>：</p><ul><li><strong>说明</strong>：图示展示了如何通过<code>JOIN</code>操作和嵌套<code>SELECT</code>子查询在多个关系间进行数据整合。</li><li><strong>关键点</strong>：帮助理解复杂查询的结构和执行顺序，增强对多表联结与子查询逻辑的掌握。</li></ul></li></ol><hr><h2 id="第六章-基于E-R模型的数据库设计"><a href="#第六章-基于E-R模型的数据库设计" class="headerlink" title="第六章 基于E-R模型的数据库设计"></a>第六章 基于E-R模型的数据库设计</h2><h3 id="6-1-重点"><a href="#6-1-重点" class="headerlink" title="6.1 重点"></a>6.1 重点</h3><ol><li><strong>实体-关系模型（E-R模型）</strong>：理解实体、属性、关系及其在数据库设计中的应用。</li><li><strong>属性类型</strong>：掌握简单属性、复合属性、多值属性和派生属性的区别及其表示方法。</li><li><strong>关系的基数约束</strong>：熟悉一对一、一对多、多对多等关系的特点及其在E-R图中的表示。</li><li><strong>主键</strong>：了解实体集和关系集的主键选择及其在唯一标识实体中的作用。</li><li><strong>弱实体集与标识关系</strong>：掌握弱实体集的定义及其与标识实体集之间的关系。</li></ol><h3 id="6-2-难点"><a href="#6-2-难点" class="headerlink" title="6.2 难点"></a>6.2 难点</h3><ol><li><strong>E-R图到关系模式的转换</strong>：如何准确地将E-R图中的各个元素映射到关系数据库的模式中。</li><li><strong>处理多值属性</strong>：理解如何通过分离关系来消除多值属性带来的冗余。</li><li><strong>聚合与泛化&#x2F;特化</strong>：掌握在E-R模型中表示复杂关系和层次结构的方法。</li><li><strong>设计规范化</strong>：了解如何通过规范化过程消除冗余和避免更新异常。</li><li><strong>依赖约束的保持与无损分解</strong>：理解在关系模式分解过程中，如何保持功能依赖以及确保分解的无损性。</li></ol><h3 id="6-3-主要内容总结"><a href="#6-3-主要内容总结" class="headerlink" title="6.3 主要内容总结"></a>6.3 主要内容总结</h3><h4 id="1-数据库设计过程概述"><a href="#1-数据库设计过程概述" class="headerlink" title="1. 数据库设计过程概述"></a>1. 数据库设计过程概述</h4><p>数据库设计过程通常包括以下几个阶段：</p><ul><li><strong>需求分析</strong>：全面描述未来数据库用户的需求。</li><li><strong>概念设计</strong>：选择合适的数据模型（通常是E-R模型）并将需求转化为数据库的概念模式。</li><li><strong>逻辑设计</strong>：将概念模式转换为特定的数据模型（如关系模型）的逻辑模式。</li><li><strong>物理设计</strong>：决定数据库的物理存储结构和优化性能。</li></ul><h4 id="2-实体-关系模型（E-R模型）"><a href="#2-实体-关系模型（E-R模型）" class="headerlink" title="2. 实体-关系模型（E-R模型）"></a>2. 实体-关系模型（E-R模型）</h4><p>E-R模型用于概念化地描述数据库的结构，主要包括以下三个基本概念：</p><ul><li><strong>实体集（Entity Set）</strong>：表示具有相同属性的一类对象，如“学生”、“教师”。</li><li><strong>属性（Attribute）</strong>：描述实体集特征的字段，如“姓名”、“学号”。属性可以分为简单属性、复合属性、多值属性和派生属性。</li><li><strong>关系集（Relationship Set）</strong>：表示实体集之间的关联，如“学生选课”关系。</li></ul><h5 id="2-1-实体集与属性"><a href="#2-1-实体集与属性" class="headerlink" title="2.1 实体集与属性"></a>2.1 实体集与属性</h5><ul><li><strong>实体</strong>：可以独立存在并具有唯一标识的对象。</li><li><strong>主键（Primary Key）</strong>：用于唯一标识实体集中的每一个实体，如“学生”的学号。</li></ul><h5 id="2-2-属性类型"><a href="#2-2-属性类型" class="headerlink" title="2.2 属性类型"></a>2.2 属性类型</h5><ul><li><strong>简单属性</strong>：不可再分的属性，如“年龄”。</li><li><strong>复合属性</strong>：可以分解为更小的子属性，如“姓名”可以分为“名字”和“姓氏”。</li><li><strong>多值属性</strong>：一个实体可以有多个此类属性的值，如“电话号码”。</li><li><strong>派生属性</strong>：可以由其他属性计算得到，如“年龄”可以由“出生日期”计算得出。</li></ul><h5 id="2-3-关系集与基数约束"><a href="#2-3-关系集与基数约束" class="headerlink" title="2.3 关系集与基数约束"></a>2.3 关系集与基数约束</h5><ul><li><strong>一对一（1:1）关系</strong>：一个实体集中的一个实体只与另一个实体集中的一个实体相关联。</li><li><strong>一对多（1:N）关系</strong>：一个实体集中的一个实体可以与另一个实体集中的多个实体相关联，但反之不成立。</li><li><strong>多对多（M:N）关系</strong>：两个实体集中的多个实体可以相互关联。</li></ul><h5 id="2-4-弱实体集与标识关系"><a href="#2-4-弱实体集与标识关系" class="headerlink" title="2.4 弱实体集与标识关系"></a>2.4 弱实体集与标识关系</h5><ul><li><strong>弱实体集（Weak Entity Set）</strong>：其存在依赖于另一个强实体集，通过标识关系进行标识。例如，“选课”实体集可能依赖于“学生”和“课程”实体集。</li><li><strong>标识关系（Identifying Relationship）</strong>：连接弱实体集与其标识强实体集的关系。</li></ul><h4 id="3-从E-R图到关系模式的转换"><a href="#3-从E-R图到关系模式的转换" class="headerlink" title="3. 从E-R图到关系模式的转换"></a>3. 从E-R图到关系模式的转换</h4><p>将E-R图转换为关系模式时，需遵循以下步骤：</p><ol><li><strong>实体集转换</strong>：每个强实体集转换为一个关系，属性成为关系的字段，主键作为关系主键。</li><li><strong>弱实体集转换</strong>：将弱实体集转换为关系，包含其标识实体集的主键作为外键，并结合自身的部分主键。</li><li><strong>关系集转换</strong>：<ul><li><strong>多对多关系</strong>：创建一个新的关系，包含两个参与实体集的主键作为外键。</li><li><strong>一对多或多对一关系</strong>：在“多”侧的关系中添加“一”侧的外键。</li><li><strong>一对一关系</strong>：可以选择任一侧添加对方的外键。</li></ul></li></ol><h5 id="3-1-处理多值属性"><a href="#3-1-处理多值属性" class="headerlink" title="3.1 处理多值属性"></a>3.1 处理多值属性</h5><p>多值属性通过创建新的关系来消除冗余。例如，“教师”的“电话号码”可以通过一个单独的关系 <code>教师电话（教师ID，电话）</code> 来表示。</p><h5 id="3-2-复合属性的展开"><a href="#3-2-复合属性的展开" class="headerlink" title="3.2 复合属性的展开"></a>3.2 复合属性的展开</h5><p>复合属性被拆解为更小的简单属性。例如，“地址”可以拆分为“街道”、“城市”、“州”、“邮编”。</p><h4 id="4-扩展的E-R特性"><a href="#4-扩展的E-R特性" class="headerlink" title="4. 扩展的E-R特性"></a>4. 扩展的E-R特性</h4><h5 id="4-1-泛化与特化（Generalization-Specialization）"><a href="#4-1-泛化与特化（Generalization-Specialization）" class="headerlink" title="4.1 泛化与特化（Generalization&#x2F;Specialization）"></a>4.1 泛化与特化（Generalization&#x2F;Specialization）</h5><ul><li><strong>泛化</strong>：将多个具体实体集抽象为一个通用的高层实体集。</li><li><strong>特化</strong>：将一个通用实体集细分为多个具体的低层实体集。</li></ul><h5 id="4-2-聚合（Aggregation）"><a href="#4-2-聚合（Aggregation）" class="headerlink" title="4.2 聚合（Aggregation）"></a>4.2 聚合（Aggregation）</h5><p>聚合用于表示关系集之间的关系，将一个或多个关系集视为一个整体来参与其他关系集。</p><h4 id="5-数据库设计中的常见问题与解决方案"><a href="#5-数据库设计中的常见问题与解决方案" class="headerlink" title="5. 数据库设计中的常见问题与解决方案"></a>5. 数据库设计中的常见问题与解决方案</h4><h5 id="5-1-冗余与更新异常"><a href="#5-1-冗余与更新异常" class="headerlink" title="5.1 冗余与更新异常"></a>5.1 冗余与更新异常</h5><ul><li><strong>冗余</strong>：信息重复存储，可能导致数据不一致。</li><li><strong>更新异常</strong>：如插入、删除、修改操作可能引发数据不一致。</li></ul><h5 id="5-2-规范化"><a href="#5-2-规范化" class="headerlink" title="5.2 规范化"></a>5.2 规范化</h5><p>通过规范化过程（如达到第三范式、BCNF等），消除冗余，避免更新异常。</p><h4 id="6-替代符号表示"><a href="#6-替代符号表示" class="headerlink" title="6. 替代符号表示"></a>6. 替代符号表示</h4><p>不同的E-R图符号如Chen符号、Crow’s Feet符号以及UML类图，有助于不同场景下的数据库设计和表示。</p><h3 id="6-4-实例分析"><a href="#6-4-实例分析" class="headerlink" title="6.4 实例分析"></a>6.4 实例分析</h3><h4 id="实例1：大学信息维护"><a href="#实例1：大学信息维护" class="headerlink" title="实例1：大学信息维护"></a>实例1：大学信息维护</h4><h5 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h5><p>一所大学需要维护以下信息：</p><ul><li>各个系，包括名称、系主任和地址。</li><li>各个班级，包括班级编号、名字和年级。</li><li>各个教师，包括教师编号、姓名和年龄。</li><li>一个系有多个班级，但班级只属于一个系。</li><li>一个系聘请某些教师，一个教师被一个系聘请。</li><li>教师最多是一个班的班主任；任何班级都必须有一个班主任。</li></ul><h5 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h5><ol><li><p><strong>实体集定义</strong></p><ul><li><strong>系（Department）</strong>：属性包括 <code>dept_name</code>（主键）、<code>head</code>、<code>address</code>。</li><li><strong>班级（Class）</strong>：属性包括 <code>class_id</code>（主键）、<code>name</code>、<code>grade</code>。</li><li><strong>教师（Teacher）</strong>：属性包括 <code>teacher_id</code>（主键）、<code>name</code>、<code>age</code>。</li></ul></li><li><p><strong>关系集定义</strong></p><ul><li><strong>隶属（Affiliation）</strong>：一对多关系，连接 <code>Department</code> 和 <code>Class</code>。一个系可有多个班级，但班级只能属于一个系。</li><li><strong>聘请（Employment）</strong>：一对多关系，连接 <code>Department</code> 和 <code>Teacher</code>。一个系聘请多个教师，一个教师被一个系聘请。</li><li><strong>班主任（Advisor）</strong>：一对一关系，连接 <code>Teacher</code> 和 <code>Class</code>。一个教师最多担任一个班主任，一个班级必须有一个班主任。</li></ul></li><li><p><strong>关系模式转换</strong></p><ul><li><strong>Department</strong>(<code>dept_name</code> [PK], <code>head</code>, <code>address</code>)</li><li><strong>Class</strong>(<code>class_id</code> [PK], <code>name</code>, <code>grade</code>, <code>dept_name</code> [FK])</li><li><strong>Teacher</strong>(<code>teacher_id</code> [PK], <code>name</code>, <code>age</code>, <code>dept_name</code> [FK])</li><li><strong>Advisor</strong>(<code>teacher_id</code> [PK, FK], <code>class_id</code> [FK])</li></ul></li><li><p><strong>SQL语句示例</strong><br>创建上述关系模式的SQL Server语句如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Department (</span><br><span class="line">    dept_name <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    head <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    address <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Teacher (</span><br><span class="line">    teacher_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    age <span class="type">INT</span>,</span><br><span class="line">    dept_name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (dept_name) <span class="keyword">REFERENCES</span> Department(dept_name)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Class (</span><br><span class="line">    class_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    grade <span class="type">INT</span>,</span><br><span class="line">    dept_name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (dept_name) <span class="keyword">REFERENCES</span> Department(dept_name)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Advisor (</span><br><span class="line">    teacher_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    class_id <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (teacher_id) <span class="keyword">REFERENCES</span> Teacher(teacher_id),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (class_id) <span class="keyword">REFERENCES</span> Class(class_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ol><h5 id="重点难点解析"><a href="#重点难点解析" class="headerlink" title="重点难点解析"></a>重点难点解析</h5><ul><li><strong>班主任关系的处理</strong>：采用一对一关系，需要在 <code>Advisor</code> 表中将 <code>teacher_id</code> 和 <code>class_id</code> 设置为外键，并分别引用 <code>Teacher</code> 和 <code>Class</code> 表。</li><li><strong>避免冗余</strong>：<code>Class</code> 和 <code>Teacher</code> 表中的 <code>dept_name</code> 作为外键避免了信息重复存储。</li></ul><h4 id="实例2：处理多值属性"><a href="#实例2：处理多值属性" class="headerlink" title="实例2：处理多值属性"></a>实例2：处理多值属性</h4><h5 id="需求描述-1"><a href="#需求描述-1" class="headerlink" title="需求描述"></a>需求描述</h5><p>记录教师的多个电话号码和多个子女姓名。</p><h5 id="设计过程-1"><a href="#设计过程-1" class="headerlink" title="设计过程"></a>设计过程</h5><p>由于多值属性会导致数据冗余，需通过创建新的关系来处理。</p><ol><li><p><strong>实体集定义</strong></p><ul><li><strong>教师（Teacher）</strong>：属性包括 <code>teacher_id</code>（主键）、<code>name</code>、<code>age</code>。</li></ul></li><li><p><strong>多值属性的处理</strong></p><ul><li><strong>教师电话（Teacher_Phone）</strong>：<code>teacher_id</code>（外键）、<code>phone_number</code>。</li><li><strong>教师子女（Teacher_Child）</strong>：<code>teacher_id</code>（外键）、<code>child_name</code>。</li></ul></li><li><p><strong>关系模式转换</strong></p><ul><li><strong>Teacher</strong>(<code>teacher_id</code> [PK], <code>name</code>, <code>age</code>)</li><li><strong>Teacher_Phone</strong>(<code>teacher_id</code> [FK], <code>phone_number</code>)</li><li><strong>Teacher_Child</strong>(<code>teacher_id</code> [FK], <code>child_name</code>)</li></ul></li><li><p><strong>SQL语句示例</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Teacher (</span><br><span class="line">    teacher_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    age <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Teacher_Phone (</span><br><span class="line">    teacher_id <span class="type">INT</span>,</span><br><span class="line">    phone_number <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (teacher_id) <span class="keyword">REFERENCES</span> Teacher(teacher_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Teacher_Child (</span><br><span class="line">    teacher_id <span class="type">INT</span>,</span><br><span class="line">    child_name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (teacher_id) <span class="keyword">REFERENCES</span> Teacher(teacher_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ol><h5 id="重点难点解析-1"><a href="#重点难点解析-1" class="headerlink" title="重点难点解析"></a>重点难点解析</h5><ul><li><strong>多值属性的分离</strong>：通过创建 <code>Teacher_Phone</code> 和 <code>Teacher_Child</code> 表，将教师的多个电话号码和子女姓名分别存储，避免冗余。</li><li><strong>保持关系的完整性</strong>：使用外键引用确保每个电话号码和子女姓名都关联到一个有效的教师。</li></ul><h3 id="6-5-图表与图示"><a href="#6-5-图表与图示" class="headerlink" title="6.5 图表与图示"></a>6.5 图表与图示</h3><h4 id="1-E-R图的图形表示"><a href="#1-E-R图的图形表示" class="headerlink" title="1. E-R图的图形表示"></a>1. E-R图的图形表示</h4><h5 id="实体集与属性"><a href="#实体集与属性" class="headerlink" title="实体集与属性"></a>实体集与属性</h5><ul><li><strong>实体集</strong>用矩形表示，内部列出其属性，主键属性下划线表示。</li><li><strong>复合属性</strong>用带有分支的椭圆表示，分支连接到子属性。</li><li><strong>多值属性</strong>用双椭圆表示。</li></ul><h5 id="关系集与基数约束"><a href="#关系集与基数约束" class="headerlink" title="关系集与基数约束"></a>关系集与基数约束</h5><ul><li><strong>关系集</strong>用菱形表示，连接参与的实体集。</li><li><strong>一对一</strong>关系在E-R图中通过双向箭头表示。</li><li><strong>一对多</strong>关系通过一端的单向箭头和多端的多向标记（如叉形脚）表示。</li><li><strong>多对多</strong>关系通过双向箭头连线表示。</li></ul><h5 id="弱实体集与标识关系"><a href="#弱实体集与标识关系" class="headerlink" title="弱实体集与标识关系"></a>弱实体集与标识关系</h5><ul><li><strong>弱实体集</strong>用双矩形表示，属性用双椭圆表示。</li><li><strong>标识关系集</strong>用双菱形表示，连接弱实体集与强实体集。</li></ul><h4 id="2-从E-R图到关系模式的转换示意"><a href="#2-从E-R图到关系模式的转换示意" class="headerlink" title="2. 从E-R图到关系模式的转换示意"></a>2. 从E-R图到关系模式的转换示意</h4><p><strong>原始E-R图示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Department]---&lt;Affiliation&gt;---[Class]</span><br><span class="line">[Department]---&lt;Employment&gt;---[Teacher]</span><br><span class="line">[Teacher]---&lt;Advisor&gt;---[Class]</span><br></pre></td></tr></table></figure><p><strong>转换后的关系模式</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. Department(dept_name [PK], head, address)</span><br><span class="line">2. Class(class_id [PK], name, grade, dept_name [FK])</span><br><span class="line">3. Teacher(teacher_id [PK], name, age, dept_name [FK])</span><br><span class="line">4. Advisor(teacher_id [PK, FK], class_id [FK])</span><br></pre></td></tr></table></figure><h3 id="6-6-总结"><a href="#6-6-总结" class="headerlink" title="6.6 总结"></a>6.6 总结</h3><p>数据库设计是一个系统性工程，需要从需求分析开始，经过概念设计、逻辑设计到物理设计的多个阶段。在E-R模型的帮助下，可以清晰地描述实体、属性和它们之间的关系。通过将E-R图转换为关系模式，并应用规范化理论，可以有效地消除冗余、避免更新异常，提升数据库的整体质量。</p><h3 id="6-7-建议"><a href="#6-7-建议" class="headerlink" title="6.7 建议"></a>6.7 建议</h3><ol><li><strong>深入理解E-R模型</strong>：通过实践绘制E-R图，掌握不同关系的表示方法。</li><li><strong>多练习E-R图到关系模式的转换</strong>：理解各种关系的映射规则，特别是处理多值属性和弱实体集时的细节。</li><li><strong>掌握规范化理论</strong>：学习不同范式的定义及其目的，应用规范化过程优化数据库设计。</li><li><strong>使用专业工具辅助设计</strong>：利用数据库设计工具（如ERwin、PowerDesigner）绘制E-R图，提高设计效率和准确性。</li></ol><hr><h2 id="第七章-标准化"><a href="#第七章-标准化" class="headerlink" title="第七章 标准化"></a>第七章 标准化</h2><h3 id="7-1-关系数据库设计中的问题"><a href="#7-1-关系数据库设计中的问题" class="headerlink" title="7.1 关系数据库设计中的问题"></a>7.1 关系数据库设计中的问题</h3><p><strong>重点难点：</strong></p><ul><li><strong>重点：</strong> 理解关系数据库设计中的数据冗余和异常问题。</li><li><strong>难点：</strong> 识别不同类型的异常（更新异常、插入异常、删除异常）及其产生原因。</li></ul><p><strong>内容摘要：</strong></p><ul><li><strong>数据冗余：</strong> 通过关系的自然连接（如<code>instructor</code>和<code>department</code>的自然连接<code>in_dep</code>），可能导致信息的重复存储。</li><li><strong>异常问题：</strong><ul><li><strong>更新异常：</strong> 部门经理变更时需要更新多个元组，容易出错。</li><li><strong>插入异常：</strong> 新部门无员工时，无法插入该部门的信息。</li><li><strong>删除异常：</strong> 删除部门所有员工后，失去部门经理的信息。</li></ul></li></ul><hr><h3 id="7-2-不良数据依赖与关系分解"><a href="#7-2-不良数据依赖与关系分解" class="headerlink" title="7.2 不良数据依赖与关系分解"></a>7.2 不良数据依赖与关系分解</h3><p><strong>重点难点：</strong></p><ul><li><strong>重点：</strong> 理解函数依赖的概念及其在关系数据库设计中的应用。</li><li><strong>难点：</strong> 辨别“好”与“不好”的函数依赖，以及进行关系分解以消除不良依赖。</li></ul><p><strong>内容摘要：</strong></p><ul><li><strong>函数依赖（Functional Dependency, FD）：</strong> 若属性集α决定属性集β，即<code>α → β</code>，则在任何合法实例中，若两个元组在α上相同，则在β上也相同。</li><li><strong>不良函数依赖：</strong> 例如<code>branch → manager</code>，当<code>branch</code>不是超级键时，会导致数据重复和异常。</li><li><strong>关系分解：</strong> 将“坏”关系分解为多个“好”关系以消除不良依赖。需要确保分解是无损连接（lossless-join）并尽可能保持依赖性（dependency preserving）。</li></ul><p><strong>实例分析：</strong></p><ul><li><p><strong>关系 <code>worker(name, branch, manager)</code> 存在的函数依赖：</strong></p><ul><li><code>name → branch</code></li><li><code>branch → manager</code></li><li><code>name → manager</code></li></ul></li><li><p><strong>问题：</strong> <code>branch → manager</code> 不是良好的依赖，因为<code>branch</code>不是超级键，导致信息冗余。</p></li><li><p><strong>分解方案：</strong></p><ul><li><code>worker1(name, branch)</code></li><li><code>branch(branch, manager)</code></li></ul><p>这种分解消除了冗余，避免了更新、插入和删除异常。</p></li></ul><hr><h3 id="7-3-正规化与范式"><a href="#7-3-正规化与范式" class="headerlink" title="7.3 正规化与范式"></a>7.3 正规化与范式</h3><p><strong>重点难点：</strong></p><ul><li><strong>重点：</strong> 理解不同范式（第一范式1NF，第二范式2NF，第三范式3NF，BCNF，第四范式4NF）的定义及其重要性。</li><li><strong>难点：</strong> 识别关系是否满足特定范式，以及进行规范化分解。</li></ul><p><strong>内容摘要：</strong></p><ul><li><strong>第一范式（1NF）：</strong> 所有属性值必须是原子性的，不能再分。</li><li><strong>第二范式（2NF）：</strong> 满足1NF且每个非主属性完全依赖于候选键，消除部分依赖。</li><li><strong>第三范式（3NF）：</strong> 满足2NF且没有传递依赖，消除传递依赖。</li><li><strong>BCNF（Boyce-Codd Normal Form）：</strong> 满足3NF且每个决定因素都是超级键。</li><li><strong>第四范式（4NF）：</strong> 满足BCNF且没有多值依赖。</li></ul><p><strong>实例分析：</strong></p><ul><li><p><strong>关系 <code>student(course_id, title, dept_name, credits, sec_id, semester, year, building, room_number, capacity, time_slot_id)</code> 存在的函数依赖：</strong></p><ul><li><code>course_id → title, dept_name, credits</code></li><li><code>building, room_number → capacity</code></li><li><code>course_id, sec_id, semester, year → building, room_number, time_slot_id</code></li></ul></li><li><p><strong>分解至BCNF：</strong></p><ul><li><code>course(course_id, title, dept_name, credits)</code></li><li><code>classroom(building, room_number, capacity)</code></li><li><code>section(course_id, sec_id, semester, year, building, room_number, time_slot_id)</code></li></ul><p>各个分解后的关系满足BCNF，消除了函数依赖导致的问题。</p></li></ul><hr><h3 id="7-4-规范化算法与依赖闭包"><a href="#7-4-规范化算法与依赖闭包" class="headerlink" title="7.4 规范化算法与依赖闭包"></a>7.4 规范化算法与依赖闭包</h3><p><strong>重点难点：</strong></p><ul><li><strong>重点：</strong> 掌握属性闭包（Attribute Closure）及其在确定函数依赖和候选键中的应用。</li><li><strong>难点：</strong> 计算函数依赖的闭包，理解规范化过程中的依赖保留和无损连接。</li></ul><p><strong>内容摘要：</strong></p><ul><li><strong>属性闭包（α+）：</strong> 在给定一组函数依赖F的情况下，属性集α的闭包是由α决定的所有属性的集合。</li><li><strong>候选键：</strong> 最小的超级键，能够唯一标识关系中的元组。</li><li><strong>规范化算法：</strong><ul><li><strong>算法步骤：</strong><ol><li>确定所有函数依赖的闭包。</li><li>分解关系，确保每个分解后的关系满足目标范式（如3NF、BCNF）。</li><li>确保分解是无损连接，并尽可能保留函数依赖。</li></ol></li></ul></li></ul><p><strong>实例分析：</strong></p><ul><li><p><strong>计算属性闭包：</strong></p><ul><li><p>关系 <code>R(A, B, C, G, H, I)</code></p></li><li><p>函数依赖集 <code>F = &#123;A → B, A → C, CG → H, CG → I, B → H&#125;</code></p></li><li><p>计算 <code>(AG)+</code>：</p><ol><li>初始：<code>AG</code></li><li><code>A → B</code> 和 <code>A → C</code>，得到 <code>AGBC</code></li><li><code>CG → H</code> 和 <code>CG → I</code>，得到 <code>AGBCHI</code></li></ol><ul><li><strong>结论：</strong> <code>(AG)+</code> 包含所有属性，因此<code>AG</code>是超级键。</li></ul></li></ul></li></ul><hr><h3 id="7-5-依赖与范式的深入理解"><a href="#7-5-依赖与范式的深入理解" class="headerlink" title="7.5 依赖与范式的深入理解"></a>7.5 依赖与范式的深入理解</h3><p><strong>重点难点：</strong></p><ul><li><strong>重点：</strong> 了解函数依赖的规范形式（如规范覆盖Canonical Cover），以及在规范化过程中的应用。</li><li><strong>难点：</strong> 理解并应用规范覆盖的简化规则，进行关系的规范化分解。</li></ul><p><strong>内容摘要：</strong></p><ul><li><p><strong>规范覆盖（Canonical Cover）：</strong> 函数依赖集的简化形式，消除冗余和多余的属性。</p></li><li><p><strong>规范覆盖的计算步骤：</strong></p><ol><li>分解右侧多个属性的函数依赖为单属性依赖。</li><li>消除左侧多余的属性。</li><li>合并具有相同左侧的函数依赖。</li></ol></li><li><p><strong>依赖保留（Dependency Preservation）：</strong> 分解后的关系能够保留原来的所有函数依赖，便于在不进行连接操作的情况下进行依赖的验证。</p></li></ul><p><strong>实例分析：</strong></p><ul><li><p><strong>计算规范覆盖：</strong></p><ul><li><p>关系 <code>R(A, B, C)</code></p></li><li><p>函数依赖集 <code>F = &#123;A → BC, B → C, A → B, AB → C&#125;</code></p></li><li><p>步骤：</p><ol><li>合并相同左侧的依赖：<code>A → BC</code> 和 <code>A → B</code> 简化为 <code>A → BC</code></li><li>删除<code>AB → C</code>，因为已由<code>A → B</code>和<code>B → C</code>通过传递性推导出。</li></ol><ul><li><strong>规范覆盖：</strong> <code>Fc = &#123;A → B, B → C&#125;</code></li></ul></li></ul></li></ul><hr><h3 id="7-6-无损连接与依赖保留的算法"><a href="#7-6-无损连接与依赖保留的算法" class="headerlink" title="7.6 无损连接与依赖保留的算法"></a>7.6 无损连接与依赖保留的算法</h3><p><strong>重点难点：</strong></p><ul><li><strong>重点：</strong> 掌握无损连接分解的判定条件及依赖是否保留的算法。</li><li><strong>难点：</strong> 理解并应用算法判断分解是否无损连接和依赖保留。</li></ul><p><strong>内容摘要：</strong></p><ul><li><p><strong>无损连接分解（Lossless-Join Decomposition）：</strong> 分解后通过自然连接能够恢复原始关系，不丢失信息。</p><ul><li><strong>判定条件：</strong> 当分解的关系<code>R1</code>和<code>R2</code>的交集<code>R1 ∩ R2</code>是<code>R1</code>或<code>R2</code>的超级键时，分解是无损的。</li></ul></li><li><p><strong>依赖保留判定：</strong></p><ul><li>通过检查分解后的所有关系的函数依赖集的并集是否能够推导出原关系的所有函数依赖。</li></ul></li></ul><p><strong>实例分析：</strong></p><ul><li><p><strong>无损连接分解：</strong></p><ul><li>关系 <code>R(A, B, C)</code></li><li>分解为 <code>R1(A, B)</code> 和 <code>R2(B, C)</code></li><li>交集<code>R1 ∩ R2 = &#123;B&#125;</code>，且<code>B → C</code>，因此分解无损。</li></ul></li><li><p><strong>依赖保留判定：</strong></p><ul><li>分解后，<code>R1</code>包含<code>A → B</code>，<code>R2</code>包含<code>B → C</code>，两者的并集等于规范覆盖<code>Fc = &#123;A → B, B → C&#125;</code>，因此依赖保留。</li></ul></li></ul><hr><h3 id="7-7-多值依赖与第四范式（4NF）"><a href="#7-7-多值依赖与第四范式（4NF）" class="headerlink" title="7.7 多值依赖与第四范式（4NF）"></a>7.7 多值依赖与第四范式（4NF）</h3><p><strong>重点难点：</strong></p><ul><li><strong>重点：</strong> 理解多值依赖（Multivalued Dependency）的概念及其在规范化中的作用。</li><li><strong>难点：</strong> 识别多值依赖并进行符合第四范式的分解。</li></ul><p><strong>内容摘要：</strong></p><ul><li><strong>多值依赖（Multivalued Dependency, MVD）：</strong> 若属性集α决定属性集β，且β与其他非相关属性独立，记作<code>α →→ β</code>。</li><li><strong>第四范式（4NF）：</strong> 满足BCNF，且不存在任何非平凡的多值依赖，即每个多值依赖的决定因素都是超级键。</li><li><strong>多值依赖的分解：</strong> 将关系分解为多个关系，每个关系消除一个多值依赖，确保分解后的关系在4NF。</li></ul><p><strong>实例分析：</strong></p><ul><li><p><strong>关系 <code>inst_info(ID, child_name, phone_number)</code> 存在的多值依赖：</strong></p><ul><li><code>ID →→ child_name</code></li><li><code>ID →→ phone_number</code></li></ul></li><li><p><strong>分解为：</strong></p><ul><li><code>inst_child(ID, child_name)</code></li><li><code>inst_phone(ID, phone_number)</code></li></ul><p>这样分解后的关系均满足4NF，消除了多值依赖引起的冗余。</p></li></ul><hr><h3 id="7-8-规范化注意事项与高级范式"><a href="#7-8-规范化注意事项与高级范式" class="headerlink" title="7.8 规范化注意事项与高级范式"></a>7.8 规范化注意事项与高级范式</h3><p><strong>重点难点：</strong></p><ul><li><strong>重点：</strong> 理解更高级范式（如第五范式PJNF）及其在特定情况下的应用。</li><li><strong>难点：</strong> 处理复杂的多值依赖和连接依赖，理解规范化与性能优化之间的权衡。</li></ul><p><strong>内容摘要：</strong></p><ul><li><strong>第五范式（PJNF）：</strong> 在多值依赖基础上，进一步消除连接依赖，确保关系满足所有可能的投影-连接条件。</li><li><strong>规范化的实际应用：</strong><ul><li>在实际设计中，常常在BCNF和3NF之间权衡，考虑依赖保留和性能。</li><li>对于复杂依赖，通常采用4NF或更高级范式以消除冗余。</li></ul></li></ul><p><strong>实例分析：</strong></p><ul><li><strong>关系 <code>dept_advisor(s_ID, i_ID, dept_name)</code></strong><ul><li>函数依赖集 <code>F = &#123;i_ID → dept_name, s_ID, dept_name → i_ID&#125;</code></li><li>分解后无法同时满足BCNF和依赖保留，需在应用中权衡选择。</li></ul></li></ul><hr><h3 id="7-9-综合实例与规范化总结"><a href="#7-9-综合实例与规范化总结" class="headerlink" title="7.9 综合实例与规范化总结"></a>7.9 综合实例与规范化总结</h3><p><strong>重点难点：</strong></p><ul><li><strong>重点：</strong> 综合运用所学知识进行实际关系的规范化。</li><li><strong>难点：</strong> 在实际应用中识别和解决复杂的函数依赖和多值依赖问题，确保分解的正确性（无损和依赖保留）。</li></ul><p><strong>内容摘要：</strong></p><ul><li><p><strong>规范化的目标：</strong></p><ul><li><strong>无损连接（Lossless-Join）：</strong> 确保分解后可以通过连接恢复原始关系。</li><li><strong>依赖保留（Dependency Preservation）：</strong> 确保所有原始函数依赖可以在分解后的关系中得到验证。</li></ul></li><li><p><strong>规范化过程：</strong></p><ol><li>确定所有函数依赖及多值依赖。</li><li>按照范式规则进行分解。</li><li>验证分解是否满足无损连接和依赖保留。</li></ol></li></ul><p><strong>实例分析：</strong></p><ul><li><p><strong>关系 <code>cust_banker_branch(customer_id, employee_id, branch_name, type)</code></strong></p><ul><li>规范覆盖 <code>Fc = &#123;customer_id, employee_id → type, employee_id → branch_name, customer_id, branch_name → employee_id&#125;</code></li><li>分解为：<ul><li><code>(customer_id, employee_id, type)</code></li><li><code>(employee_id, branch_name)</code></li><li><code>(customer_id, branch_name, employee_id)</code></li></ul></li><li>删除子集关系，最终得到：<ul><li><code>(customer_id, employee_id, type)</code></li><li><code>(customer_id, branch_name, employee_id)</code></li></ul></li></ul><p>这样的分解满足3NF，保持了无损连接和依赖保留。</p></li></ul><hr><h3 id="7-10-多值依赖与进一步规范化（7-117-7-140）"><a href="#7-10-多值依赖与进一步规范化（7-117-7-140）" class="headerlink" title="7.10 多值依赖与进一步规范化（7.117 - 7.140）"></a>7.10 多值依赖与进一步规范化（7.117 - 7.140）</h3><p><strong>重点难点：</strong></p><ul><li><strong>重点：</strong> 深入理解多值依赖在规范化过程中的应用，特别是第四范式（4NF）。</li><li><strong>难点：</strong> 处理属性间复杂的多值依赖，确保分解后的关系结构合理且无冗余。</li></ul><p><strong>内容摘要：</strong></p><ul><li><p><strong>合并与分解策略：</strong></p><ul><li>对包含多值依赖的关系进行分解，确保每个分解后的关系仅有单一或无多值依赖。</li><li>使用算法识别非平凡多值依赖并进行适当的分解。</li></ul></li><li><p><strong>第四范式（4NF）详细定义：</strong></p><ul><li>若<code>R</code>满足BCNF，并且对于每个<code>R</code>中的多值依赖<code>α →→ β</code>，<code>α</code>是<code>R</code>的超级键，则<code>R</code>在4NF中。</li></ul></li></ul><p><strong>实例分析：</strong></p><ul><li><p><strong>关系 <code>R(A, B, C, G, H, I)</code> 存在的多值依赖：</strong></p><ul><li><code>A →→ B</code></li><li><code>B →→ HI</code></li><li><code>CG →→ H</code></li></ul></li><li><p><strong>分解步骤：</strong></p><ol><li>分解为<code>R1(A, B)</code> 和 <code>R2(A, C, G, H, I)</code></li><li><code>R2</code>仍不满足4NF，继续分解为<code>R3(C, G, H)</code> 和 <code>R4(A, C, G, I)</code></li><li><code>R4</code>再次分解为<code>R5(A, I)</code> 和 <code>R6(A, C, G)</code></li></ol><p>最终分解后的关系均满足4NF，消除了所有非平凡多值依赖。</p></li></ul><hr><h3 id="7-11-方法论与最佳实践"><a href="#7-11-方法论与最佳实践" class="headerlink" title="7.11 方法论与最佳实践"></a>7.11 方法论与最佳实践</h3><p><strong>重点难点：</strong></p><ul><li><strong>重点：</strong> 了解如何在实际数据库设计中应用规范化原则与方法。</li><li><strong>难点：</strong> 在复杂的实际场景中平衡规范化与性能需求，避免信息丢失和确保数据完整性。</li></ul><p><strong>内容摘要：</strong></p><ul><li><p><strong>规范化设计的目标：</strong> </p><ul><li>合理消除冗余，避免数据异常。</li><li>保持分解关系的可恢复性和依赖保留性。</li></ul></li><li><p><strong>最佳实践：</strong></p><ul><li>在设计早期进行规范化，确保关系结构合理。</li><li>对于性能敏感的应用场景，可以适当进行非规范化处理，如创建物化视图（Materialized Views）以提升查询效率。</li><li>避免在数据库设计中使用交叉表（Crosstab）的方式，因其不利于数据的灵活查询和维护。</li></ul></li></ul><p><strong>实例分析：</strong></p><ul><li><strong>关系<code>inst_child(ID, child_name)</code> 和 <code>inst_phone(ID, phone_number)</code></strong><ul><li>通过分解消除重复和多值依赖，确保每个关系满足4NF。</li><li>保持数据的独立性和完整性，避免冗余信息。</li></ul></li></ul><hr><h3 id="7-12-总结与复习要点"><a href="#7-12-总结与复习要点" class="headerlink" title="7.12 总结与复习要点"></a>7.12 总结与复习要点</h3><ul><li><strong>函数依赖和多值依赖：</strong> 理解其定义和在规范化中的作用。</li><li><strong>范式的层次与要求：</strong> 按照1NF到4NF逐步规范化，理解每个范式消除的冗余类型。</li><li><strong>关系分解原则：</strong> 确保分解是无损连接且依赖保留。</li><li><strong>算法应用：</strong> 熟练运用属性闭包、规范覆盖等算法进行关系规范化。</li><li><strong>实际应用：</strong> 在实际设计中合理应用规范化原则，平衡规范化与性能需求。</li></ul><p><strong>学习建议：</strong></p><ul><li><strong>多做练习：</strong> 通过大量实例练习，巩固函数依赖和范式的理解。</li><li><strong>理解而非记忆：</strong> 深入理解规范化的原理，避免死记硬背。</li><li><strong>实际应用：</strong> 尝试在实际数据库设计项目中应用所学知识，提升实践能力。</li></ul><hr><h3 id="7-13-附录：SQL-Server环境下的示例SQL语句"><a href="#7-13-附录：SQL-Server环境下的示例SQL语句" class="headerlink" title="7.13 附录：SQL Server环境下的示例SQL语句"></a>7.13 附录：SQL Server环境下的示例SQL语句</h3><p><strong>示例1：创建和分解<code>worker</code>关系</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建原始worker表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> worker (</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    branch <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    manager <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入示例数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> worker <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;Jones&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;Frank&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;Smith&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;David&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;Curry&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;Frank&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;Larry&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;David&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;Julia&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;Frank&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分解为worker1和branch表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> worker1 (</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    branch <span class="type">CHAR</span>(<span class="number">1</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> branch (</span><br><span class="line">    branch <span class="type">CHAR</span>(<span class="number">1</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    manager <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入分解后的数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> worker1 (name, branch)</span><br><span class="line"><span class="keyword">SELECT</span> name, branch <span class="keyword">FROM</span> worker;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> branch (branch, manager)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> branch, manager <span class="keyword">FROM</span> worker;</span><br></pre></td></tr></table></figure><p><strong>示例2：创建触发器以维护<code>student_sum</code>表</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建学生表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">    stu_id <span class="type">INT</span> <span class="keyword">IDENTITY</span>(<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    stu_name <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    stu_gender <span class="type">CHAR</span>(<span class="number">2</span>),</span><br><span class="line">    stu_age <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建存储学生人数的student_sum表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student_sum (</span><br><span class="line">    stuCount <span class="type">INT</span> <span class="keyword">DEFAULT</span>(<span class="number">0</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建插入触发器</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trig_insert</span><br><span class="line"><span class="keyword">ON</span> student</span><br><span class="line">AFTER <span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> <span class="variable">@stuNumber</span> <span class="type">INT</span>;</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="variable">@stuNumber</span> <span class="operator">=</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> student;</span><br><span class="line">    IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student_sum)</span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> student_sum <span class="keyword">VALUES</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">UPDATE</span> student_sum <span class="keyword">SET</span> stuCount <span class="operator">=</span> <span class="variable">@stuNumber</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建删除触发器</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trig_delete</span><br><span class="line"><span class="keyword">ON</span> student</span><br><span class="line">AFTER <span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> stu_id <span class="keyword">AS</span> 已删除的学生编号, stu_name, stu_gender, stu_age</span><br><span class="line">    <span class="keyword">FROM</span> deleted;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建更新触发器</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trig_update</span><br><span class="line"><span class="keyword">ON</span> student</span><br><span class="line">AFTER <span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> <span class="variable">@stuCount</span> <span class="type">INT</span>;</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="variable">@stuCount</span> <span class="operator">=</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> student;</span><br><span class="line">    <span class="keyword">UPDATE</span> student_sum <span class="keyword">SET</span> stuCount <span class="operator">=</span> <span class="variable">@stuCount</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">SELECT</span> stu_id <span class="keyword">AS</span> 更新前学生编号, stu_name <span class="keyword">AS</span> 更新前学生姓名 <span class="keyword">FROM</span> deleted;</span><br><span class="line">    <span class="keyword">SELECT</span> stu_id <span class="keyword">AS</span> 更新后学生编号, stu_name <span class="keyword">AS</span> 更新后学生姓名 <span class="keyword">FROM</span> inserted;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li>确保在SQL Server中执行上述SQL语句时，具有相应的权限。</li><li>触发器中的<code>deleted</code>和<code>inserted</code>表是SQL Server中特殊的临时表，用于存储被删除和插入的元组。</li></ul><hr><p>通过以上总结，学生可以系统地掌握数据库规范化的理论与实践，理解不同范式的意义及其应用，熟悉在SQL Server环境下实现规范化设计的具体步骤与SQL语句。</p><hr><h2 id="第八章-多值依赖（MVDS）"><a href="#第八章-多值依赖（MVDS）" class="headerlink" title="第八章 多值依赖（MVDS）"></a>第八章 多值依赖（MVDS）</h2><h3 id="8-1-重点"><a href="#8-1-重点" class="headerlink" title="8.1 重点"></a>8.1 重点</h3><ol><li><p><strong>多值依赖（MVD）的定义与理解：</strong></p><ul><li>理解多值依赖的概念，即在关系模式中，如果属性集合X多值依赖于Y，意味着对于每个X的值，Y的值是相互独立的。</li></ul></li><li><p><strong>第四范式（4NF）的定义及其与BCNF的关系：</strong></p><ul><li>熟悉4NF的定义：如果一个关系模式中的每一个非平凡的多值依赖都由超级键决定，则该关系模式属于4NF。</li><li>理解4NF比BCNF更严格，4NF不仅处理函数依赖，还处理多值依赖。</li></ul></li><li><p><strong>多值依赖的规约与分解：</strong></p><ul><li>学会根据MVD进行关系模式的分解，以消除数据冗余。</li><li>了解4NF分解的方法，确保分解后的关系模式依然保持无损连接。</li></ul></li></ol><h3 id="8-2-难点"><a href="#8-2-难点" class="headerlink" title="8.2 难点"></a>8.2 难点</h3><ol><li><p><strong>多值依赖的识别与应用：</strong></p><ul><li>在复杂的关系模式中识别哪些属性之间存在多值依赖，区分多值依赖和函数依赖。</li></ul></li><li><p><strong>4NF与BCNF的区别与联系：</strong></p><ul><li>理解虽然每一个函数依赖都是多值依赖，但反之则不然，导致4NF包含更多的约束条件。</li></ul></li><li><p><strong>复杂分解的正确性验证：</strong></p><ul><li>确保通过多值依赖分解后的关系模式依然满足原有的数据依赖和保持无损连接。</li></ul></li></ol><h3 id="8-3-实例分析"><a href="#8-3-实例分析" class="headerlink" title="8.3 实例分析"></a>8.3 实例分析</h3><h4 id="实例1：多值依赖的定义与应用"><a href="#实例1：多值依赖的定义与应用" class="headerlink" title="实例1：多值依赖的定义与应用"></a>实例1：多值依赖的定义与应用</h4><p><strong>关系模式：Drinkers(name, addr, phones, beersLiked)</strong></p><p><strong>多值依赖：</strong></p><ul><li><code>name →→ phones</code></li><li><code>name →→ beersLiked</code></li></ul><p><strong>解释：</strong></p><ul><li>每个饮酒者的电话号码（phones）与他们喜欢的啤酒（beersLiked）是相互独立的，即每个电话号码可以与每种喜欢的啤酒组合出现，导致数据的重复。</li></ul><p><strong>SQL Server 中的示例操作：</strong></p><p>假设有以下数据：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Drinkers (name, addr, phones, beersLiked) <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="string">&#x27;sue&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;p1&#x27;</span>, <span class="string">&#x27;b1&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;sue&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;p2&#x27;</span>, <span class="string">&#x27;b2&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;sue&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;p2&#x27;</span>, <span class="string">&#x27;b1&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;sue&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;p1&#x27;</span>, <span class="string">&#x27;b2&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>分解为4NF：</strong></p><ol><li><p>分解出电话信息：</p> <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Drinkers_Phones (</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    addr <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    phones <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (name, phones)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Drinkers_Phones (name, addr, phones)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> name, addr, phones <span class="keyword">FROM</span> Drinkers;</span><br></pre></td></tr></table></figure></li><li><p>分解出喜欢的啤酒信息：</p> <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Drinkers_BeersLiked (</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    beersLiked <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (name, beersLiked)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Drinkers_BeersLiked (name, beersLiked)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> name, beersLiked <span class="keyword">FROM</span> Drinkers;</span><br></pre></td></tr></table></figure></li></ol><p>这样可以消除原表中的多值依赖，避免数据冗余。</p><h4 id="实例2：4NF-的分解"><a href="#实例2：4NF-的分解" class="headerlink" title="实例2：4NF 的分解"></a>实例2：4NF 的分解</h4><p><strong>原关系模式：Drinkers(name, addr, phones, beersLiked, manf)</strong></p><p><strong>多值依赖：</strong></p><ul><li><code>name →→ (areaCode, phone)</code></li><li><code>name →→ (beersLiked, manf)</code></li></ul><p><strong>分解步骤：</strong></p><ol><li><p>创建 Drinkers_AreaPhone 表：</p> <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Drinkers_AreaPhone (</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    areaCode <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    phone <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (name, areaCode, phone)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>创建 Drinkers_BeersManf 表：</p> <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Drinkers_BeersManf (</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    beersLiked <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    manf <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (name, beersLiked, manf)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>移除原表中的多值依赖：</p> <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Drinkers_Info (</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    addr <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ol><p><strong>确保分解无损连接：</strong></p><p>通过连接 Drinkers_AreaPhone 和 Drinkers_BeersManf 可以恢复原始数据。</p><hr><h3 id="8-4-图表与图示"><a href="#8-4-图表与图示" class="headerlink" title="8.4 图表与图示"></a>8.4 图表与图示</h3><h4 id="1-多值依赖的图示描述"><a href="#1-多值依赖的图示描述" class="headerlink" title="1. 多值依赖的图示描述"></a>1. 多值依赖的图示描述</h4><ul><li><strong>图1：MVD X →→ Y 的图示</strong><ul><li>关系模式 R 包含属性集 X、Y 和其他属性。</li><li>如果两个元组在 X 上相同，则可以交换 Y 属性的值，生成新的元组仍在 R 中。</li></ul></li></ul><h4 id="2-4NF-分解的流程图"><a href="#2-4NF-分解的流程图" class="headerlink" title="2. 4NF 分解的流程图"></a>2. 4NF 分解的流程图</h4><ul><li><strong>图2：4NF 分解流程</strong><ul><li>检查关系模式中的每一个多值依赖。</li><li>如果某个多值依赖不满足4NF，则将关系模式分解为两个子模式，一个包含多值依赖的属性，另一个包含剩余属性。</li><li>确保分解后的子模式满足无损连接。</li></ul></li></ul><hr><hr><h2 id="第九章-应用程序开发"><a href="#第九章-应用程序开发" class="headerlink" title="第九章 应用程序开发"></a>第九章 应用程序开发</h2><h3 id="9-1-重点"><a href="#9-1-重点" class="headerlink" title="9.1 重点"></a>9.1 重点</h3><ol><li><p><strong>应用程序架构与Web基础：</strong></p><ul><li>理解现代应用程序的多层架构（前端、中间层、后端）及其各自的职责。</li><li>掌握Web技术的基础，如HTML、JavaScript、Servlets、JSP等。</li></ul></li><li><p><strong>快速应用程序开发（RAD）工具与框架：</strong></p><ul><li>熟悉常用的RAD工具和Web框架，如Java Server Faces (JSF)、Ruby on Rails、ASP.NET等，提高开发效率。</li></ul></li><li><p><strong>应用性能优化：</strong></p><ul><li>了解缓存技术（如连接池、查询缓存、HTML缓存）以提高Web应用的响应速度和处理能力。</li></ul></li><li><p><strong>应用安全性：</strong></p><ul><li>深入理解Web应用常见的安全问题，如SQL注入、跨站脚本攻击（XSS）、跨站请求伪造（CSRF）等，并掌握相应的防护措施。</li><li>掌握加密技术及其在数据库中的应用，确保数据传输和存储的安全。</li></ul></li></ol><h3 id="9-2-难点"><a href="#9-2-难点" class="headerlink" title="9.2 难点"></a>9.2 难点</h3><ol><li><p><strong>会话管理与状态保持：</strong></p><ul><li>理解无状态的HTTP协议如何通过会话（Session）管理用户状态，掌握Cookies、Session等技术。</li></ul></li><li><p><strong>触发器的复杂应用：</strong></p><ul><li>设计复杂的触发器以维护数据一致性或实现自动化操作，同时避免触发器带来的性能问题和意外副作用。</li></ul></li><li><p><strong>跨域认证与单点登录（SSO）：</strong></p><ul><li>理解如何实现跨域的安全认证机制，如SAML、OpenID，以及在分布式系统中的认证流程。</li></ul></li><li><p><strong>加密技术的结合与应用：</strong></p><ul><li>了解对称加密与非对称加密的结合使用（混合加密），以及在实际数据库中的具体应用场景和配置方法。</li></ul></li></ol><h3 id="9-3-实例分析"><a href="#9-3-实例分析" class="headerlink" title="9.3 实例分析"></a>9.3 实例分析</h3><p><strong>例1：创建和使用触发器</strong></p><p><strong>任务：</strong> 为<code>student</code>表创建一个AFTER UPDATE触发器，更新<code>student_sum</code>表中的学生总数，并记录更新前后的学生信息。</p><p><strong>示例SQL代码：</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建student表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">    stu_id <span class="type">INT</span> <span class="keyword">IDENTITY</span>(<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    stu_name <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    stu_gender <span class="type">CHAR</span>(<span class="number">2</span>),</span><br><span class="line">    stu_age <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建student_sum表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student_sum (</span><br><span class="line">    stuCount <span class="type">INT</span> <span class="keyword">DEFAULT</span>(<span class="number">0</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建AFTER UPDATE触发器</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trig_update</span><br><span class="line"><span class="keyword">ON</span> student</span><br><span class="line">AFTER <span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> <span class="variable">@stuCount</span> <span class="type">INT</span>;</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="variable">@stuCount</span> <span class="operator">=</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> student;</span><br><span class="line">    <span class="keyword">UPDATE</span> student_sum <span class="keyword">SET</span> stuCount <span class="operator">=</span> <span class="variable">@stuCount</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 显示更新前后的学生信息</span></span><br><span class="line">    <span class="keyword">SELECT</span> stu_id <span class="keyword">AS</span> 更新前学生编号, stu_name <span class="keyword">AS</span> 更新前学生姓名 <span class="keyword">FROM</span> deleted;</span><br><span class="line">    <span class="keyword">SELECT</span> stu_id <span class="keyword">AS</span> 更新后学生编号, stu_name <span class="keyword">AS</span> 更新后学生姓名 <span class="keyword">FROM</span> inserted;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>当<code>student</code>表中的记录被更新时，<code>trig_update</code>触发器自动执行。</li><li>触发器更新<code>student_sum</code>表中的<code>stuCount</code>为当前学生总数。</li><li>使用<code>deleted</code>表记录更新前的学生信息，使用<code>inserted</code>表记录更新后的学生信息。</li></ul><hr><p><strong>例2：防范SQL注入攻击</strong></p><p><strong>任务：</strong> 通过编写Servlet，确保用户输入通过预编译语句处理，防止SQL注入。</p><p><strong>示例Java Servlet代码片段：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设已经建立数据库连接conn</span></span><br><span class="line"><span class="type">String</span> <span class="variable">persontype</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;persontype&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(persontype.equals(<span class="string">&quot;student&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT ID, name, dept_name FROM student WHERE name = ?&quot;</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">    pstmt.setString(<span class="number">1</span>, name);</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.executeQuery();</span><br><span class="line"></span><br><span class="line">    out.println(<span class="string">&quot;&lt;table BORDER COLS=3&gt;&quot;</span>);</span><br><span class="line">    out.println(<span class="string">&quot;&lt;tr&gt; &lt;td&gt;ID&lt;/td&gt; &lt;td&gt;Name&lt;/td&gt; &lt;td&gt;Department&lt;/td&gt; &lt;/tr&gt;&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ID</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;ID&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">studentName</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">deptName</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;dept_name&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;tr&gt; &lt;td&gt;&quot;</span> + ID + <span class="string">&quot;&lt;/td&gt;&lt;td&gt;&quot;</span> + studentName + <span class="string">&quot;&lt;/td&gt;&lt;td&gt;&quot;</span> + deptName + <span class="string">&quot;&lt;/td&gt;&lt;/tr&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    out.println(<span class="string">&quot;&lt;/table&gt;&quot;</span>);</span><br><span class="line">    rs.close();</span><br><span class="line">    pstmt.close();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 类似处理instructor类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>使用<code>PreparedStatement</code>预编译SQL语句，确保用户输入的<code>name</code>参数被安全处理，防止SQL注入。</li><li>动态生成HTML表格显示查询结果。</li></ul><hr><p><strong>例3：使用JSP实现动态网页</strong></p><p><strong>任务：</strong> 编写一个JSP页面，根据用户输入的名字显示问候语。</p><p><strong>示例JSP代码：</strong></p><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Hello&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;% </span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123; </span><br><span class="line">    %&gt;</span><br><span class="line">            Hello World</span><br><span class="line">    &lt;% </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    %&gt;</span><br><span class="line">            Hello, &lt;%= name %&gt;</span><br><span class="line">    &lt;% </span><br><span class="line">        &#125; </span><br><span class="line">    %&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>根据用户通过表单提交的<code>name</code>参数，动态显示不同的问候语。</li><li>如果用户未输入名字，则显示“Hello World”。</li></ul><h3 id="9-4-图表与图示"><a href="#9-4-图表与图示" class="headerlink" title="9.4 图表与图示"></a>9.4 图表与图示</h3><h4 id="1-Web-应用程序三层架构图示描述"><a href="#1-Web-应用程序三层架构图示描述" class="headerlink" title="1. Web 应用程序三层架构图示描述"></a>1. Web 应用程序三层架构图示描述</h4><ul><li><strong>图1：应用程序三层架构</strong><ol><li><strong>前端（Presentation Layer）：</strong> 用户界面部分，负责与用户交互，通过浏览器展示HTML、CSS、JavaScript等。</li><li><strong>业务逻辑层（Business Logic Layer）：</strong> 处理应用程序的核心功能和业务规则，通常通过Servlets、JSP、或其他中间件实现。</li><li><strong>数据访问层（Data Access Layer）：</strong> 负责与数据库的交互，通过JDBC、ORM工具（如Hibernate）进行数据的读取与存储。</li></ol></li></ul><h4 id="2-Servlet-处理流程图示描述"><a href="#2-Servlet-处理流程图示描述" class="headerlink" title="2. Servlet 处理流程图示描述"></a>2. Servlet 处理流程图示描述</h4><ul><li><strong>图2：Servlet 处理流程</strong><ol><li>用户在浏览器中提交请求（如表单）。</li><li>请求发送到Web服务器。</li><li>Web服务器将请求转发给对应的Servlet。</li><li>Servlet处理请求，包括与数据库的交互。</li><li>Servlet生成HTML响应并返回给Web服务器。</li><li>Web服务器将响应发送回用户的浏览器显示。</li></ol></li></ul><h4 id="3-防范XSS攻击的流程图示描述"><a href="#3-防范XSS攻击的流程图示描述" class="headerlink" title="3. 防范XSS攻击的流程图示描述"></a>3. 防范XSS攻击的流程图示描述</h4><ul><li><strong>图3：防范跨站脚本攻击（XSS）流程</strong><ol><li>用户提交输入数据。</li><li>服务器端对输入数据进行过滤，移除或转义HTML标签。</li><li>生成安全的HTML页面返回给用户。</li><li>浏览器渲染页面，防止恶意脚本执行。</li></ol></li></ul><hr><h2 id="第十章-物理存储系统和文件组织"><a href="#第十章-物理存储系统和文件组织" class="headerlink" title="第十章 物理存储系统和文件组织"></a>第十章 物理存储系统和文件组织</h2><h3 id="10-1-物理存储介质分类"><a href="#10-1-物理存储介质分类" class="headerlink" title="10.1 物理存储介质分类"></a>10.1 物理存储介质分类</h3><p>物理存储介质按数据存储的特性分为以下两类：</p><ul><li><p><strong>易失性存储（Volatile Storage）</strong>：</p><ul><li>断电后数据丢失。</li><li>例如：缓存（Cache）、主存（Main Memory）。</li></ul></li><li><p><strong>非易失性存储（Non-Volatile Storage）</strong>：</p><ul><li>断电后数据仍然保存。</li><li>包括：二级存储（磁盘、闪存）、三级存储（磁带、光盘）和带有电池支持的主存。</li></ul></li></ul><p><strong>影响存储介质选择的因素：</strong></p><ul><li>数据访问速度。</li><li>单位存储成本。</li><li>可靠性。</li></ul><hr><h3 id="10-2-存储层次结构"><a href="#10-2-存储层次结构" class="headerlink" title="10.2 存储层次结构"></a>10.2 存储层次结构</h3><p>存储设备按照速度、成本和存储容量形成一个层次结构：</p><ul><li><p><strong>主存储（Primary Storage）</strong>：</p><ul><li><strong>特点</strong>：速度最快，但易失性。</li><li><strong>举例</strong>：缓存、主存。</li></ul></li><li><p><strong>二级存储（Secondary Storage）</strong>：</p><ul><li><strong>特点</strong>：非易失性，速度适中。</li><li><strong>举例</strong>：闪存、磁盘（HDD、SSD）。</li></ul></li><li><p><strong>三级存储（Tertiary Storage）</strong>：</p><ul><li><strong>特点</strong>：非易失性，访问速度慢，适合归档数据。</li><li><strong>举例</strong>：磁带（顺序访问）、光盘。</li></ul></li></ul><p><strong>实例分析：</strong></p><ul><li>磁带存储容量可达1-12TB，适合大规模归档存储，但访问速度慢（顺序访问）。</li><li>磁盘存储的扇区（Sector）是访问的最小单位，一般大小为512字节。</li></ul><hr><h3 id="10-3-磁盘存储机制"><a href="#10-3-磁盘存储机制" class="headerlink" title="10.3 磁盘存储机制"></a>10.3 磁盘存储机制</h3><p>磁盘存储的关键技术细节：</p><ul><li><p><strong>磁盘结构</strong>：</p><ul><li>磁盘由若干圆形磁盘组成，每个磁盘包含多个<strong>磁道（Tracks）</strong>，每个磁道再分为<strong>扇区（Sectors）</strong>。</li><li>典型硬盘每个磁盘有50K-100K磁道，每扇区大小通常为512字节。</li></ul></li><li><p><strong>读写过程</strong>：</p><ul><li><strong>磁臂定位时间（Seek Time）</strong>：磁臂移动到目标磁道的时间。</li><li><strong>旋转延迟（Rotational Latency）</strong>：目标扇区旋转至磁头下的时间。</li><li><strong>数据传输率（Data-Transfer Rate）</strong>：数据传输速率，典型范围为25至200MB&#x2F;s。</li></ul></li></ul><p><strong>实例分析：</strong><br>假设一块硬盘的平均定位时间为5ms，旋转延迟为5ms，传输速率为100MB&#x2F;s，一次读取1MB数据：</p><ul><li>总延迟 &#x3D; 定位时间 + 旋转延迟 + 数据传输时间 &#x3D; 5ms + 5ms + (1MB &#x2F; 100MB&#x2F;s) &#x3D; 15ms。</li></ul><hr><h3 id="10-4-磁盘可靠性与性能"><a href="#10-4-磁盘可靠性与性能" class="headerlink" title="10.4 磁盘可靠性与性能"></a>10.4 磁盘可靠性与性能</h3><ul><li><p><strong>平均故障间隔时间（MTTF）</strong>：</p><ul><li>表示磁盘在连续运行中平均无故障的时间，通常为3-5年。</li><li>例如：MTTF为120万小时，表示1000块新磁盘中，每1200小时可能损坏一块。</li></ul></li><li><p><strong>磁盘控制器</strong>：</p><ul><li>负责磁盘与计算机的交互，执行磁臂移动、数据读写、校验和计算等任务。</li><li>提供坏扇区重新映射功能以提高可靠性。</li></ul></li></ul><hr><h3 id="10-5-闪存存储"><a href="#10-5-闪存存储" class="headerlink" title="10.5 闪存存储"></a>10.5 闪存存储</h3><ul><li><p><strong>NAND闪存</strong>：</p><ul><li><strong>特点</strong>：广泛用于存储设备（如SSD），便宜但需要按页读取（页大小512B-4KB）。</li><li><strong>速度</strong>：读取一页耗时20-100微秒。</li><li><strong>限制</strong>：每个页只能写一次，重写需先擦除。</li></ul></li><li><p><strong>固态硬盘（SSD）</strong>：</p><ul><li>内部使用多块闪存，提供块级接口。</li><li><strong>传输速率</strong>：通过NVMe协议可达3GB&#x2F;s。</li></ul></li></ul><hr><h3 id="10-6-RAID（独立磁盘冗余阵列）"><a href="#10-6-RAID（独立磁盘冗余阵列）" class="headerlink" title="10.6 RAID（独立磁盘冗余阵列）"></a>10.6 RAID（独立磁盘冗余阵列）</h3><p>RAID通过并行和冗余提升存储系统的性能和可靠性：</p><ul><li><p><strong>RAID 0（条带化存储，无冗余）</strong>：</p><ul><li><strong>特点</strong>：将数据分块存储到多个磁盘中，读写性能高，但无数据保护。</li><li><strong>用途</strong>：高性能、数据丢失风险可接受的场景。</li></ul></li><li><p><strong>RAID 1（镜像存储）</strong>：</p><ul><li><strong>特点</strong>：将每块磁盘的数据完全复制到另一块磁盘。</li><li><strong>优点</strong>：提供高可靠性，适合日志存储。</li></ul></li><li><p><strong>RAID 5（分布式奇偶校验）</strong>：</p><ul><li><strong>特点</strong>：数据和奇偶校验分布在所有磁盘上，提供容错能力。</li><li><strong>缺点</strong>：写性能较低。</li></ul></li><li><p><strong>RAID 6（双奇偶校验）</strong>：</p><ul><li><strong>特点</strong>：比RAID 5增加额外奇偶校验块，可容忍两块磁盘同时故障。</li></ul></li></ul><p><strong>实例分析：</strong><br>RAID 1的两个磁盘MTTF均为10万小时，修复时间为10小时，则系统数据丢失的平均时间为：</p><ul><li>MTTDL ≈ (MTTF² &#x2F; 修复时间) &#x3D; (10万² &#x2F; 10) &#x3D; 10亿小时（约11万年）。</li></ul><hr><h3 id="10-7-文件组织"><a href="#10-7-文件组织" class="headerlink" title="10.7 文件组织"></a>10.7 文件组织</h3><p>数据库存储为文件集合，每个文件由记录组成：</p><ul><li><p><strong>固定长度记录</strong>：</p><ul><li><strong>存储方式</strong>：记录按固定字节偏移存储。</li><li><strong>删除方式</strong>：可以通过移动记录或维护空闲列表实现。</li></ul></li><li><p><strong>可变长度记录</strong>：</p><ul><li><strong>存储方式</strong>：使用偏移量和长度标记字段，实际数据存储在记录末尾。</li><li><strong>优点</strong>：支持变长字段（如VARCHAR）和重复字段。</li></ul></li><li><p><strong>大对象存储</strong>：</p><ul><li>例如：BLOB&#x2F;CLOB类型。</li><li><strong>存储方式</strong>：可以拆分为多个元组存储，或者存储为文件系统中的文件。</li></ul></li></ul><hr><h3 id="10-8-文件组织策略"><a href="#10-8-文件组织策略" class="headerlink" title="10.8 文件组织策略"></a>10.8 文件组织策略</h3><ul><li><p><strong>堆文件（Heap）</strong>：</p><ul><li>无序存储，记录插入到空闲空间。</li><li>使用空闲空间映射表（Free-Space Map）来快速定位空闲块。</li></ul></li><li><p><strong>顺序文件（Sequential）</strong>：</p><ul><li>按搜索键值存储，适合顺序访问。</li><li><strong>处理删除和插入</strong>：通过溢出块和指针链维护顺序。</li></ul></li><li><p><strong>多表聚簇文件（Multitable Clustering）</strong>：</p><ul><li>将多个关系存储在同一文件中，适合频繁的连接查询。</li></ul></li></ul><hr><h3 id="10-9-列存储与压缩"><a href="#10-9-列存储与压缩" class="headerlink" title="10.9 列存储与压缩"></a>10.9 列存储与压缩</h3><ul><li><p><strong>列存储（Column-Oriented Storage）</strong>：</p><ul><li>将每个属性单独存储，适合数据分析和决策支持。</li><li><strong>优点</strong>：减少I&#x2F;O、提升压缩率、支持矢量化处理。</li><li><strong>缺点</strong>：重建元组成本高，更新和删除效率低。</li></ul></li><li><p><strong>实例：Parquet文件格式</strong>：</p><ul><li>广泛应用于大数据场景，提供高效的列式存储。</li></ul></li></ul><hr><h3 id="10-10-缓存管理"><a href="#10-10-缓存管理" class="headerlink" title="10.10 缓存管理"></a>10.10 缓存管理</h3><ul><li><strong>缓冲区管理器</strong>：<ul><li><strong>功能</strong>：管理内存中的数据块缓存，减少磁盘访问次数。</li><li><strong>替换策略</strong>：<ul><li><strong>LRU（最近最少使用）</strong>：根据历史访问记录替换。</li><li><strong>MRU（最近最多使用）</strong>：适合需要频繁访问的块。</li><li><strong>Toss-Immediate</strong>：块处理完成后立即释放。</li></ul></li></ul></li></ul><p><strong>实例分析：</strong><br>嵌套循环连接可能导致LRU策略性能低下，因为循环内的访问模式会不断驱逐之前加载的块。</p><hr><h3 id="10-11-数据字典（系统目录）"><a href="#10-11-数据字典（系统目录）" class="headerlink" title="10.11 数据字典（系统目录）"></a>10.11 数据字典（系统目录）</h3><p>数据字典存储数据库的元数据，例如：</p><ul><li>关系的名称、属性及其类型。</li><li>索引信息和物理存储位置。</li><li>用户信息和统计数据。</li></ul><p>元数据的高效访问对数据库系统的运行至关重要。</p><hr><hr><h2 id="第十一章-索引"><a href="#第十一章-索引" class="headerlink" title="第十一章 索引"></a>第十一章 索引</h2><h3 id="11-1-索引的基本概念"><a href="#11-1-索引的基本概念" class="headerlink" title="11.1 索引的基本概念"></a>11.1 索引的基本概念</h3><p><strong>关键概念</strong></p><ul><li><p><strong>搜索键（Search Key）</strong>：</p><ul><li>用于查找记录的一个或多个属性。</li></ul></li><li><p><strong>索引文件（Index File）</strong>：</p><ul><li>包含形式为 <code>(search-key, pointer)</code> 的索引条目，指向实际数据记录。</li></ul></li><li><p><strong>索引的两种基本类型</strong>：</p><ol><li><strong>有序索引（Ordered Indices）</strong>：按搜索键值排序存储。</li><li><strong>哈希索引（Hash Indices）</strong>：通过哈希函数将搜索键均匀分布到“桶”中。</li></ol></li></ul><p><strong>评价指标</strong></p><ul><li><p><strong>支持的访问类型</strong>：</p><ul><li>按指定值查找记录。</li><li>按范围值查找记录。</li></ul></li><li><p><strong>时间效率</strong>：访问、插入和删除的时间。</p></li><li><p><strong>空间开销</strong>：索引的存储成本。</p></li></ul><hr><h3 id="11-2-有序索引"><a href="#11-2-有序索引" class="headerlink" title="11.2 有序索引"></a>11.2 有序索引</h3><p>有序索引是基于搜索键值排序的索引方式。</p><p><strong>分类</strong></p><ol><li><p><strong>聚簇索引（Clustering Index）</strong>：</p><ul><li>索引的键值与文件的物理顺序一致。</li><li>通常是主键，但不一定必须是主键。</li><li>又称<strong>主索引（Primary Index）</strong>。</li></ul></li><li><p><strong>非聚簇索引（Non-Clustering Index）</strong>：</p><ul><li>索引的键值与文件的物理顺序无关。</li><li>又称<strong>次级索引（Secondary Index）</strong>。</li></ul></li><li><p><strong>密集索引（Dense Index）</strong>：</p><ul><li>每个搜索键值都有一个索引记录。</li><li><strong>例子</strong>：对<code>instructor</code>关系的<code>ID</code>属性建立密集索引。<ul><li><strong>解析</strong>：每个<code>ID</code>值在索引中都有一个对应的条目，指向实际数据记录。</li></ul></li></ul></li><li><p><strong>稀疏索引（Sparse Index）</strong>：</p><ul><li>仅为部分搜索键值建立索引条目。</li><li><strong>适用场景</strong>：文件按搜索键排序，例如每个块的第一个键值。</li><li><strong>优缺点</strong>：稀疏索引节省空间，但查找速度较慢。</li></ul></li></ol><p><strong>例子解析</strong>：<br>假设文件根据<code>dept_name</code>排序，对其建立稀疏索引。要查找<code>Physics</code>，首先找到小于<code>Physics</code>的最大键值（例如<code>Mathematics</code>），然后从指针指定的位置顺序扫描。</p><hr><h3 id="11-3-多级索引"><a href="#11-3-多级索引" class="headerlink" title="11.3 多级索引"></a>11.3 多级索引</h3><p>当索引文件太大无法全部加载到内存时：</p><ul><li>将索引看作顺序文件，为其构建稀疏索引（称为<strong>外层索引</strong>）。</li><li>如果外层索引仍然过大，可以继续构建更高层的索引，形成多层次结构。</li></ul><p><strong>优点</strong>：通过分层结构减少磁盘访问次数，提高查找效率。<br><strong>缺点</strong>：插入或删除时需要更新所有层次的索引。</p><hr><h3 id="11-4-B-树索引"><a href="#11-4-B-树索引" class="headerlink" title="11.4 B+树索引"></a>11.4 B+树索引</h3><p><strong>B+树</strong>是一种动态多级索引结构，广泛用于数据库系统中。</p><p><strong>特点</strong></p><ul><li>自动调整以适应插入和删除，避免性能下降。</li><li><strong>平衡性</strong>：从根到叶节点的路径长度相同。</li><li><strong>节点结构</strong>：<ul><li>非叶节点存储键值和指针，形成稀疏索引。</li><li>叶节点存储所有搜索键值及对应指针，形成密集索引，并通过指针相连。</li></ul></li></ul><p><strong>优点</strong></p><ul><li>插入和删除只需局部调整，性能稳定。</li><li>查找时间为<code>O(log n)</code>，其中<code>n</code>为树的阶。</li></ul><p><strong>例子解析</strong>：</p><ol><li><p><strong>插入“Adams”</strong>：</p><ul><li>找到适当的叶节点，如果节点已满，拆分节点，将部分键值移至新节点，并将新节点的信息插入父节点。</li><li>如果父节点也满，继续向上拆分，可能导致树高度增加。</li></ul></li><li><p><strong>删除“Singh”</strong>：</p><ul><li>如果删除导致节点不足，将其与相邻节点合并，或从邻居节点借用键值。</li><li>如果父节点变得不足，继续调整，可能导致树高度减少。</li></ul></li></ol><hr><h3 id="11-5-哈希索引"><a href="#11-5-哈希索引" class="headerlink" title="11.5 哈希索引"></a>11.5 哈希索引</h3><p>哈希索引通过哈希函数将搜索键值映射到桶地址。</p><p><strong>分类</strong></p><ol><li><p><strong>静态哈希</strong>：</p><ul><li>桶数量固定。</li><li><strong>缺点</strong>：当文件大小动态变化时，可能导致桶溢出或空间浪费。</li></ul></li><li><p><strong>动态哈希</strong>：</p><ul><li><strong>线性哈希（Linear Hashing）</strong>：增量扩展桶，以适应文件增长。</li><li><strong>可扩展哈希（Extendable Hashing）</strong>：通过增加哈希表的深度而不增加桶数量。</li></ul></li></ol><p><strong>例子解析</strong>：</p><p>对<code>instructor</code>的<code>ID</code>属性建立哈希索引：</p><ol><li>将<code>ID</code>值通过哈希函数映射到桶。</li><li>如果多个键值映射到同一桶，使用溢出链表存储额外记录。</li></ol><p><strong>优缺点对比</strong>：</p><ul><li>哈希索引适合精确查找。</li><li>有序索引适合范围查询。</li></ul><hr><h3 id="11-6-复合索引"><a href="#11-6-复合索引" class="headerlink" title="11.6 复合索引"></a>11.6 复合索引</h3><p><strong>复合搜索键</strong>：包含多个属性的搜索键，例如<code>(dept_name, salary)</code>。</p><p><strong>特点</strong></p><ul><li>按字典序排序（例如：<code>(Finance, 80000)</code> &lt; <code>(Marketing, 70000)</code>）。</li><li>可以同时高效处理多个条件查询。</li></ul><p><strong>例子解析</strong>：<br>假设有索引<code>(dept_name, salary)</code>：</p><ol><li><p>查询条件<code>dept_name=&quot;Finance&quot; AND salary=80000</code>：</p><ul><li>索引直接定位到满足条件的记录。</li></ul></li><li><p>查询条件<code>dept_name=&quot;Finance&quot; AND salary&lt;80000</code>：</p><ul><li>索引可快速定位到<code>Finance</code>，然后顺序扫描满足<code>salary&lt;80000</code>的记录。</li></ul></li><li><p>查询条件<code>dept_name&lt;&quot;Finance&quot; AND salary=80000</code>：</p><ul><li>无法高效利用索引，因为<code>dept_name</code>的范围查询优先级更高。</li></ul></li></ol><hr><h3 id="11-7-位图索引"><a href="#11-7-位图索引" class="headerlink" title="11.7 位图索引"></a>11.7 位图索引</h3><p>哈希索引通过哈希函数将搜索键值映射到桶地址。</p><p><strong>特点</strong></p><ul><li>每个属性值对应一个位图，位图每位表示一个记录是否具有该值。</li><li>适合属性值数量较少的情况，例如性别、国家、收入等级。</li></ul><p><strong>查询操作</strong></p><ul><li>使用位运算（与、或、非）快速计算结果。</li><li><strong>例子</strong>：<ul><li>查询男性且收入等级为L1：<code>Bitmap(Male) AND Bitmap(L1)</code>。</li><li>查询结果位图可以直接定位记录。</li></ul></li></ul><p><strong>优点</strong>：空间开销小，查询效率高。<br><strong>缺点</strong>：不适合动态变化的数据。</p><hr><h3 id="11-8-索引的创建与管理"><a href="#11-8-索引的创建与管理" class="headerlink" title="11.8 索引的创建与管理"></a>11.8 索引的创建与管理</h3><p><strong>SQL中的索引定义</strong></p><ul><li><p><strong>创建索引</strong>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name (attribute_list);</span><br></pre></td></tr></table></figure><p><strong>例子</strong>：对<code>branch</code>表的<code>branch_name</code>属性创建索引：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX b_index <span class="keyword">ON</span> branch(branch_name);</span><br></pre></td></tr></table></figure></li><li><p><strong>删除索引</strong>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name;</span><br></pre></td></tr></table></figure></li><li><p><strong>唯一索引</strong>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX unique_index_name <span class="keyword">ON</span> table_name(attribute_list);</span><br></pre></td></tr></table></figure><p>用于强制候选键的唯一性。</p></li></ul><p><strong>数据库自动创建索引</strong></p><ul><li>数据库通常会自动为<strong>主键</strong>和<strong>外键</strong>创建索引：<ul><li>主键索引：加速主键查找。</li><li>外键索引：加速连接查询。</li></ul></li></ul><hr><h3 id="11-9-索引的优化选择"><a href="#11-9-索引的优化选择" class="headerlink" title="11.9 索引的优化选择"></a>11.9 索引的优化选择</h3><p>索引的使用需权衡查询性能与更新成本：</p><ul><li><p><strong>查询优化</strong>：</p><ul><li>索引加速查询，但复杂查询可能需要多个索引。</li><li><strong>索引调优工具</strong>：部分数据库提供索引调优助手，根据查询和更新负载建议优化索引。</li></ul></li><li><p><strong>更新代价</strong>：</p><ul><li>插入、删除、更新操作需要维护索引，可能增加成本。</li></ul></li></ul><hr><hr><h2 id="第十三章-查询优化"><a href="#第十三章-查询优化" class="headerlink" title="第十三章 查询优化"></a>第十三章 查询优化</h2><h3 id="13-1-查询优化的目标"><a href="#13-1-查询优化的目标" class="headerlink" title="13.1 查询优化的目标"></a>13.1 查询优化的目标</h3><p>查询优化的目标是通过生成低成本的执行计划来提高查询性能。</p><ul><li><strong>查询优化的两种方法</strong>：<ol><li><p><strong>启发式优化（Heuristic Optimization）</strong>：</p><ul><li>使用规则优化查询结构，不需要具体的统计信息。</li><li>优化过程基于通用规则，如选择操作下推、投影操作提前等。</li></ul></li><li><p><strong>基于成本的优化（Cost-Based Optimization）</strong>：</p><ul><li>使用统计信息和模型估计查询计划的执行成本。</li><li>比较多个等价查询计划，选择成本最低的方案。</li></ul></li></ol></li></ul><hr><h3 id="13-2-关系代数等价性与规则"><a href="#13-2-关系代数等价性与规则" class="headerlink" title="13.2 关系代数等价性与规则"></a>13.2 关系代数等价性与规则</h3><h4 id="等价性定义"><a href="#等价性定义" class="headerlink" title="等价性定义"></a>等价性定义</h4><p>两个关系代数表达式在所有合法的数据库实例上生成相同的结果集，则它们是等价的。</p><h4 id="常用等价规则"><a href="#常用等价规则" class="headerlink" title="常用等价规则"></a>常用等价规则</h4><ol><li><p><strong>选择操作规则</strong>：</p><ul><li><p>选择的分解与交换：</p><ul><li><code>σθ1∧θ2(E) ≡ σθ1(σθ2(E))</code></li><li><code>σθ1(σθ2(E)) ≡ σθ2(σθ1(E))</code></li></ul></li><li><p>选择与笛卡尔积、连接的结合：</p><ul><li><code>σθ(E1 × E2) ≡ E1 ⨝θ E2</code></li><li><code>σθ1(E1 ⨝θ2 E2) ≡ E1 ⨝θ1∧θ2 E2</code></li></ul></li></ul></li><li><p><strong>投影操作规则</strong>：</p><ul><li>只保留最后一个投影操作：<br><code>πL1(πL2(...πLn(E)...)) ≡ πL1(E)</code>，其中 <code>L1 ⊆ L2 ⊆ ... ⊆ Ln</code>。</li></ul></li><li><p><strong>连接操作规则</strong>：</p><ul><li>连接的交换性：<code>E1 ⨝ E2 ≡ E2 ⨝ E1</code></li><li>连接的结合性：<code>(E1 ⨝ E2) ⨝ E3 ≡ E1 ⨝ (E2 ⨝ E3)</code></li></ul></li><li><p><strong>选择与连接的分配性</strong>：</p><ul><li><code>σθ(E1 ⨝ E2) ≡ (σθ(E1)) ⨝ E2</code>，条件是 <code>θ</code> 只涉及 <code>E1</code> 的属性。</li></ul></li><li><p><strong>投影与连接的分配性</strong>：</p><ul><li><code>πL1∪L2(E1 ⨝ E2) ≡ (πL1(E1)) ⨝ (πL2(E2))</code>，条件是 <code>L1</code> 和 <code>L2</code> 包含连接所需的所有属性。</li></ul></li><li><p><strong>集合操作规则</strong>：</p><ul><li>并集和交集的交换性与结合性：<ul><li><code>E1 ∪ E2 ≡ E2 ∪ E1</code>，<code>(E1 ∪ E2) ∪ E3 ≡ E1 ∪ (E2 ∪ E3)</code></li></ul></li><li>选择与集合操作的分配性：<ul><li><code>σθ(E1 ∪ E2) ≡ σθ(E1) ∪ σθ(E2)</code></li></ul></li></ul></li></ol><p><strong>例子解析</strong>：<br>查询：查找<code>Music</code>系的教师姓名及其在2017年授课的课程标题。  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ARTIST.NAME, COURSE.TITLE</span><br><span class="line"><span class="keyword">FROM</span> ARTIST, TEACHES, COURSE</span><br><span class="line"><span class="keyword">WHERE</span> ARTIST.dept_name <span class="operator">=</span> <span class="string">&#x27;Music&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> TEACHES.year <span class="operator">=</span> <span class="number">2017</span></span><br><span class="line">  <span class="keyword">AND</span> ARTIST.ID <span class="operator">=</span> TEACHES.ID</span><br><span class="line">  <span class="keyword">AND</span> TEACHES.course_id <span class="operator">=</span> COURSE.course_id;</span><br></pre></td></tr></table></figure><ol><li><p>初始表达式：<br><code>πname, title(σdept_name=&#39;Music&#39;∧year=2017(instructor ⨝ teaches ⨝ course))</code></p></li><li><p>使用连接结合性：<br><code>(instructor ⨝ teaches) ⨝ course</code> 转换为 <code>instructor ⨝ (teaches ⨝ course)</code></p></li><li><p>应用选择下推规则：<br><code>σdept_name=&#39;Music&#39;(instructor) ⨝ σyear=2017(teaches) ⨝ course</code></p></li><li><p>提前投影：减少中间结果的大小。</p></li></ol><hr><h3 id="13-3-基于成本的优化"><a href="#13-3-基于成本的优化" class="headerlink" title="13.3 基于成本的优化"></a>13.3 基于成本的优化</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li><p><strong>生成等价表达式</strong>：</p><ul><li>使用关系代数等价规则生成多个等价表达式。</li></ul></li><li><p><strong>注释表达式</strong>：</p><ul><li>为每个表达式选择具体的算法（如嵌套循环连接、哈希连接等）。</li></ul></li><li><p><strong>估算成本</strong>：</p><ul><li>基于统计信息估算每种执行计划的成本。</li></ul></li><li><p><strong>选择最低成本计划</strong>：</p><ul><li>比较所有计划，选择成本最低的一个。</li></ul></li></ol><h4 id="成本估算"><a href="#成本估算" class="headerlink" title="成本估算"></a>成本估算</h4><ul><li><p><strong>统计信息</strong>：</p><ul><li>记录的数量（<code>nr</code>）。</li><li>每个块的记录数（<code>fr</code>）。</li><li>属性的不同值数量（<code>V(A, r)</code>）。</li></ul></li><li><p><strong>选择操作</strong>：</p><ul><li><code>σA=v(r)</code> 的记录数：<code>nr / V(A, r)</code>。</li><li><code>σA≥v(r)</code> 的记录数：<code>nr * (Amax - v + 1) / (Amax - Amin + 1)</code>。</li></ul></li><li><p><strong>连接操作</strong>：</p><ul><li>若 <code>R ⋂ S</code> 为键：<code>|r ⨝ s| = |s|</code>。</li><li>一般情况：<code>|r ⨝ s| ≈ nr * ns / max(V(A, r), V(A, s))</code>。</li></ul></li></ul><p><strong>例子解析</strong>：<br>学生表（<code>student</code>）和选课表（<code>takes</code>）：  </p><ul><li><code>nstudent = 5000</code>, <code>bstudent = 100</code>, <code>ntakes = 10000</code>, <code>btakes = 400</code>。  </li><li><code>V(ID, student) = 5000</code>, <code>V(ID, takes) = 2500</code>。<br>假设 <code>ID</code> 是 <code>takes</code> 的外键，连接结果的大小为 <code>ntakes = 10000</code>。</li></ul><hr><h3 id="13-4-动态规划与连接顺序"><a href="#13-4-动态规划与连接顺序" class="headerlink" title="13.4 动态规划与连接顺序"></a>13.4 动态规划与连接顺序</h3><h4 id="连接顺序优化"><a href="#连接顺序优化" class="headerlink" title="连接顺序优化"></a>连接顺序优化</h4><ul><li><strong>连接顺序会显著影响查询性能。</strong></li><li>动态规划通过递归计算子集的最优连接计划，避免重复计算。</li></ul><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ol><li><p>对于每个子集 <code>S</code>：</p><ul><li>尝试所有可能的分割 <code>S1</code> 和 <code>S2</code>（<code>S1 ⨝ S2</code>）。</li><li>计算每种分割的成本，选择最低成本的方案。</li></ul></li><li><p>存储每个子集的最优计划，避免重复计算。</p></li></ol><p><strong>复杂性</strong>：  </p><ul><li><strong>一般情况</strong>：<code>O(3^n)</code>，其中 <code>n</code> 为关系数量。  </li><li><strong>左深树优化</strong>：<code>O(n * 2^n)</code>，适用于优化复杂度较低的场景。</li></ul><hr><h3 id="13-5-启发式优化"><a href="#13-5-启发式优化" class="headerlink" title="13.5 启发式优化"></a>13.5 启发式优化</h3><h4 id="启发式规则"><a href="#启发式规则" class="headerlink" title="启发式规则"></a>启发式规则</h4><ol><li><p><strong>选择操作尽早执行</strong>：</p><ul><li>减少待处理的元组数量。</li></ul></li><li><p><strong>投影操作尽早执行</strong>：</p><ul><li>减少待处理的属性数量。</li></ul></li><li><p><strong>优先执行选择性强的操作</strong>：</p><ul><li>选择性强的操作通常会显著减少中间结果的大小。</li></ul></li><li><p><strong>避免笛卡尔积</strong>：</p><ul><li>替换为连接操作。</li></ul></li></ol><p><strong>例子解析</strong>：<br>查询：查找专辑名称为“Andy’s OG Remix”的艺术家姓名。  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ARTIST.NAME</span><br><span class="line"><span class="keyword">FROM</span> ARTIST, APPEARS, ALBUM</span><br><span class="line"><span class="keyword">WHERE</span> ARTIST.ID <span class="operator">=</span> APPEARS.ARTIST_ID</span><br><span class="line">  <span class="keyword">AND</span> APPEARS.ALBUM_ID <span class="operator">=</span> ALBUM.ID</span><br><span class="line">  <span class="keyword">AND</span> ALBUM.NAME <span class="operator">=</span> &quot;Andy’s OG Remix&quot;;</span><br></pre></td></tr></table></figure><ol><li><p><strong>分解谓词</strong>：  </p><ul><li><code>ARTIST.ID = APPEARS.ARTIST_ID</code>  </li><li><code>APPEARS.ALBUM_ID = ALBUM.ID</code>  </li><li><code>ALBUM.NAME = &quot;Andy’s OG Remix&quot;</code></li></ul></li><li><p><strong>谓词下推</strong>：  </p><ul><li>将 <code>ALBUM.NAME = &quot;Andy’s OG Remix&quot;</code> 下推到 <code>ALBUM</code> 中，减少中间结果。</li></ul></li><li><p><strong>替换笛卡尔积</strong>：  </p><ul><li>用连接代替笛卡尔积：<code>ARTIST ⨝ APPEARS ⨝ ALBUM</code>。</li></ul></li><li><p><strong>提前投影</strong>：  </p><ul><li>删除不必要的属性，减少中间结果的大小。</li></ul></li></ol><hr><h3 id="13-6-统计信息与直方图"><a href="#13-6-统计信息与直方图" class="headerlink" title="13.6 统计信息与直方图"></a>13.6 统计信息与直方图</h3><ul><li><strong>数据库系统使用统计信息（如记录数、属性的不同值数）来估算查询成本。</strong></li><li><strong>直方图</strong>：<ul><li><strong>等宽直方图</strong>：将值域划分为等宽区间。</li><li><strong>等深直方图</strong>：每个区间包含相同数量的元组。</li></ul></li></ul><p><strong>例子解析</strong>：<br>假设<code>V(age, people) = 5</code>, <code>nr = 5</code>：  </p><ol><li><p>查询 <code>age=2</code>：  </p><ul><li>满足条件的记录数为 <code>nr / V(age, people) = 5 / 5 = 1</code>。</li></ul></li><li><p>查询 <code>age&gt;=2</code>：  </p><ul><li>满足条件的记录数为 <code>nr * (Amax - 2 + 1) / (Amax - Amin + 1)</code>。  </li><li>结果为 <code>5 * (4 - 2 + 1) / (4 - 0 + 1) = 3</code>。</li></ul></li></ol><hr><hr><h2 id="第十四章-事务"><a href="#第十四章-事务" class="headerlink" title="第十四章 事务"></a>第十四章 事务</h2><h3 id="14-1-事务的基本概念"><a href="#14-1-事务的基本概念" class="headerlink" title="14.1 事务的基本概念"></a>14.1 事务的基本概念</h3><h4 id="事务（Transaction）"><a href="#事务（Transaction）" class="headerlink" title="事务（Transaction）"></a>事务（Transaction）</h4><ul><li><strong>定义</strong>：事务是一个程序执行的单位，通过访问和可能更新数据库中的数据项来完成任务。</li><li><strong>性质</strong>：事务要么完全执行（所有操作成功完成），要么完全不执行（任何操作都不生效）。</li></ul><p><strong>例子</strong>：<br>将$50从账户A转移到账户B的事务：</p><ol><li>读取账户A余额。</li><li>从账户A扣除50。</li><li>写回账户A的新余额。</li><li>读取账户B余额。</li><li>向账户B添加50。</li><li>写回账户B的新余额。</li></ol><p><strong>问题</strong>：</p><ul><li>如果系统在步骤3和步骤6之间崩溃，可能导致数据不一致（$50丢失）。</li></ul><hr><h3 id="14-2-事务的ACID属性"><a href="#14-2-事务的ACID属性" class="headerlink" title="14.2 事务的ACID属性"></a>14.2 事务的ACID属性</h3><p>事务需要满足以下四个关键特性以保证数据库的一致性：</p><ol><li><p><strong>原子性（Atomicity）</strong>：</p><ul><li>事务的所有操作要么全部执行，要么全部不执行。</li><li><strong>解决方法</strong>：通过日志记录，在事务失败时回滚未完成的操作。</li></ul></li><li><p><strong>一致性（Consistency）</strong>：</p><ul><li>事务的执行必须保证数据库从一个一致状态转变为另一个一致状态。</li><li><strong>例子</strong>：在转账事务中，A和B账户余额之和在事务执行后保持不变。</li></ul></li><li><p><strong>隔离性（Isolation）</strong>：</p><ul><li>事务彼此独立运行，每个事务的中间状态对其他事务不可见。</li><li><strong>问题</strong>：如果隔离性未得到保证，可能导致数据不一致。</li></ul></li><li><p><strong>持久性（Durability）</strong>：</p><ul><li>一旦事务提交，其对数据库的修改必须永久保存，即使系统崩溃。</li><li><strong>解决方法</strong>：使用日志或稳定存储。</li></ul></li></ol><hr><h3 id="14-3-事务的状态"><a href="#14-3-事务的状态" class="headerlink" title="14.3 事务的状态"></a>14.3 事务的状态</h3><p><strong>事务的生命周期</strong>由以下几种状态组成：</p><ul><li><strong>活动状态（Active）</strong>：事务正在执行。</li><li><strong>部分提交状态（Partially Committed）</strong>：事务的最后一条语句已经执行，但尚未完成提交。</li><li><strong>失败状态（Failed）</strong>：事务由于某种原因无法继续。</li><li><strong>中止状态（Aborted）</strong>：事务被回滚，数据库恢复到事务开始时的状态。</li><li><strong>提交状态（Committed）</strong>：事务成功完成，所有修改被永久保存。</li></ul><p><strong>例子</strong>：  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">50</span> <span class="keyword">WHERE</span> <span class="keyword">no</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">50</span> <span class="keyword">WHERE</span> <span class="keyword">no</span> <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><ul><li>如果在第一条<code>UPDATE</code>执行后系统崩溃，事务的<strong>原子性</strong>和<strong>一致性</strong>会受影响。</li></ul><hr><h3 id="14-4-调度与并发执行"><a href="#14-4-调度与并发执行" class="headerlink" title="14.4 调度与并发执行"></a>14.4 调度与并发执行</h3><h4 id="调度（Schedule）"><a href="#调度（Schedule）" class="headerlink" title="调度（Schedule）"></a>调度（Schedule）</h4><ul><li><p>调度是指事务中所有操作按照时间顺序执行的过程。</p></li><li><p><strong>串行调度</strong>：</p><ul><li>一个事务完成后再执行下一个事务。</li><li>保证一致性，但效率低。</li></ul></li><li><p><strong>并发调度</strong>：</p><ul><li>多个事务交错执行，提高资源利用率和响应时间。</li></ul></li></ul><h4 id="并发执行的优点"><a href="#并发执行的优点" class="headerlink" title="并发执行的优点"></a>并发执行的优点</h4><ol><li>提高处理器和磁盘的利用率。</li><li>减少事务的平均响应时间。</li></ol><h4 id="并发调度的问题"><a href="#并发调度的问题" class="headerlink" title="并发调度的问题"></a>并发调度的问题</h4><p>如果未正确处理并发调度，可能导致以下数据不一致性：</p><ol><li><p><strong>丢失修改</strong>：</p><ul><li><p>两个事务同时修改同一数据，一个事务的修改被另一个事务覆盖。</p></li><li><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">T1: read(A); A :<span class="operator">=</span> A <span class="operator">+</span> <span class="number">100</span>; write(A);</span><br><span class="line">T2: read(A); A :<span class="operator">=</span> A <span class="operator">+</span> <span class="number">200</span>; write(A);</span><br></pre></td></tr></table></figure><p>如果<code>T1</code>和<code>T2</code>同时执行，<code>T2</code>的写入会覆盖<code>T1</code>的结果，导致<code>T1</code>的修改丢失。</p></li></ul></li><li><p><strong>不可重复读</strong>：</p><ul><li><p>一个事务在两次读取同一数据时，数据值发生了变化。</p></li><li><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">T1: read(A); print(A); read(A); print(A);</span><br><span class="line">T2: read(A); A :<span class="operator">=</span> A <span class="operator">+</span> <span class="number">100</span>; write(A);</span><br></pre></td></tr></table></figure><p><code>T1</code>读取两次<code>A</code>的值可能不同。</p></li></ul></li><li><p><strong>读“脏”数据</strong>：</p><ul><li><p>一个事务<code>T2</code>读取了另一个事务<code>T1</code>未提交的数据，如果<code>T1</code>回滚，则<code>T2</code>读取的数据无效。</p></li><li><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">T1: read(A); A :<span class="operator">=</span> A <span class="operator">+</span> <span class="number">100</span>; write(A); <span class="keyword">rollback</span>;</span><br><span class="line">T2: read(A); print(A);</span><br></pre></td></tr></table></figure><p><code>T2</code>读取了<code>T1</code>未提交的修改，导致读“脏”数据。</p></li></ul></li></ol><hr><h3 id="14-5-可串行化（Serializability）"><a href="#14-5-可串行化（Serializability）" class="headerlink" title="14.5 可串行化（Serializability）"></a>14.5 可串行化（Serializability）</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>一个调度是<strong>可串行化的</strong>，如果它的执行效果与某个串行调度相同。</p><ul><li>可串行化是并发调度的正确性准则。</li></ul><h4 id="冲突可串行化（Conflict-Serializability）"><a href="#冲突可串行化（Conflict-Serializability）" class="headerlink" title="冲突可串行化（Conflict Serializability）"></a>冲突可串行化（Conflict Serializability）</h4><ul><li>如果一个调度可以通过交换非冲突操作转换为串行调度，则该调度是冲突可串行化的。</li><li><strong>冲突的定义</strong>：<ul><li>两个操作访问同一数据，且至少有一个是写操作：<ul><li><code>read(Q) vs write(Q)</code>：冲突。</li><li><code>write(Q) vs write(Q)</code>：冲突。</li></ul></li></ul></li></ul><h4 id="检测冲突可串行化"><a href="#检测冲突可串行化" class="headerlink" title="检测冲突可串行化"></a>检测冲突可串行化</h4><p>通过<strong>优先图（Precedence Graph）</strong>检测：</p><ol><li>图中每个节点表示一个事务。</li><li>如果事务<code>Ti</code>的操作在事务<code>Tj</code>之前访问了数据，则添加一条从<code>Ti</code>到<code>Tj</code>的边。</li><li><strong>判断方法</strong>：如果优先图无环，则调度是冲突可串行化的。</li></ol><p><strong>例子</strong>：  </p><ul><li><p>调度：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">T1: read(A); write(A);</span><br><span class="line">T2: read(A); write(A);</span><br></pre></td></tr></table></figure><ul><li>优先图：<code>T1 → T2</code>，无环，因此可串行化。</li></ul></li></ul><hr><h3 id="14-6-恢复性调度"><a href="#14-6-恢复性调度" class="headerlink" title="14.6 恢复性调度"></a>14.6 恢复性调度</h3><h4 id="恢复性（Recoverable）"><a href="#恢复性（Recoverable）" class="headerlink" title="恢复性（Recoverable）"></a>恢复性（Recoverable）</h4><p>如果事务<code>Tj</code>依赖于事务<code>Ti</code>写入的数据，则<code>Tj</code>必须在<code>Ti</code>提交后才能提交。</p><ul><li><strong>问题</strong>：如果<code>Tj</code>在<code>Ti</code>回滚之前提交，则可能导致不一致。</li></ul><h4 id="级联回滚（Cascading-Rollback）"><a href="#级联回滚（Cascading-Rollback）" class="headerlink" title="级联回滚（Cascading Rollback）"></a>级联回滚（Cascading Rollback）</h4><ul><li>一个事务的失败可能导致多个事务回滚。</li><li><strong>避免方法</strong>：<strong>无级联调度（Cascadeless Schedule）</strong>，要求<code>Tj</code>读取<code>Ti</code>的数据时，<code>Ti</code>必须已提交。</li></ul><hr><h3 id="14-7-事务隔离级别"><a href="#14-7-事务隔离级别" class="headerlink" title="14.7 事务隔离级别"></a>14.7 事务隔离级别</h3><p>SQL-92定义了四种隔离级别，允许不同程度的并发性：</p><ol><li><p><strong>Serializable（可串行化）</strong>：</p><ul><li>最严格的隔离级别，保证事务调度可串行化。</li></ul></li><li><p><strong>Repeatable Read（可重复读）</strong>：</p><ul><li>防止不可重复读，但无法避免幻影读。</li></ul></li><li><p><strong>Read Committed（读已提交）</strong>：</p><ul><li>只能读取已提交的数据，可能导致不可重复读。</li></ul></li><li><p><strong>Read Uncommitted（读未提交）</strong>：</p><ul><li>允许读取未提交的数据，可能导致读“脏”数据。</li></ul></li></ol><p><strong>例子解析</strong>：<br>事务1：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> accounts <span class="keyword">WHERE</span> balance <span class="operator">&gt;</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p>事务2：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>如果隔离级别是<code>Read Uncommitted</code>，事务1可能读取到事务2未提交的结果。</li></ul><hr><hr><h2 id="第十五章-并发控制"><a href="#第十五章-并发控制" class="headerlink" title="第十五章 并发控制"></a>第十五章 并发控制</h2><h3 id="15-1-引言：并发控制的必要性"><a href="#15-1-引言：并发控制的必要性" class="headerlink" title="15.1 引言：并发控制的必要性"></a>15.1 引言：并发控制的必要性</h3><ul><li><strong>目标</strong>：在不预先知道整个调度的情况下，确保所有执行调度都是正确的（即可串行化的）。</li><li><strong>挑战</strong>：<ol><li><strong>数据一致性</strong>：多事务并发执行时，可能导致数据不一致。</li><li><strong>事务隔离性</strong>：必须避免事务间的互相干扰。</li></ol></li><li><strong>解决方案</strong>：<ul><li>使用并发控制协议，如<strong>锁机制</strong>、<strong>时间戳协议</strong>、<strong>多版本控制</strong>等。</li></ul></li></ul><hr><h3 id="15-2-基于锁的并发控制"><a href="#15-2-基于锁的并发控制" class="headerlink" title="15.2 基于锁的并发控制"></a>15.2 基于锁的并发控制</h3><h4 id="2-1-锁的基本概念"><a href="#2-1-锁的基本概念" class="headerlink" title="2.1 锁的基本概念"></a>2.1 锁的基本概念</h4><ul><li><p><strong>定义</strong>：锁是控制数据项并发访问的一种机制。</p></li><li><p><strong>两种锁模式</strong>：</p><ol><li><strong>共享锁（S锁）</strong>：允许事务读取数据，但不允许修改。</li><li><strong>排它锁（X锁）</strong>：允许事务读取和修改数据。</li></ol></li><li><p><strong>锁兼容矩阵</strong>：</p><table><thead><tr><th>请求锁类型</th><th>已持有锁类型</th><th>兼容性</th></tr></thead><tbody><tr><td>S</td><td>S</td><td>是</td></tr><tr><td>S</td><td>X</td><td>否</td></tr><tr><td>X</td><td>S</td><td>否</td></tr><tr><td>X</td><td>X</td><td>否</td></tr></tbody></table></li></ul><p><strong>例子</strong>：<br>事务<code>T2</code>读取两个数据项：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">T2: lock-S(A); read(A); unlock(A);</span><br><span class="line">    lock-S(B); read(B); unlock(B);</span><br><span class="line">    display(A + B)</span><br></pre></td></tr></table></figure><p>这种方式不能保证<strong>可串行化</strong>，因为没有控制事务间的交互。</p><hr><h4 id="2-2-两阶段锁协议（2PL）"><a href="#2-2-两阶段锁协议（2PL）" class="headerlink" title="2.2 两阶段锁协议（2PL）"></a>2.2 两阶段锁协议（2PL）</h4><ul><li><p><strong>定义</strong>：一种确保冲突可串行化的协议，分为两个阶段：</p><ol><li><strong>增长阶段</strong>：事务可以获取锁，但不能释放锁。</li><li><strong>收缩阶段</strong>：事务可以释放锁，但不能获取新锁。</li></ol></li><li><p><strong>关键点</strong>：事务的“锁点”（获取最后一个锁的时间）决定了事务的顺序。</p></li></ul><p><strong>例子</strong>：</p><ol><li><p>符合两阶段锁协议：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">T1: lock-S(B); lock-X(A); read(B); read(A);</span><br><span class="line">    unlock(B); write(A); unlock(A)</span><br></pre></td></tr></table></figure></li><li><p>不符合两阶段锁协议：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">T1: lock-S(B); read(B); unlock(B);</span><br><span class="line">    lock-X(A); read(A); write(A); unlock(A)</span><br></pre></td></tr></table></figure></li></ol><p><strong>扩展</strong>：</p><ol><li><strong>严格两阶段锁协议</strong>：事务直到提交或回滚后才释放其所有的排它锁，避免了<strong>级联回滚</strong>。</li><li><strong>严格强制两阶段锁协议</strong>：事务直到提交或回滚后才释放所有的锁，保证了事务的可恢复性和串行化顺序。</li></ol><hr><h4 id="2-3-死锁处理"><a href="#2-3-死锁处理" class="headerlink" title="2.3 死锁处理"></a>2.3 死锁处理</h4><ul><li><p><strong>死锁</strong>：当一组事务彼此等待对方释放锁时，会导致系统无法继续执行。</p></li><li><p><strong>死锁预防策略</strong>：</p><ol><li><strong>等待-死（Wait-Die）</strong>：较老的事务可以等待较新的事务；较新的事务必须回滚。</li><li><strong>伤害-等待（Wound-Wait）</strong>：较老的事务会中止较新的事务；较新的事务可以等待较老的事务。</li></ol></li><li><p><strong>死锁检测</strong>：</p><ul><li>使用<strong>等待图</strong>，如果图中存在环，则表示发生死锁。</li></ul></li><li><p><strong>死锁恢复</strong>：</p><ul><li>回滚代价最小的事务以打破死锁。</li></ul></li></ul><hr><h3 id="15-3-基于时间戳的并发控制"><a href="#15-3-基于时间戳的并发控制" class="headerlink" title="15.3 基于时间戳的并发控制"></a>15.3 基于时间戳的并发控制</h3><h4 id="3-1-时间戳协议"><a href="#3-1-时间戳协议" class="headerlink" title="3.1 时间戳协议"></a>3.1 时间戳协议</h4><ul><li><strong>时间戳</strong>：每个事务在开始时分配一个唯一的时间戳（TS）。</li><li><strong>规则</strong>：<ol><li>如果<code>TS(Ti) &lt; TS(Tj)</code>，则系统必须确保<code>Ti</code>的操作在<code>Tj</code>之前执行。</li><li>每个数据项维护两个时间戳：<ul><li>**W-timestamp(Q)**：最后写入<code>Q</code>的事务的时间戳。</li><li>**R-timestamp(Q)**：最后读取<code>Q</code>的事务的时间戳。</li></ul></li></ol></li></ul><p><strong>读操作规则</strong>：</p><ol><li>如果<code>TS(Ti) &lt; W-timestamp(Q)</code>，表示<code>Ti</code>试图读取已被覆盖的数据，<code>Ti</code>回滚。</li><li>如果<code>TS(Ti) &gt;= W-timestamp(Q)</code>，执行读取操作，并更新<code>R-timestamp(Q)</code>。</li></ol><p><strong>写操作规则</strong>：</p><ol><li>如果<code>TS(Ti) &lt; R-timestamp(Q)</code>，表示<code>Ti</code>生成的值已经被其他事务读取，<code>Ti</code>回滚。</li><li>如果<code>TS(Ti) &lt; W-timestamp(Q)</code>，表示<code>Ti</code>试图写入过期数据，<code>Ti</code>回滚。</li><li>否则，执行写操作，并更新<code>W-timestamp(Q)</code>。</li></ol><p><strong>优点</strong>：</p><ul><li>保证了可串行化。</li><li>避免死锁（因为没有事务等待）。</li></ul><h4 id="3-2-Thomas写规则"><a href="#3-2-Thomas写规则" class="headerlink" title="3.2 Thomas写规则"></a>3.2 Thomas写规则</h4><ul><li><strong>改进</strong>：当事务试图写入过期值时，直接忽略写操作，而不是回滚事务。</li><li><strong>优势</strong>：允许更多的并发调度，支持一些不可冲突串行化的调度。</li></ul><hr><h3 id="15-4-多版本并发控制（MVCC）"><a href="#15-4-多版本并发控制（MVCC）" class="headerlink" title="15.4 多版本并发控制（MVCC）"></a>15.4 多版本并发控制（MVCC）</h3><h4 id="4-1-多版本协议的核心思想"><a href="#4-1-多版本协议的核心思想" class="headerlink" title="4.1 多版本协议的核心思想"></a>4.1 多版本协议的核心思想</h4><ul><li>数据库维护每个数据项的多个版本。</li><li><strong>写入</strong>：创建新版本。</li><li><strong>读取</strong>：根据事务的时间戳读取适当的版本。</li></ul><h4 id="4-2-多版本时间戳排序（MVTO）"><a href="#4-2-多版本时间戳排序（MVTO）" class="headerlink" title="4.2 多版本时间戳排序（MVTO）"></a>4.2 多版本时间戳排序（MVTO）</h4><ul><li><p>每个数据项的版本包含：</p><ol><li><strong>内容</strong>：版本的值。</li><li><strong>W-timestamp</strong>：创建该版本的事务时间戳。</li><li><strong>R-timestamp</strong>：读取该版本的最大事务时间戳。</li></ol></li><li><p><strong>规则</strong>：</p><ol><li><strong>读取</strong>：选择满足条件的最新版本。</li><li><strong>写入</strong>：<ul><li>如果<code>TS(Ti) &lt; R-timestamp(Qk)</code>，则回滚事务。</li><li>否则，创建新版本。</li></ul></li></ol></li></ul><p><strong>优点</strong>：</p><ul><li>读取操作永不等待，提高了并发性。</li><li>保证了可串行化。</li></ul><h4 id="4-3-快照隔离（Snapshot-Isolation-SI）"><a href="#4-3-快照隔离（Snapshot-Isolation-SI）" class="headerlink" title="4.3 快照隔离（Snapshot Isolation, SI）"></a>4.3 快照隔离（Snapshot Isolation, SI）</h4><ul><li><p><strong>工作原理</strong>：</p><ul><li>每个事务读取开始时的“快照”数据。</li><li>写操作遵循<strong>第一个提交者获胜（First-Committer-Wins）</strong>规则。</li></ul></li><li><p><strong>优点</strong>：</p><ul><li>读操作不会阻塞，提高了读性能。</li><li>写操作避免冲突。</li></ul></li><li><p><strong>不足</strong>：</p><ul><li>可能导致非串行化调度（如丢失更新）。</li></ul></li></ul><hr><h3 id="15-5-其他并发控制协议"><a href="#15-5-其他并发控制协议" class="headerlink" title="15.5 其他并发控制协议"></a>15.5 其他并发控制协议</h3><h4 id="5-1-图锁协议"><a href="#5-1-图锁协议" class="headerlink" title="5.1 图锁协议"></a>5.1 图锁协议</h4><ul><li><p>基于数据项的部分顺序关系（有向无环图）。</p></li><li><p><strong>规则</strong>：</p><ul><li>事务必须按规定的顺序访问数据。</li></ul></li><li><p><strong>优点</strong>：避免死锁，增加并发性。</p></li><li><p><strong>缺点</strong>：可能需要锁定未访问的数据，增加开销。</p></li></ul><h4 id="5-2-多粒度锁"><a href="#5-2-多粒度锁" class="headerlink" title="5.2 多粒度锁"></a>5.2 多粒度锁</h4><ul><li><p>数据项可分为多种粒度（如数据库→表→记录）。</p></li><li><p><strong>意向锁</strong>：</p><ul><li><strong>IS（意向共享）</strong>：表示将对数据的子节点加共享锁。</li><li><strong>IX（意向排它）</strong>：表示将对数据的子节点加排它锁。</li><li><strong>SIX（共享且意向排它）</strong>：当前节点为共享锁，子节点可能加排它锁。</li></ul></li><li><p><strong>优点</strong>：提高并发性，减少锁管理开销。</p></li></ul><hr><h3 id="15-6-总结"><a href="#15-6-总结" class="headerlink" title="15.6 总结"></a>15.6 总结</h3><p>本章介绍了数据库并发控制的核心机制和协议，包括基于锁的控制、时间戳协议和多版本并发控制。</p><p><strong>重点内容</strong>：</p><ol><li>两阶段锁协议及其扩展（严格2PL、强制2PL）。</li><li>时间戳协议和Thomas写规则。</li><li>多版本控制中的快照隔离（SI）。</li><li>死锁的检测与预防。</li></ol><p><strong>实例分析</strong>：通过多个调度示例，详细阐述了并发控制协议在实际场景中的应用及其优缺点。</p><p><strong>关键思想</strong>：在保证事务ACID特性的基础上，最大化并发性和系统性能。</p><hr><hr><h2 id="第十六章-恢复系统"><a href="#第十六章-恢复系统" class="headerlink" title="第十六章 恢复系统"></a>第十六章 恢复系统</h2><h3 id="16-1-恢复系统的目标"><a href="#16-1-恢复系统的目标" class="headerlink" title="16.1 恢复系统的目标"></a>16.1 恢复系统的目标</h3><ul><li><strong>核心问题</strong>：在系统发生故障时，如何保证数据库的一致性和事务的ACID特性（原子性、一致性、隔离性、持久性）。</li><li><strong>恢复算法的两部分</strong>：<ol><li><strong>正常事务处理期间的准备</strong>：<ul><li>记录足够的信息以便在故障发生后能够恢复。</li></ul></li><li><strong>故障后的恢复操作</strong>：<ul><li>将数据库恢复到一致状态。</li></ul></li></ol></li></ul><hr><h3 id="16-2-故障分类"><a href="#16-2-故障分类" class="headerlink" title="16.2 故障分类"></a>16.2 故障分类</h3><ol><li><p><strong>事务故障</strong>：</p><ul><li><strong>逻辑错误</strong>：由于内部错误（如违反约束条件）导致事务无法完成。</li><li><strong>系统错误</strong>：如死锁，数据库系统需要终止某个事务。</li></ul></li><li><p><strong>系统崩溃</strong>：</p><ul><li>由于硬件或软件故障导致系统崩溃。</li><li><strong>假设</strong>：非易失性存储的数据不会被系统崩溃破坏（<strong>Fail-Stop假设</strong>）。</li></ul></li><li><p><strong>磁盘故障</strong>：</p><ul><li>硬盘损坏或部分数据丢失。</li><li>使用校验和检测磁盘故障。</li></ul></li></ol><hr><h3 id="16-3-存储结构"><a href="#16-3-存储结构" class="headerlink" title="16.3 存储结构"></a>16.3 存储结构</h3><ol><li><p><strong>易失性存储</strong>：</p><ul><li>不会在系统崩溃后保留数据。</li><li>例如：主存、缓存。</li></ul></li><li><p><strong>非易失性存储</strong>：</p><ul><li>系统崩溃后保留数据。</li><li>例如：磁盘、闪存。</li></ul></li><li><p><strong>稳定存储</strong>：</p><ul><li>理想化的存储，能够抵抗所有故障。</li><li><strong>实现方式</strong>：保持多个副本（如RAID系统）。</li></ul></li></ol><hr><h3 id="16-4-日志和恢复机制"><a href="#16-4-日志和恢复机制" class="headerlink" title="16.4 日志和恢复机制"></a>16.4 日志和恢复机制</h3><h4 id="4-1-日志记录"><a href="#4-1-日志记录" class="headerlink" title="4.1 日志记录"></a>4.1 日志记录</h4><ul><li><strong>日志的作用</strong>：记录事务的操作，以便在系统崩溃后进行恢复。</li><li><strong>日志记录方式</strong>：<ol><li><strong>事务开始</strong>：<code>&lt;Ti start&gt;</code>。</li><li><strong>写操作</strong>：<code>&lt;Ti, X, V1, V2&gt;</code>，记录数据项<code>X</code>的旧值<code>V1</code>和新值<code>V2</code>。</li><li><strong>事务提交</strong>：<code>&lt;Ti commit&gt;</code>。</li></ol></li></ul><p><strong>例子</strong>：<br>事务<code>T0</code>将$50从账户A转移到账户B：</p><ol><li><p>日志记录：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;T0 start&gt;</span><br><span class="line">&lt;T0, A, 1000, 950&gt;</span><br><span class="line">&lt;T0, B, 2000, 2050&gt;</span><br><span class="line">&lt;T0 commit&gt;</span><br></pre></td></tr></table></figure></li><li><p>如果系统崩溃：</p><ul><li>若<code>&lt;T0 commit&gt;</code>存在，则需要重做（Redo）。</li><li>若<code>&lt;T0 commit&gt;</code>不存在，则需要回滚（Undo）。</li></ul></li></ol><h4 id="4-2-Undo和Redo操作"><a href="#4-2-Undo和Redo操作" class="headerlink" title="4.2 Undo和Redo操作"></a>4.2 Undo和Redo操作</h4><ol><li><p><strong>Undo（回滚）</strong>：</p><ul><li>将事务所做的修改恢复为旧值。</li><li>写入补偿日志记录：<code>&lt;Ti, X, V1&gt;</code>。</li></ul></li><li><p><strong>Redo（重做）</strong>：</p><ul><li>将事务提交的修改重新应用于数据库。</li></ul></li></ol><p><strong>恢复规则</strong>：</p><ul><li>需要<strong>Undo</strong>：日志中有<code>&lt;Ti start&gt;</code>但没有<code>&lt;Ti commit&gt;</code>。</li><li>需要<strong>Redo</strong>：日志中有<code>&lt;Ti start&gt;</code>且有<code>&lt;Ti commit&gt;</code>。</li></ul><h4 id="4-3-恢复算法"><a href="#4-3-恢复算法" class="headerlink" title="4.3 恢复算法"></a>4.3 恢复算法</h4><ol><li><p><strong>Redo阶段</strong>：</p><ul><li>从最近的检查点开始，向前扫描日志，对所有提交的事务重做操作。</li></ul></li><li><p><strong>Undo阶段</strong>：</p><ul><li>从日志末尾向后扫描，对未完成的事务进行回滚操作。</li></ul></li></ol><p><strong>示例</strong>：<br>假设以下日志记录：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;checkpoint L=&#123;T0, T1&#125;&gt;</span><br><span class="line">&lt;T0 start&gt;</span><br><span class="line">&lt;T0, A, 1000, 950&gt;</span><br><span class="line">&lt;T0, B, 2000, 2050&gt;</span><br><span class="line">&lt;T1 start&gt;</span><br><span class="line">&lt;T1, C, 700, 600&gt;</span><br><span class="line">&lt;T0 commit&gt;</span><br></pre></td></tr></table></figure><ul><li>恢复步骤：<ol><li>Redo：重做<code>T0</code>的操作，因为<code>T0</code>已提交。</li><li>Undo：回滚<code>T1</code>的操作，因为<code>T1</code>未提交。</li></ol></li></ul><hr><h3 id="16-5-检查点（Checkpoint）"><a href="#16-5-检查点（Checkpoint）" class="headerlink" title="16.5 检查点（Checkpoint）"></a>16.5 检查点（Checkpoint）</h3><h4 id="5-1-检查点的作用"><a href="#5-1-检查点的作用" class="headerlink" title="5.1 检查点的作用"></a>5.1 检查点的作用</h4><ul><li>检查点减少了恢复时需要处理的日志记录长度。</li><li><strong>步骤</strong>：<ol><li>将内存中的日志记录写入稳定存储。</li><li>将修改过的缓冲区块写回磁盘。</li><li>写入<code>&lt;checkpoint L&gt;</code>日志记录，其中<code>L</code>是所有活跃事务的列表。</li></ol></li></ul><h4 id="5-2-恢复时的优化"><a href="#5-2-恢复时的优化" class="headerlink" title="5.2 恢复时的优化"></a>5.2 恢复时的优化</h4><ul><li>从最近的检查点开始扫描日志。</li><li>只需要处理检查点之后开始的事务，之前的日志可被忽略。</li></ul><p><strong>例子</strong>：<br>日志：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;checkpoint L=&#123;T1, T2&#125;&gt;</span><br><span class="line">&lt;T1 start&gt;</span><br><span class="line">&lt;T1, A, 100, 200&gt;</span><br><span class="line">&lt;T1 commit&gt;</span><br><span class="line">&lt;T2 start&gt;</span><br><span class="line">&lt;T2, B, 300, 400&gt;</span><br></pre></td></tr></table></figure><ul><li><code>T1</code>已提交，无需处理。</li><li><code>T2</code>尚未完成，需要回滚。</li></ul><hr><h3 id="16-6-Write-Ahead-Logging-WAL"><a href="#16-6-Write-Ahead-Logging-WAL" class="headerlink" title="16.6 Write-Ahead Logging (WAL)"></a>16.6 Write-Ahead Logging (WAL)</h3><ul><li><strong>规则</strong>：写入数据块之前，必须先将对应的日志记录写入稳定存储。</li><li><strong>目的</strong>：保证即使系统崩溃，也能通过日志恢复数据。</li></ul><hr><h3 id="16-7-数据库缓冲管理"><a href="#16-7-数据库缓冲管理" class="headerlink" title="16.7 数据库缓冲管理"></a>16.7 数据库缓冲管理</h3><ul><li><strong>No-Force策略</strong>：事务提交时，不强制将数据块写回磁盘。</li><li><strong>Steal策略</strong>：允许未提交事务修改的数据块写回磁盘，但必须遵守WAL规则。</li></ul><p><strong>步骤</strong>：</p><ol><li>写入日志记录。</li><li>刷新日志到稳定存储。</li><li>将数据块写回磁盘。</li></ol><hr><h3 id="16-8-模糊检查点（Fuzzy-Checkpointing）"><a href="#16-8-模糊检查点（Fuzzy-Checkpointing）" class="headerlink" title="16.8 模糊检查点（Fuzzy Checkpointing）"></a>16.8 模糊检查点（Fuzzy Checkpointing）</h3><ul><li><strong>避免长时间中断</strong>：允许事务在检查点期间继续运行。</li><li><strong>步骤</strong>：<ol><li>暂停更新，写入<code>&lt;checkpoint L&gt;</code>日志记录。</li><li>记录所有修改过的缓冲区块。</li><li>恢复更新，将缓冲区块逐步写回磁盘。</li></ol></li></ul><hr><h3 id="16-9-远程备份系统"><a href="#16-9-远程备份系统" class="headerlink" title="16.9 远程备份系统"></a>16.9 远程备份系统</h3><h4 id="9-1-目的"><a href="#9-1-目的" class="headerlink" title="9.1 目的"></a>9.1 目的</h4><ul><li>提供高可用性，即使主站点发生故障，事务处理仍可在备份站点继续。</li></ul><h4 id="9-2-工作原理"><a href="#9-2-工作原理" class="headerlink" title="9.2 工作原理"></a>9.2 工作原理</h4><ol><li>主站点将日志记录传输到备份站点。</li><li>备份站点应用日志更新本地数据库。</li><li>主站点故障后，备份站点接管事务处理。</li></ol><h4 id="9-3-提交策略"><a href="#9-3-提交策略" class="headerlink" title="9.3 提交策略"></a>9.3 提交策略</h4><ul><li><strong>One-Safe</strong>：主站点提交后即可返回结果，但可能导致更新丢失。</li><li><strong>Two-Very-Safe</strong>：主备站点同时记录提交，可靠但延迟高。</li><li><strong>Two-Safe</strong>：在主站点和备份站点之间权衡性能和可靠性。</li></ul><hr><h3 id="16-10-总结"><a href="#16-10-总结" class="headerlink" title="16.10 总结"></a>16.10 总结</h3><p>本章详细讲解了数据库恢复的核心机制，包括日志记录、Undo&#x2F;Redo操作、检查点和远程备份系统。通过具体的例子说明了如何在事务失败或系统崩溃后恢复数据库的一致性。重难点如下：</p><ul><li><strong>日志记录与WAL规则</strong>：日志是恢复的核心，必须首先写入稳定存储。</li><li><strong>检查点的优化作用</strong>：减少日志扫描的范围，加速恢复。</li><li><strong>恢复算法的两个阶段</strong>：Redo和Undo。</li><li><strong>远程备份系统</strong>：提高系统的可用性和容错能力。</li></ul><p>通过这些机制，数据库系统能够在故障后快速恢复，同时保证事务的ACID特性。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL Server </tag>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Marcel Proust</title>
      <link href="/2024/11/24/Marcel_Proust/"/>
      <url>/2024/11/24/Marcel_Proust/</url>
      
        <content type="html"><![CDATA[<p><strong>前半生出入社交名利场  后半生缠绵病榻；</strong></p><p><strong>长期遭受慢性失眠症的折磨  他用这些漫漫长夜来追忆逝水年华。</strong></p><h3 id="以笔绘梦，以梦织生"><a href="#以笔绘梦，以梦织生" class="headerlink" title="以笔绘梦，以梦织生"></a>以笔绘梦，以梦织生</h3><h4 id="一、晨曦初照：贵族之子的文学萌芽"><a href="#一、晨曦初照：贵族之子的文学萌芽" class="headerlink" title="一、晨曦初照：贵族之子的文学萌芽"></a>一、晨曦初照：贵族之子的文学萌芽</h4><p>在19世纪末的巴黎，一座宏伟的宅邸内，诞生了一位日后将照亮法国乃至世界文坛的星辰——马塞尔·普鲁斯特。1871年的冬日，随着一阵清脆的啼哭，普鲁斯特家族迎来了他们的长子，法国迎来了一个注定要在文学的天空中璀璨夺目的灵魂。</p><p>普鲁斯特自幼便沐浴在浓厚的文化氛围之中，父亲阿德里安·普鲁斯特是医学界的佼佼者，母亲让娜·魏尔则以其优雅与智慧，为家庭增添了一抹不可磨灭的贵族气质。然而，命运似乎总爱与天才开玩笑，小小的普鲁斯特在童年的阳光中，却早早地埋下了哮喘的病根，这成为了他日后生命中的一抹暗影，却也意外地滋养了他敏感而细腻的心灵。</p><h4 id="二、青春序曲：社交场的翩翩公子"><a href="#二、青春序曲：社交场的翩翩公子" class="headerlink" title="二、青春序曲：社交场的翩翩公子"></a>二、青春序曲：社交场的翩翩公子</h4><p>随着年岁的增长，普鲁斯特踏入了巴黎的社交舞台，成为了一名风度翩翩的青年才俊。在贡多塞中学的求学岁月里，他不仅汲取了知识的甘露，更在沙龙中结识了诸多文学与艺术界的精英。法朗士等文学巨匠的指引，让他对文学有了更深的感悟与追求。那时的他，如同一位游走于名利场中的诗人，用心灵之眼捕捉着每一个瞬间，为日后的创作积累了无尽的素材与灵感。</p><p>然而，普鲁斯特的内心始终是孤独的，他的敏感与内向让他在喧嚣的社交场中显得格格不入。哮喘的困扰更是让他不得不时常远离尘嚣，退回到自己的小天地中，那里有书、有音乐，更有他对生活的无尽遐想与憧憬。</p><h4 id="三、午夜梦回：文学之路的艰难跋涉"><a href="#三、午夜梦回：文学之路的艰难跋涉" class="headerlink" title="三、午夜梦回：文学之路的艰难跋涉"></a>三、午夜梦回：文学之路的艰难跋涉</h4><p>当普鲁斯特决定以笔为剑，探索人性的深渊时，他踏上了一条漫长而艰辛的旅程。《欢乐与时日》的出版，是他文学探索的初次尝试，但真正的辉煌，还需等待那部耗尽他心血与生命的《追忆似水年华》。</p><p>从1906年的初步构思，到1913年框架初定，再到逝世前的最终定稿，《追忆似水年华》(À la recherche du temps perdu)的诞生，是普鲁斯特对时间与记忆、爱与失去的一次深刻探索。他以独特的意识流手法，将主人公马塞尔的回忆与幻想交织成一幅幅流动的画卷，带领读者穿梭于过去与现在、真实与梦境之间。那些看似冗长复杂的句子，实则蕴含着普鲁斯特对人性最细腻的剖析与最真挚的情感。</p><h4 id="四、黄昏之歌：病榻上的文学传奇"><a href="#四、黄昏之歌：病榻上的文学传奇" class="headerlink" title="四、黄昏之歌：病榻上的文学传奇"></a>四、黄昏之歌：病榻上的文学传奇</h4><p>晚年的普鲁斯特，被哮喘病魔紧紧缠绕，不得不长期卧床。然而，正是这段看似绝望的时光，成就了他文学上的巅峰。在病榻上，他以一种近乎超然的姿态，继续编织着《追忆似水年华》的梦幻篇章。每一个字、每一句话，都凝聚着他对生命的深刻理解与对艺术的无限热爱。</p><p>当这部鸿篇巨制终于面世，它犹如一颗璀璨夺目的新星，在法国乃至世界文坛的广阔天幕上，绽放出了前所未有的光芒，照亮了无数读者的心灵深处。普鲁斯特的名字，也因此被镌刻在了文学的殿堂之上，成为了一段不朽的传奇，永远闪耀在人类文化的长河之中。</p><h4 id="五、星河长明：普鲁斯特的永恒光辉"><a href="#五、星河长明：普鲁斯特的永恒光辉" class="headerlink" title="五、星河长明：普鲁斯特的永恒光辉"></a>五、星河长明：普鲁斯特的永恒光辉</h4><p>普鲁斯特的离世，是文学界的一大损失，但他的精神与作品，却如同璀璨的星河，永远照耀着后来者的道路。他的《追忆似水年华》，不仅开创了意识流文学的先河，更为后世留下了无尽的思考与启示。</p><p>普鲁斯特教会我们，生活不仅仅是眼前的苟且，更是那些被遗忘的瞬间、被深埋的情感，以及那些看似平凡却充满意义的日常。他用文字捕捉了时间的流逝，让我们在回忆中找到了永恒。</p><p>在普鲁斯特的世界里，每一个读者都能找到属于自己的影子，那份对过去的怀念、对现在的珍惜、对未来的憧憬，都化作了文字中的温暖与力量。他的一生，虽然短暂且充满病痛，但他用文字书写了不朽的篇章，成为了文学史上永恒的璀璨星辰。</p>]]></content>
      
      
      <categories>
          
          <category> Literary giants </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Marcel Proust </tag>
            
            <tag> In Search of Lost Time </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neural Network</title>
      <link href="/2024/11/22/Neural_Network/"/>
      <url>/2024/11/22/Neural_Network/</url>
      
        <content type="html"><![CDATA[<h2 id="神经网络简介"><a href="#神经网络简介" class="headerlink" title="神经网络简介"></a>神经网络简介</h2><h3 id="什么是神经网络"><a href="#什么是神经网络" class="headerlink" title="什么是神经网络"></a>什么是神经网络</h3><p>神经网络是一种模仿人脑神经系统工作原理的计算模型，由大量的相互连接的节点（神经元）组成。这些节点通过调整连接强度（权重）来学习并执行各种复杂的任务，如图像识别、语音处理、自然语言处理等。神经网络的结构包括输入层、隐藏层和输出层，通过反向传播算法不断优化权重，最终得到一个能够很好完成特定任务的模型。</p><h3 id="神经网络的发展历史"><a href="#神经网络的发展历史" class="headerlink" title="神经网络的发展历史"></a>神经网络的发展历史</h3><p>神经网络的概念最早可以追溯到20世纪40年代，当时麦卡洛克和皮茨提出了最早的神经网络模型——感知机。此后，神经网络经历了几个重要的发展阶段：</p><ul><li>1980年代：反向传播算法的提出，使得多层神经网络的训练成为可能。</li><li>1990年代：支持向量机（SVM）的兴起，一度对神经网络构成挑战。</li><li>2000年代：GPU的出现，大幅提高了神经网络的训练速度，深度学习开始流行。</li><li>近年来：随着计算能力的不断增强和大规模数据的积累，神经网络模型不断发展，广泛应用于各个领域。</li></ul><h3 id="神经网络的组成部分"><a href="#神经网络的组成部分" class="headerlink" title="神经网络的组成部分"></a>神经网络的组成部分</h3><p>神经网络主要由以下几个部分组成：</p><ul><li>输入层：接收输入数据。</li><li>隐藏层：进行特征提取和模式识别。</li><li>输出层：产生输出结果。</li><li>连接权重：连接神经元之间的权重，通过训练不断调整。</li><li>激活函数：决定神经元的输出，增加模型的非线性。</li><li>损失函数：定义预测值与真实值之间的差距。</li><li>优化算法：不断优化网络参数，如梯度下降算法。</li></ul><h3 id="神经网络与LLM的关系"><a href="#神经网络与LLM的关系" class="headerlink" title="神经网络与LLM的关系"></a>神经网络与LLM的关系</h3><p>LLM的兴起进一步推动了神经网络技术在自然语言处理方面的应用。LLM本质上也是基于神经网络的模型，利用海量文本数据进行预训练，学习到了强大的自然语言理解和生成能力。常用的神经网络架构如Transformer，以及新兴架构如Megatron等，都被用于构建LLM。这些模型在各种下游任务上表现优异，推动了神经网络在实际应用中的广泛应用。</p><h2 id="NN分类及应用"><a href="#NN分类及应用" class="headerlink" title="NN分类及应用"></a>NN分类及应用</h2><p>神经网络有多种不同的分类方式，主要包括：</p><p><strong>按结构分</strong>：</p><ul><li>前馈神经网络：最简单的神经网络结构，信息从输入层向输出层单向传播。</li><li>循环神经网络（recurrent neural network, RNN）：能够处理序列数据，捕捉数据中的时序信息。</li><li>卷积神经网络（convolutional neural network, CNN）：特别适用于处理图像数据，通过卷积层和池化层提取图像特征。</li><li>递归神经网络：处理树形或图形结构的数据，如自然语言处理中的句法分析。</li></ul><p><strong>按学习方式分</strong>：</p><ul><li>监督学习神经网络：需要标记数据进行训练，如图像分类、语音识别等。</li><li>无监督学习神经网络：不需要标记数据，如聚类、降维等。</li><li>强化学习神经网络：通过与环境交互来学习最佳策略，如机器人控制、游戏AI等。</li></ul><p><strong>按应用领域分</strong>：</p><ul><li>图像识别&#x2F;计算机视觉：如人脸识别、自动驾驶等。</li><li>自然语言处理：如机器翻译、情感分析等。</li><li>语音识别：如语音助手、语音搜索等。</li><li>推荐系统：如电商推荐、视频推荐等。</li><li>金融&#x2F;股票预测：如市场趋势分析、风险管理等。</li><li>医疗诊断：如疾病预测、影像识别等。</li><li>机器人控制：如运动规划、自主导航等。</li></ul><h3 id="前馈神经网络"><a href="#前馈神经网络" class="headerlink" title="前馈神经网络"></a>前馈神经网络</h3><p><strong>一、定义</strong></p><p>前馈神经网络（Feed-Forward Neural Network，简称FNN）是一种基本且广泛应用的人工神经网络结构。它是最简单的一种神经网络，其各神经元分层排列，每个神经元只与前一层的神经元相连，接收前一层的输出，并输出给下一层，各层间没有反馈。</p><p><strong>二、结构</strong></p><p>前馈神经网络主要由输入层、隐藏层和输出层组成：</p><ol><li><strong>输入层</strong>：从外部接收输入数据，并将其传输给网络的第一层。</li><li><strong>隐藏层</strong>：对输入信号进行处理和特征提取，可以有一层或多层。每个隐层由多个神经元（或节点）组成，并且与前一层和后一层的神经元全连接。</li><li><strong>输出层</strong>：产生最终的输出结果。输出层的神经元个数取决于问题的类型，例如，对于二分类问题，输出层通常只有一个神经元；对于多分类问题，输出层的神经元个数等于类别的数量。</li></ol><p><strong>三、工作原理</strong></p><ol><li><strong>输入数据</strong>：首先进入输入层。</li><li><strong>权重和偏置</strong>：输入数据通过权重和偏置传递到隐藏层。权重控制信号在神经元之间的传递强度，偏置用于调整输入信号的加权总和。</li><li><strong>隐藏层处理</strong>：隐藏层中的节点对输入进行加权求和，并通过激活函数进行非线性转换。</li><li><strong>输出层输出</strong>：输出层接收到经过隐藏层处理的信号，并产生最终的输出。</li></ol><p><strong>四、激活函数</strong></p><p>激活函数在人工神经网络中起着至关重要的作用，它们负责将神经元的输入映射到输出端，并引入非线性因素，使得神经网络能够学习和模拟复杂的函数。常见的激活函数包括：</p><ol><li><strong>Sigmoid函数</strong>：输出范围在（0,1）之间，适合用于二元分类问题。它连续且可微，但在函数的两端导数接近于0，可能导致梯度消失问题。</li><li><strong>Tanh函数</strong>：输出范围在（-1,1）之间，具有零中心化特性，可以加速神经网络的训练过程。与Sigmoid函数一样，Tanh函数也是连续且可微的，但在深层网络中也可能遇到梯度消失的问题。</li><li><strong>ReLU函数</strong>：对于所有正输入值，ReLU函数的输出等于输入值本身，这保持了其线性特性，避免了Sigmoid和Tanh函数在输入值较大或较小时的饱和问题。ReLU函数计算效率高，但在输入为负数时，输出恒为0，可能导致“死神经元”问题。</li><li><strong>Leaky ReLU和PReLU</strong>：作为ReLU的变体，它们在输入为负数时引入非零斜率，以缓解“神经元死亡”问题。</li></ol><p><strong>五、训练过程</strong></p><p>前馈神经网络的训练过程通常使用反向传播算法，该算法基于梯度下降法，通过计算损失函数对网络中的参数的导数来更新参数，以使网络的预测结果与实际结果更加接近。反向传播分为两个步骤：</p><ol><li><strong>前向传播</strong>：输入数据通过网络的每一层进行计算，得到预测结果。</li><li><strong>反向传播</strong>：通过比较预测结果与实际结果之间的差异，计算损失函数。然后，从输出层开始，使用链式法则计算损失函数对每个层中的权重和偏置的导数，并使用梯度下降法来更新每个参数，减小损失函数的值。</li></ol><p><strong>六、应用场景</strong></p><p>前馈神经网络适用于许多任务，如分类、回归和模式识别等。它还可以与其他模型结合使用，如CNN+Transformer，以进一步提高模型的性能。</p><p>综上所述，前馈神经网络是一种基本且强大的人工神经网络结构，通过多层连接的神经元处理输入数据并生成输出。它在许多领域都有广泛的应用，并随着技术的不断发展而不断完善。</p><h3 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h3><p>RNN是一种专门用于处理序列数据的神经网络结构，它能够在序列的演进方向上进行递归，并通过所有节点（循环单元）的链式连接来捕捉序列中的时序信息和语义信息。RNN的提出基于记忆模型的想法，期望网络能够记住前面出现的特征，并依据这些特征推断后续的结果。</p><p>RNN的核心在于其循环结构，这一结构允许信息在不同时间步之间传递。在每个时间步，RNN接收当前的输入数据（如一个词的嵌入表示）和前一个时间步的隐藏状态，然后生成一个新的隐藏状态。这个新的隐藏状态不仅包含了当前时间步的信息，还融合了之前所有时间步的信息，因此RNN能够捕捉到序列数据中的上下文信息。</p><p>RNN的基本结构包括输入层、隐藏层和输出层。其中，隐藏层的状态会随时间步更新，并作为下一时间步的输入之一。这种循环连接使得RNN具有记忆能力，能够捕捉序列中的长距离依赖关系。</p><p>RNN的隐藏状态更新公式为：</p><p>$$<br>h_t &#x3D; \text{tanh}(W_{xh}x_t + W_{hh}h_{t-1} + b_h)<br>$$</p><p>其中，$x_t$是当前时间步的输入，$h_t$是当前时间步的隐藏状态，$h_{t-1}$是前一时间步的隐藏状态，$W_{xh}$和$W_{hh}$是权重矩阵，$b_h$是偏置项，$\text{tanh}$是激活函数。</p><p>RNN的权重参数是共享的，即每个时间步都使用相同的权重矩阵。这种权重共享机制可以确保不同时间步的数据都使用相同的模型进行处理，从而保持模型的参数数量相对较小。同时，权重共享也使得RNN能够处理任意长度的序列数据，因为无论序列长度如何变化，模型的结构和参数都保持不变。</p><p>RNN的前向传播过程是按照时间步的顺序逐步进行的。在每个时间步，根据当前的输入和前一时间步的隐藏状态计算出新的隐藏状态和输出。</p><p>具体过程如下：</p><p>输入层接收数据：在每个时间步，RNN的输入层接收当前的输入数据。这个数据可以是序列中的一个元素，如文本中的一个词或时间序列中的一个数据点。<br>隐藏层计算隐藏状态：隐藏层接收当前的输入数据和前一个时间步的隐藏状态，并通过权重矩阵和激活函数计算出新的隐藏状态。这个新的隐藏状态不仅包含了当前时间步的信息，还融合了之前所有时间步的信息。<br>输出层生成输出：输出层根据当前的隐藏状态和权重矩阵计算出输出。这个输出可以是序列中的下一个元素、分类结果或其他任务相关的输出。<br>而反向传播过程则是为了更新模型的权重参数，以最小化损失函数。在反向传播过程中，需要计算损失函数关于每个时间步隐藏状态和权重的梯度，并使用这些梯度来更新权重参数。</p><h4 id="一、按输入输出结构分类"><a href="#一、按输入输出结构分类" class="headerlink" title="一、按输入输出结构分类"></a>一、按输入输出结构分类</h4><h5 id="1-N-vs-N-RNN"><a href="#1-N-vs-N-RNN" class="headerlink" title="1. N vs N - RNN"></a>1. N vs N - RNN</h5><ul><li><strong>结构特点</strong>：输入和输出序列是等长的。每个时间步的输入都对应一个输出。</li><li><strong>工作原理</strong>：网络在每个时间步都接收输入并产生输出，同时隐藏状态在时间步之间传递。</li><li><strong>应用场景</strong>：由于输入输出等长，适用于生成等长度的合辙诗句、文本对文本的对齐等任务。</li></ul><h5 id="2-N-vs-1-RNN"><a href="#2-N-vs-1-RNN" class="headerlink" title="2. N vs 1 - RNN"></a>2. N vs 1 - RNN</h5><ul><li><strong>结构特点</strong>：输入是一个序列，输出是一个单独的值或向量。</li><li><strong>工作原理</strong>：网络接收序列输入，并在序列处理完毕后输出一个总结性的结果。</li><li><strong>应用场景</strong>：情感分析（整个句子的情感倾向）、序列分类（如文本分类、语音识别中的词识别）等。</li></ul><h5 id="3-1-vs-N-RNN"><a href="#3-1-vs-N-RNN" class="headerlink" title="3. 1 vs N - RNN"></a>3. 1 vs N - RNN</h5><ul><li><strong>结构特点</strong>：输入不是序列，而是一个单独的值或向量，输出是一个序列。</li><li><strong>工作原理</strong>：网络根据单个输入生成一个序列输出。</li><li><strong>应用场景</strong>：图像描述生成（根据图像生成描述性文本）、音乐生成（根据一个主题或风格生成音乐序列）等。</li></ul><h5 id="4-N-vs-M-RNN（seq2seq）"><a href="#4-N-vs-M-RNN（seq2seq）" class="headerlink" title="4. N vs M - RNN（seq2seq）"></a>4. N vs M - RNN（seq2seq）</h5><ul><li><strong>结构特点</strong>：输入和输出序列的长度可以不同。通常包括编码器和解码器两部分。</li><li><strong>工作原理</strong>：编码器将输入序列编码为一个固定长度的向量（也称为上下文向量或隐藏状态），解码器则根据这个向量生成输出序列。</li><li><strong>应用场景</strong>：机器翻译（将一种语言的句子翻译成另一种语言）、文本摘要（将长文本压缩为短摘要）、问答系统（根据问题生成答案）等。</li></ul><h4 id="二、按内部构造分类"><a href="#二、按内部构造分类" class="headerlink" title="二、按内部构造分类"></a>二、按内部构造分类</h4><h5 id="1-传统RNN"><a href="#1-传统RNN" class="headerlink" title="1. 传统RNN"></a>1. 传统RNN</h5><ul><li><strong>结构特点</strong>：隐藏层的状态是循环的，能够保存和传递之前时间步的信息。</li><li><strong>工作原理</strong>：在每个时间步，网络根据当前输入和前一时刻的隐藏状态计算当前隐藏状态，并据此产生输出。</li><li><strong>优缺点</strong>：能够处理序列数据，但处理长序列时容易遇到梯度消失或梯度爆炸问题。</li></ul><h5 id="2-LSTM（长短期记忆网络）"><a href="#2-LSTM（长短期记忆网络）" class="headerlink" title="2. LSTM（长短期记忆网络）"></a>2. LSTM（长短期记忆网络）</h5><ul><li><strong>结构特点</strong>：引入特殊的记忆单元（LSTM单元），包括遗忘门、输入门、输出门和细胞状态。</li><li><strong>工作原理</strong>：通过门控机制控制信息的流动和更新，解决梯度消失或梯度爆炸问题。</li><li><strong>优点</strong>：能够学习到长距离的时序依赖关系。</li></ul><h5 id="3-GRU（门控循环单元）"><a href="#3-GRU（门控循环单元）" class="headerlink" title="3. GRU（门控循环单元）"></a>3. GRU（门控循环单元）</h5><ul><li><strong>结构特点</strong>：LSTM的简化版本，只有两个门：更新门和重置门。</li><li><strong>工作原理</strong>：通过更新门和重置门控制信息的流动和更新。</li><li><strong>优点</strong>：在保证性能的同时降低了模型的复杂度和计算成本。</li></ul><h5 id="4-Bi-RNN（双向循环神经网络）"><a href="#4-Bi-RNN（双向循环神经网络）" class="headerlink" title="4. Bi-RNN（双向循环神经网络）"></a>4. Bi-RNN（双向循环神经网络）</h5><ul><li><strong>结构特点</strong>：由两个独立的RNN组成，一个正向处理序列，一个反向处理序列。</li><li><strong>工作原理</strong>：将两个RNN的输出合并或拼接，以获取序列数据的前后文信息。</li><li><strong>优点</strong>：能够捕捉到序列数据中的前后文信息，提高模型的性能。</li></ul><p>综上所述，RNN可以按照输入输出结构和内部构造进行多种分类。每种类型的RNN都有其独特的特点和工作原理，适用于不同的应用场景和任务需求。在实际应用中，可以根据具体任务的需求选择合适的RNN类型。</p><h3 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h3><p>CNN是一种专门用于处理网格数据的神经网络结构，尤其擅长处理图像数据。它通过卷积运算来捕捉图像中的局部特征，并通过池化操作来降低数据的维度和复杂度。CNN的提出基于特征提取的思想，期望网络能够自动学习到图像中的层次化特征表示，从而实现对图像的有效分类、识别和其他相关任务。</p><p>CNN的核心在于其卷积层和池化层，这些层允许网络在输入数据上滑动窗口，并应用卷积核来提取特征。卷积层通过卷积运算将输入数据映射到特征空间，生成特征图。这些特征图包含了输入数据的局部特征信息，并且具有平移不变性。池化层则对特征图进行下采样，降低数据的维度和计算量，同时保留重要的特征信息。</p><p>CNN的基本结构包括输入层、卷积层、池化层、全连接层和输出层。其中，卷积层和池化层交替出现，用于提取和降维特征；全连接层则用于对提取的特征进行分类或回归；输出层则根据任务需求生成最终的输出。</p><p>CNN的卷积运算公式为：</p><p>$$<br>y_{ij} &#x3D; \sum_{m}\sum_{n} x_{i+m,j+n} \cdot k_{mn} + b<br>$$</p><p>其中，$x$是输入数据，$y$是卷积后的特征图，$k$是卷积核，$b$是偏置项，$i$和$j$表示特征图上的位置，$m$和$n$表示卷积核的大小。</p><p>CNN的权重参数是局部连接的，即每个卷积核只与输入数据的一部分区域相连。这种局部连接机制使得CNN能够捕捉到图像中的局部特征，并且具有较少的参数数量。同时，卷积核的权重在输入数据的不同位置上是共享的，这种权重共享机制进一步减少了模型的参数数量，并提高了模型的泛化能力。</p><p>CNN的前向传播过程是按照层次结构逐步进行的。在每个卷积层，网络通过卷积运算生成特征图；在每个池化层，网络对特征图进行下采样；在全连接层，网络对提取的特征进行分类或回归；最后，在输出层生成最终的输出。</p><p>具体过程如下：</p><p>输入层接收数据：CNN的输入层接收图像数据，这些数据可以是原始图像或经过预处理的图像。<br>卷积层提取特征：卷积层通过卷积运算和激活函数（如ReLU）提取输入数据的局部特征，并生成特征图。这些特征图包含了输入数据的层次化特征表示。<br>池化层降维：池化层对特征图进行下采样，降低数据的维度和计算量，同时保留重要的特征信息。常见的池化操作包括最大池化和平均池化。<br>全连接层分类或回归：全连接层接收池化层输出的特征向量，并通过权重矩阵和激活函数进行分类或回归任务。<br>输出层生成输出：输出层根据全连接层的输出生成最终的输出，如分类结果、回归值或其他任务相关的输出。</p><h4 id="一、按网络结构分类"><a href="#一、按网络结构分类" class="headerlink" title="一、按网络结构分类"></a>一、按网络结构分类</h4><h5 id="1-LeNet"><a href="#1-LeNet" class="headerlink" title="1. LeNet"></a>1. LeNet</h5><ul><li><strong>结构特点</strong>：较早的CNN结构，包括卷积层、池化层和全连接层。</li><li><strong>工作原理</strong>：通过卷积和池化操作提取图像特征，并通过全连接层进行分类。</li><li><strong>应用场景</strong>：手写数字识别等简单图像分类任务。</li></ul><h5 id="2-AlexNet"><a href="#2-AlexNet" class="headerlink" title="2. AlexNet"></a>2. AlexNet</h5><ul><li><strong>结构特点</strong>：包含多个卷积层和池化层，以及较大的全连接层。</li><li><strong>工作原理</strong>：通过更深的网络结构提取更复杂的图像特征，提高分类性能。</li><li><strong>应用场景</strong>：大规模图像分类任务，如ImageNet竞赛。</li></ul><h5 id="3-VGG"><a href="#3-VGG" class="headerlink" title="3. VGG"></a>3. VGG</h5><ul><li><strong>结构特点</strong>：采用较小的卷积核（如3x3）和较深的网络结构（如VGG-16、VGG-19）。</li><li><strong>工作原理</strong>：通过堆叠多个小卷积核来提取图像特征，并增加网络的深度以提高性能。</li><li><strong>应用场景</strong>：图像分类、目标检测等任务。</li></ul><h5 id="4-ResNet（残差网络）"><a href="#4-ResNet（残差网络）" class="headerlink" title="4. ResNet（残差网络）"></a>4. ResNet（残差网络）</h5><ul><li><strong>结构特点</strong>：引入残差块，通过跳跃连接解决深层网络的梯度消失问题。</li><li><strong>工作原理</strong>：残差块允许网络学习恒等映射，从而更容易地训练深层网络。</li><li><strong>应用场景</strong>：图像分类、目标检测、图像分割等任务。</li></ul><h5 id="5-DenseNet（密集连接网络）"><a href="#5-DenseNet（密集连接网络）" class="headerlink" title="5. DenseNet（密集连接网络）"></a>5. DenseNet（密集连接网络）</h5><ul><li><strong>结构特点</strong>：每一层都接收来自前面所有层的特征图作为输入。</li><li><strong>工作原理</strong>：通过密集连接实现特征的重用和梯度流动，提高网络的性能。</li><li><strong>应用场景</strong>：图像分类、目标检测、图像生成等任务。</li></ul><h4 id="二、按功能和应用分类"><a href="#二、按功能和应用分类" class="headerlink" title="二、按功能和应用分类"></a>二、按功能和应用分类</h4><h5 id="1-图像分类"><a href="#1-图像分类" class="headerlink" title="1. 图像分类"></a>1. 图像分类</h5><ul><li><strong>结构特点</strong>：通常包含多个卷积层、池化层和全连接层。</li><li><strong>工作原理</strong>：通过卷积和池化操作提取图像特征，并通过全连接层进行分类。</li><li><strong>应用场景</strong>：如ImageNet竞赛、动物识别、植物识别等。</li></ul><h5 id="2-目标检测"><a href="#2-目标检测" class="headerlink" title="2. 目标检测"></a>2. 目标检测</h5><ul><li><strong>结构特点</strong>：在图像分类的基础上增加区域候选网络（RPN）或YOLO等检测头。</li><li><strong>工作原理</strong>：通过卷积层提取特征，并通过检测头生成目标的位置和类别信息。</li><li><strong>应用场景</strong>：自动驾驶、人脸识别、安防监控等。</li></ul><h5 id="3-图像分割"><a href="#3-图像分割" class="headerlink" title="3. 图像分割"></a>3. 图像分割</h5><ul><li><strong>结构特点</strong>：采用全卷积网络（FCN）或U-Net等结构。</li><li><strong>工作原理</strong>：通过卷积层提取特征，并通过上采样操作恢复图像的分辨率，实现像素级别的分类。</li><li><strong>应用场景</strong>：医学影像分析、自动驾驶中的道路识别、遥感图像分析等。</li></ul><h5 id="4-图像生成"><a href="#4-图像生成" class="headerlink" title="4. 图像生成"></a>4. 图像生成</h5><ul><li><strong>结构特点</strong>：采用生成对抗网络（GAN）、变分自编码器（VAE）等结构。</li><li><strong>工作原理</strong>：通过生成器和判别器的对抗训练，生成逼真的图像或视频。</li><li><strong>应用场景</strong>：图像修复、图像超分辨率、视频生成等。</li></ul><p>综上所述，CNN可以按照网络结构和功能应用进行多种分类。每种类型的CNN都有其独特的特点和工作原理，适用于不同的应用场景和任务需求。在实际应用中，可以根据具体任务的需求选择合适的CNN类型。</p><h3 id="递归神经网络（Recursive-Neural-Network-RecNN）"><a href="#递归神经网络（Recursive-Neural-Network-RecNN）" class="headerlink" title="递归神经网络（Recursive Neural Network, RecNN）"></a>递归神经网络（Recursive Neural Network, RecNN）</h3><p>递归神经网络是一种专门用于处理具有层次结构或树形结构数据的神经网络结构。与循环神经网络（RNN）不同，递归神经网络通过递归地应用相同的网络结构来处理不同层次的输入数据，从而能够捕捉数据中的层次信息和结构信息。递归神经网络在自然语言处理、图像解析和其他涉及层次结构数据的任务中表现出色。</p><p>递归神经网络的核心在于其递归结构和信息传递机制。这些结构允许网络在输入数据的层次结构上递归地展开，并通过节点间的信息传递来捕捉层次关系。每个节点都代表一个递归神经网络的实例，它接收来自其子节点的信息，并处理这些信息以生成输出，该输出随后被传递给其父节点。这种递归机制使得网络能够处理任意深度的层次结构数据。</p><p>递归神经网络的基本结构包括输入层、递归层（或称为隐藏层，但在这里强调其递归性质）和输出层。其中，递归层是核心部分，它负责在层次结构上递归地处理数据。输入层接收层次结构数据的根节点或初始节点作为输入，而输出层则根据任务需求生成最终的输出，如分类结果、解析树或其他相关输出。</p><p>递归神经网络的信息传递过程是通过节点间的连接实现的。每个节点都维护一个内部状态，该状态用于存储从子节点接收到的信息以及节点自身的处理结果。当处理一个节点时，网络会将其子节点的输出作为输入，并通过递归层的处理来更新节点的内部状态。然后，该状态被用于生成节点的输出，该输出随后被传递给其父节点。</p><p>具体过程如下：</p><ol><li><p><strong>输入层接收数据</strong>：递归神经网络的输入层接收具有层次结构的数据，如解析树、语法树或其他形式的树形结构数据。</p></li><li><p><strong>递归层处理数据</strong>：在递归层中，网络对每个节点进行递归处理。对于每个节点，网络会将其子节点的输出作为输入，并通过递归神经网络的运算来更新节点的内部状态。这个状态包含了从子节点接收到的信息以及节点自身的处理结果。然后，网络使用该状态来生成节点的输出。</p></li><li><p><strong>输出层生成输出</strong>：在输出层中，网络根据递归层生成的节点输出来生成最终的输出。这个输出可以是分类结果、解析树的结构或其他与任务相关的输出。</p></li></ol><p>递归神经网络在处理具有层次结构的数据时具有显著的优势。它们能够捕捉数据中的层次关系和结构信息，从而实现对数据的更深入理解。然而，递归神经网络也面临一些挑战，如梯度消失或爆炸问题，这可能导致网络难以训练。为了解决这个问题，研究人员提出了多种改进方法，如使用门控机制、引入注意力机制或采用更复杂的网络结构。</p><p>尽管递归神经网络在自然语言处理和其他涉及层次结构数据的任务中取得了显著成果，但它们的应用仍然受到一些限制。例如，对于非常深的层次结构数据，递归神经网络可能会面临计算复杂性和内存消耗的挑战。此外，由于递归神经网络的结构是树形的，它们可能不适用于处理具有循环或网状结构的数据。</p><p>综上所述，递归神经网络是一种专门用于处理具有层次结构数据的神经网络结构。它们通过递归地应用相同的网络结构来处理不同层次的输入数据，从而能够捕捉数据中的层次信息和结构信息。尽管面临一些挑战和限制，递归神经网络在自然语言处理和其他相关任务中仍然具有广泛的应用前景。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> NN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>书评特辑·第二期</title>
      <link href="/2024/11/21/Book_Review2/"/>
      <url>/2024/11/21/Book_Review2/</url>
      
        <content type="html"><![CDATA[<p>《倚天屠龙记》中，周芷若这一角色，如同金庸先生笔下另一颗璀璨夺目的星辰，与赵敏的明媚张扬形成鲜明对比，她以一种温婉而深邃的方式，深深触动着每一位读者的心弦。周芷若，这个从汉水边渔家女成长为峨眉派掌门的女子，她的一生，是成长与蜕变，也是挣扎与牺牲的写照。</p><p>周芷若的初始形象，是那样的清新脱俗，宛如山间清泉，温柔而纯净。在汉水之畔，她初次遇见张无忌，那时的她，还是一个天真无邪、心地善良的小女孩，与张无忌有着天然的互相亲近与依赖。这段初遇，不仅为两人日后的情感纠葛埋下了伏笔，也奠定了周芷若性格中温柔、善良的一面。</p><p>然而，随着剧情的发展，周芷若的命运开始发生巨变。她进入峨眉派，师从灭绝师太，从此走上了习武之路。峨眉派的严格训练，让她的武艺日益精进，但同时也让她背负上了沉重的门派使命与复仇的枷锁。在这个过程中，周芷若的内心世界开始变得复杂，她既要保持内心的纯净，又要应对江湖的险恶，这种矛盾与挣扎，让她的形象更加立体，也更加真实。周芷若对张无忌的感情，是复杂而深沉的。从汉水边的初次相遇，到光明顶上的重逢，再到后来的种种经历，张无忌在她心中始终占据着不可替代的位置。然而，这份感情，却因为种种误会与命运的捉弄，而变得曲折坎坷。周芷若深知自己与张无忌之间隔着太多的障碍，包括门派之仇、身份之差，以及灭绝师太的遗命，这些都让她在爱情面前犹豫不决，甚至选择了放弃。这种无奈与牺牲，让人看到了周芷若内心深处的坚韧与痛苦。</p><p>“倚天剑、屠龙刀”的争夺，更是将周芷若推向了风口浪尖。在这场江湖纷争中，她不仅要面对外部的威胁，更要面对自己内心的挣扎。她渴望得到张无忌的爱，却又害怕失去自我；她想要遵从师命，却又无法割舍对张无忌的深情。这种矛盾与冲突，让周芷若的形象更加饱满，也让笔者对她产生了深深的同情与理解。</p><p>周芷若的“黑化”，是她人生中的一个重要转折点。万安寺后，她被迫修炼“九阴白骨爪”，灭绝师太的托付与强迫，强行扭转了她内心原有的价值排序，从而深刻地影响了她的性格与行为。她努力过，努力将爱情与责任平衡，因此制定了一个看似严丝合缝的计划，但此计划的实施需要以伤害其他人为代价。这个选择让她走上黑化的道路。为了让计划成功，她开始变得冷酷、决绝，甚至不惜使用各类手段来达到自己的目的。但在她的计划里玩弄的是聪慧伶俐的郡主，是洞察世事的狮王，这两个人被安置在计划中，芷若的努力注定不可能成功。当她看到张无忌与赵敏渐渐重修于好，她知道失败仅仅是时间问题。周芷若的黑化，有人说是一种堕落，而我看来是她对命运的不甘与反抗，也是她对爱情的绝望与绝望后另一种的自我救赎。</p><p>她深知，自己已无法再与张无忌共度余生，那份深沉的爱，只能化作无尽的遗憾与愧疚。在那一刻，她终于放下了心中的执念，说出了那句震撼人心的话：“<strong>倘若我问心有愧呢？</strong>”</p><p>这句话，如同一块巨石投入平静的湖面，激起了层层涟漪。它不仅是周芷若对自己过去行为的深刻反思与忏悔，更是对张无忌深情与愧疚的交织。周芷若深知，自己曾为了门派与个人的利益，对张无忌使用心计伤害了他的感情。这些行为，让她在爱情面前感到深深的愧疚与自责。然而，她又无法完全放下对张无忌的爱，那份矛盾与挣扎，让她的内心如同被撕裂般痛苦。“倘若我问心有愧”，这“倘若”二字，透露出周芷若内心的不甘与无奈。她希望自己能够问心无愧地面对张无忌，面对自己的感情，但现实却让她无法做到这一点。</p><p>然而，即便是在“黑化”之后，周芷若内心深处的善良与温柔也并未完全消失。在关键时刻，当她看到深爱的人胸口寸许的伤疤，她选择收手。我不敢妄加评论对她而言这个选择正确与否，但最终在三棵松树下，她还是选择了张无忌，与张无忌共同面对困难，这一举动，是对旧日那次无心之举的救赎。</p><p>她的矛盾，与赵敏所面对的又不相同。赵敏的责任并不大，就算撂挑子不干也并不能影响蒙古的没落衰亡。周芷若担负的则是一整个峨眉派，她不能让到她这里仅有四代的峨嵋派夭折。灭绝师太强行将她的钟爱与她的责任隔为对立面，逼迫她做出选择。戏剧性的是，她这一生，仅仅直接伤害过张无忌一次，这唯一的一次，反而是黑化前的光明顶无意的一刺。（这里应该忽略了少林寺山脚下针对敏忌二人的那次刺杀，众多分析表明是周芷若的手笔，篇幅有限不作讨论，暂且搁置。）</p><p>周芷若的一生，是成长与牺牲的写照，也是爱情与命运的交织。她的形象，既有温柔善良的一面，又有坚韧勇敢的一面；既有对爱情的执着追求，又有对命运的无奈妥协。她用自己的经历，让我们看到了人性中的光辉与阴暗，以及面对命运时的坚韧与不屈。周芷若，这个金庸笔下的女子，用她的一生，为我们讲述了一个关于成长、爱情与牺牲的动人故事。</p>]]></content>
      
      
      <categories>
          
          <category> Book Review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 金庸 </tag>
            
            <tag> 《倚天屠龙记》 </tag>
            
            <tag> 周芷若 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>书评特辑·第一期</title>
      <link href="/2024/11/21/Book_Review1/"/>
      <url>/2024/11/21/Book_Review1/</url>
      
        <content type="html"><![CDATA[<p>首先，衷心感谢每一位uu的热情支持与厚爱，正是你们的存在，让这片金庸武侠的浩瀚天地更加丰富多彩，更加令人向往。</p><p>对于那些尚未踏入《倚天屠龙记》壮丽世界的朋友们，以下的内容或许可以作为一次心灵的邀约，一次武侠世界的初探。但请放心，即便未曾翻阅原著，亦不妨碍我们共享这份对赵敏角色的无限感慨与赞美。</p><p>赵敏，这个元朝郡主的身份，本应是高高在上的存在，在父兄的安排和种种机缘巧合下，她踏入纷繁复杂的中原江湖，结识张无忌。她的美丽，不仅仅是外表上的倾国倾城，更是那份由内而外散发出的聪慧与灵动。她的聪明伶俐，让她在复杂的江湖斗争中游刃有余；而她的纯真与直率，又让这份聪明不显得锋芒毕露，反而增添了几分温暖与亲和力。在《倚天屠龙记》的宏大叙事中，赵敏以她独有的方式，诠释了何为真正的“侠女”，成为了无数武侠迷心中不可替代的女神。</p><p>“新妇素手裂红裳”这一幕，无疑是赵敏形象塑造的高潮之一。她以一己之力，不顾一切地闯入张无忌与周芷若的婚礼，那一刻，她不仅是为爱勇敢，更是在向世人宣告：爱情面前，身份、地位乃至生死，皆可抛诸脑后。赵敏的那句“<strong>我偏要勉强</strong>”，不仅是她对爱情的宣言，更是对命运不甘屈服的抗争。这句话，承载了她身为郡主却不被束缚的渴望，也流露出她对张无忌深沉而炽热的情感。赵敏的这份深情与执着，不仅让人心生敬佩，更激发了人们对真挚爱情的向往与追求。</p><p>郡主的智慧与勇气，在她为张无忌所做的一切中体现得淋漓尽致。她利用自己的资源，巧妙地为张无忌打探消息，即使身处敌对阵营，也始终保持着对张无忌的真心与关怀。她的智勇双全，不仅体现在战略上的运筹帷幄，更在于关键时刻的果断决策。如她巧妙地将张无忌从婚礼现场带走，这一举动，既是对爱情的捍卫，也是对自我价值的实现。赵敏以她的行动，向世人证明了女性不仅拥有美丽的外表和温柔的性格，更具备超越性别的智慧与勇气。</p><p>赵敏的形象，还通过一系列生动有趣的情节得以深化。她在无忌手背上留下的疤痕，既是对彼此情感的见证，也是她独特个性的体现；在船上当着无忌、谢逊和其余三女的面诉说真情，那份直率与坦诚，让人感受到她内心的纯真与热烈。她的这些举动，不仅让张无忌为之倾心，也让无数读者为之动容，仿佛看到了自己内心深处对爱情最美好的憧憬。</p><p>赵敏为了爱情，不惜与父兄割裂，这一情节更是展现了她对爱情的极致追求。她放弃了尊贵的身份，甚至与亲人反目，这份决绝与牺牲，让人看到了爱情的力量，也让人反思，真正的爱情，是否值得如此付出？尽管赵敏的选择充满了争议，但正是这样的选择，让她的人物形象更加立体，更加真实。因为在这个武侠世界里，每个人都在为自己的信仰和追求而战，无论是对是错，都是他们内心最真实的写照。</p><p>总之，赵敏这一角色，以其独特的魅力，成为了《倚天屠龙记》中一道亮丽的风景线。她不仅是我心中的女神，更是所有武侠迷心中永恒的记忆。愿我们都能在这片金庸武侠的江湖中，找到属于自己的那份武侠梦与情怀，让赵敏这个形象，永远闪耀在我们心中，成为那抹最温柔的“白月光”。</p>]]></content>
      
      
      <categories>
          
          <category> Book Review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 金庸 </tag>
            
            <tag> 《倚天屠龙记》 </tag>
            
            <tag> 赵敏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Computer Graphics</title>
      <link href="/2024/11/20/Computer_Graphics/"/>
      <url>/2024/11/20/Computer_Graphics/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机图形学"><a href="#计算机图形学" class="headerlink" title="计算机图形学"></a>计算机图形学</h1><h2 id="计算机图形学-第一讲"><a href="#计算机图形学-第一讲" class="headerlink" title="计算机图形学 第一讲"></a>计算机图形学 第一讲</h2><h3 id="1-课程介绍与概要"><a href="#1-课程介绍与概要" class="headerlink" title="1. 课程介绍与概要"></a>1. 课程介绍与概要</h3><h4 id="1-1-课程介绍"><a href="#1-1-课程介绍" class="headerlink" title="1.1 课程介绍"></a>1.1 课程介绍</h4><p>计算机图形学是研究如何利用计算机进行图形的表示、计算、处理与显示的科学学科。核心任务包括：</p><ul><li><strong>建模</strong>（Modeling）：如何在计算机中表示三维物体及场景？</li><li><strong>渲染</strong>（Rendering）：如何将三维几何模型绘制出来，产生视觉效果？</li><li><strong>动画</strong>（Animation）：如何描述物体随时间变化的状态？</li><li><strong>交互</strong>（Interaction）：如何通过人机交互完成用户所希望的任务？</li></ul><h4 id="1-2-课程内容大纲"><a href="#1-2-课程内容大纲" class="headerlink" title="1.2 课程内容大纲"></a>1.2 课程内容大纲</h4><p>课程分为三个阶段：</p><ol><li><strong>相关知识背景</strong>（1-3周）：包括引言、历史与应用、渲染管线、OpenGL 编程基础。</li><li><strong>计算机图形学基础</strong>（4-13周）：光栅化、几何变换、视角、曲线及曲面建模等。</li><li><strong>进阶与扩展课题</strong>（14-17周）：网格处理、光影、全局光照、纹理映射、蒙特卡洛渲染、神经网络渲染等前沿技术。</li></ol><h4 id="1-3-课程评分标准"><a href="#1-3-课程评分标准" class="headerlink" title="1.3 课程评分标准"></a>1.3 课程评分标准</h4><ul><li><strong>编程作业</strong>：占65%，重点考察完成度、编程规范及美观等。</li><li><strong>期末大作业</strong>：占20%，需要完成报告及现场展示。</li><li><strong>科技论文阅读</strong>：占10%，通过阅读前沿论文加深理解。</li><li><strong>出勤及小测</strong>：占5%。</li></ul><h3 id="2-计算机图形学的基本任务"><a href="#2-计算机图形学的基本任务" class="headerlink" title="2. 计算机图形学的基本任务"></a>2. 计算机图形学的基本任务</h3><h4 id="2-1-建模（Modeling）"><a href="#2-1-建模（Modeling）" class="headerlink" title="2.1 建模（Modeling）"></a>2.1 建模（Modeling）</h4><p>建模的核心是<strong>如何在计算机中表示三维物体和场景</strong>。常见的建模方式包括：</p><ul><li><strong>实体几何构造</strong>（Constructive Solid Geometry，CSG）：通过几何运算生成新的形体。</li><li><strong>网格</strong>（Mesh）：通过记录点的坐标及其连接关系，近似表示连续曲面，如著名的 <strong>Stanford bunny</strong> 。</li><li><strong>样条曲线与曲面</strong>：用于工业造型的标准。</li><li><strong>体数据</strong>（Volume）：常用于标量场的表示，如医学成像中的CT数据。</li><li><strong>过程式建模</strong>：基于规则和语法生成模型，适合具有重复特征的几何物体（如树木）。</li><li><strong>三维场景的神经网络表示</strong>：例如<strong>神经辐射场</strong>（NeRF）。</li><li><strong>手工建模</strong>：利用软件工具手动构建模型。</li><li><strong>三维扫描</strong>：通过扫描真实物体生成三维模型。</li></ul><h4 id="2-2-渲染（Rendering）"><a href="#2-2-渲染（Rendering）" class="headerlink" title="2.2 渲染（Rendering）"></a>2.2 渲染（Rendering）</h4><p>渲染是将三维几何模型转换为二维图像的过程，常见的渲染目标包括：</p><ul><li><strong>真实感渲染</strong>（Photorealistic Rendering）：通过物理模拟实现逼真的光影效果，通常用于电影特效等高质量场景。如电影《Monsters University》中的渲染，使用了24,000核的渲染农场，每帧渲染耗时29小时。</li><li><strong>实时渲染</strong>（Interactive Rendering）：在数毫秒内生成图像，通常用于游戏等追求实时反馈的应用。</li><li><strong>非真实感渲染</strong>（Non-photorealistic Rendering）：风格化渲染，用于艺术作品或示意图。</li></ul><h4 id="2-3-动画（Animation）"><a href="#2-3-动画（Animation）" class="headerlink" title="2.3 动画（Animation）"></a>2.3 动画（Animation）</h4><p>动画是使几何模型随时间变化的过程。常见手段包括：</p><ul><li><strong>手动关键帧动画</strong>：通过定义关键帧控制物体运动。</li><li><strong>行为模拟</strong>：通过物理规则模拟物体在环境中的行为，如流体或刚体的运动。</li><li><strong>物理模拟</strong>：通过物理方程模拟真实世界中的运动效果，如布料、烟雾等。</li><li><strong>动作捕捉</strong>（Motion Capture）：通过捕捉实际人物的动作并映射到虚拟角色。</li></ul><h4 id="2-4-交互（Interaction）"><a href="#2-4-交互（Interaction）" class="headerlink" title="2.4 交互（Interaction）"></a>2.4 交互（Interaction）</h4><p>交互使用户能够控制物体的内容、结构、外观，并产生实时的视觉反馈。典型应用包括：</p><ul><li><strong>输入设备</strong>：如鼠标、手绘笔、多点触控设备等。</li><li><strong>输出设备</strong>：如显示器、打印机等。</li></ul><p>最早的交互式图形系统为 <strong>Sketchpad</strong>，由 Ivan Sutherland 于1963年提出，奠定了现代交互式图形系统的基础。</p><h3 id="3-计算机图形学的扩展"><a href="#3-计算机图形学的扩展" class="headerlink" title="3. 计算机图形学的扩展"></a>3. 计算机图形学的扩展</h3><h4 id="3-1-可视化（Visualization）"><a href="#3-1-可视化（Visualization）" class="headerlink" title="3.1 可视化（Visualization）"></a>3.1 可视化（Visualization）</h4><p>可视化是计算机图形学的一个分支，主要用于数据的图形化表现，帮助用户从数据中获取有用信息。常见的可视化类别包括：</p><ul><li><strong>科学可视化</strong>：如流场可视化，通过 LIC（Line Integral Convolution）等技术表现复杂数据。</li><li><strong>信息可视化</strong>：如通过图表、关系图表现复杂信息。</li><li><strong>可视分析</strong>：通过人机交互对数据进行分析。</li></ul><h4 id="3-2-设计（Design）"><a href="#3-2-设计（Design）" class="headerlink" title="3.2 设计（Design）"></a>3.2 设计（Design）</h4><p>设计是计算机图形学的另一应用领域，涉及到工业设计、交互设计和通信设计等。常用工具包括 CAD（计算机辅助设计）和 HCI（人机交互）系统。</p><h3 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h3><h4 id="4-1-推荐教材"><a href="#4-1-推荐教材" class="headerlink" title="4.1 推荐教材"></a>4.1 推荐教材</h4><ul><li><strong>E. Angel, D. Shreiner</strong>: <em>Interactive Computer Graphics — A Top-down Approach Using OpenGL</em> （第七版）</li><li><strong>D. Hearn et al.</strong>: <em>Computer Graphics with OpenGL</em> （第四版，2014年）</li><li><strong>J. Kessenich et al.</strong>: <em>OpenGL Programming Guide</em> （第九版，2016年）</li></ul><h3 id="4-2-在线资源"><a href="#4-2-在线资源" class="headerlink" title="4.2 在线资源"></a>4.2 在线资源</h3><ul><li><strong>OpenGL-Song Ho Ahn</strong>: <a href="http://www.songho.ca/opengl/">http://www.songho.ca/opengl/</a></li><li><strong>NeHe Productions</strong>: <a href="http://nehe.gamedev.net/">http://nehe.gamedev.net/</a></li><li><strong>OpenGL-tutorial</strong>: <a href="http://www.opengl-tutorial.org/">http://www.opengl-tutorial.org/</a></li></ul><h4 id="4-3-渲染软件"><a href="#4-3-渲染软件" class="headerlink" title="4.3 渲染软件"></a>4.3 渲染软件</h4><ul><li><strong>Pixar’s RenderMan</strong>：著名的电影级渲染软件，广泛用于高质量的照片级渲染。</li></ul><h3 id="5-拓展阅读建议"><a href="#5-拓展阅读建议" class="headerlink" title="5. 拓展阅读建议"></a>5. 拓展阅读建议</h3><ul><li><strong>神经网络与图形学结合</strong>：如 <strong>NeRF</strong>（Neural Radiance Fields）等技术代表了图形学领域的前沿方向。</li><li><strong>GPGPU</strong>（通用图形处理器计算）：利用 GPU 的并行处理能力加速渲染、模拟等任务。</li><li><strong>实时光影效果</strong>：深入研究实时光影渲染技术，如 <strong>Ray Tracing</strong> 在游戏中的应用。</li></ul><h2 id="计算机图形学-第二讲"><a href="#计算机图形学-第二讲" class="headerlink" title="计算机图形学 第二讲"></a>计算机图形学 第二讲</h2><h3 id="1-现代计算机图形学的发展"><a href="#1-现代计算机图形学的发展" class="headerlink" title="1. 现代计算机图形学的发展"></a>1. 现代计算机图形学的发展</h3><h4 id="1-1-硬件变革：显卡运算性能的爆炸性增长"><a href="#1-1-硬件变革：显卡运算性能的爆炸性增长" class="headerlink" title="1.1 硬件变革：显卡运算性能的爆炸性增长"></a>1.1 硬件变革：显卡运算性能的爆炸性增长</h4><p>随着<strong>显卡（GPU）运算性能的快速提升</strong>，计算机图形学迎来了巨大发展。显卡的发展主要依赖于以下几个因素：</p><ul><li><strong>摩尔定律</strong>：由英特尔创始人之一 <strong>戈登·摩尔</strong> 提出，集成电路上可容纳的晶体管数目大约每两年翻一倍。这意味着计算机硬件的性能也会随之提升。然而，摩尔定律也面临瓶颈，晶体管数量的增加并不意味着频率的提升，未来摩尔定律能持续多久也存在不确定性。</li><li><strong>CPU 与 GPU 性能的对比</strong>：GPU 的并行计算能力远超 CPU，在处理图形渲染、模型计算等任务时显著加速。</li></ul><h4 id="1-2-GPU-的通用计算：GPGPU"><a href="#1-2-GPU-的通用计算：GPGPU" class="headerlink" title="1.2 GPU 的通用计算：GPGPU"></a>1.2 GPU 的通用计算：GPGPU</h4><p><strong>GPGPU</strong>（General-Purpose computing on Graphics Processing Unit）是将 GPU 从只处理图形任务扩展到通用计算的方案。GPGPU 的优势在于：</p><ul><li><strong>高度并行化</strong>：GPU 拥有大量计算核心，能够同时处理大量数据。</li><li><strong>图形绘制流程的简化</strong>：如通过 <strong>Vertex Shader</strong> 和 <strong>Fragment Shader</strong> 进行图形的渲染，这些步骤可以通过用户编写的 <strong>shading language</strong>（着色语言）进行自定义。</li></ul><p>常见的 GPGPU 应用包括：</p><ul><li><strong>计算机视觉</strong>：如 OpenCV 库的加速。</li><li><strong>深度学习</strong>：如 TensorFlow 框架中，利用 GPU 处理大量并行的计算任务。</li></ul><h4 id="1-3-输入输出设备的丰富化"><a href="#1-3-输入输出设备的丰富化" class="headerlink" title="1.3 输入输出设备的丰富化"></a>1.3 输入输出设备的丰富化</h4><p>现代计算机图形学不仅依赖于 GPU 的提升，还受益于输入输出设备的丰富化：</p><ul><li><strong>输入设备</strong>：包括传统的鼠标、手写笔、多点触控等设备，甚至包括体感设备（如 Xbox Kinect、Leap Motion）等。</li><li><strong>输出设备</strong>：从台式机和笔记本电脑的显示屏，到智能手机、智能手表及 3D 虚拟现实设备（如 Oculus Rift、Google Cardboard、Microsoft Hololens）等。</li></ul><h3 id="2-计算机图形学的发展史"><a href="#2-计算机图形学的发展史" class="headerlink" title="2. 计算机图形学的发展史"></a>2. 计算机图形学的发展史</h3><h4 id="2-1-早期发展（1950-1970年代）"><a href="#2-1-早期发展（1950-1970年代）" class="headerlink" title="2.1 早期发展（1950-1970年代）"></a>2.1 早期发展（1950-1970年代）</h4><ul><li><strong>1950年代</strong>：MIT 开发了首个可视显示单元（VDU），CalComp 推出了滚筒绘图仪，Gerber 公司开发了平板绘图仪，奠定了早期计算机图形学的硬件基础。</li><li><strong>1960年代</strong>：<ul><li><strong>Spacewar</strong>：第一个计算机游戏，由 MIT 学生 Steve Russell 开发。</li><li><strong>Sketchpad 系统</strong>：由 Ivan Sutherland 在其博士论文中提出，成为第一个交互式图形系统。</li><li><strong>CAD（计算机辅助设计）</strong>：由 MIT 教授 Steven Anson Coons 提出，CAD 系统在60年代末得到了广泛应用，尤其是 Bezier 曲线的发明对现代 CAD 产生了深远影响。</li></ul></li><li><strong>1970年代</strong>：光栅化图形算法快速发展，标准化进程加速，出现了诸如 GKS、PHIGS 等图形标准。此外，Bouknight 提出了最早的光反射模型，Phong 着色模型的提出奠定了现代图形渲染的基础。</li></ul><h4 id="2-2-计算机图形学的里程碑（1980年代至今）"><a href="#2-2-计算机图形学的里程碑（1980年代至今）" class="headerlink" title="2.2 计算机图形学的里程碑（1980年代至今）"></a>2.2 计算机图形学的里程碑（1980年代至今）</h4><ul><li><p><strong>1980年代</strong>：</p><ul><li><strong>光线追踪</strong>（Ray Tracing）和 <strong>辐射度</strong>（Radiosity）算法的提出使得图形渲染质量大幅提升，尤其是光线追踪技术可以模拟现实世界中的光影效果。</li><li>专业图形工作站的出现推动了图形学的发展，但随着硬件的普及，越来越多的图形处理工作由 GPU 和通用硬件完成。</li></ul></li><li><p><strong>1990年代</strong>：</p><ul><li><strong>建模技术</strong>：如网格、细分曲面、隐式曲面（Implicit Surface）等建模技术逐渐成熟。</li><li><strong>渲染技术</strong>：基于图像的渲染、体渲染、点基渲染等新技术出现，进一步丰富了图形学的表现形式。</li></ul></li><li><p><strong>2000年后</strong>：</p><ul><li><strong>3D 扫描技术</strong>：通过扫描真实物体生成三维模型的技术迅速发展。</li><li><strong>GPU 并行编程</strong>：随着 GPU 的性能提升，计算机图形学任务越来越依赖于并行计算。</li><li><strong>深度学习</strong>：神经网络的兴起推动了图形学领域的智能化发展，如神经渲染技术的应用。</li></ul></li></ul><h4 id="2-3-新兴趋势"><a href="#2-3-新兴趋势" class="headerlink" title="2.3 新兴趋势"></a>2.3 新兴趋势</h4><ul><li><strong>体感设备</strong>：如微软的 Kinect，支持通过手势和身体动作进行交互。</li><li><strong>3D 打印</strong>：3D 打印技术的普及使得虚拟设计与实际制造之间的距离越来越短。</li><li><strong>虚拟现实</strong>（VR）：如 Cyberith Virtualizer，提供更加沉浸式的虚拟现实体验。</li><li><strong>神经辐射场（NeRF）</strong>：利用神经网络对三维场景进行建模和渲染，成为图形学领域的前沿技术。</li></ul><h3 id="3-计算机图形学的应用"><a href="#3-计算机图形学的应用" class="headerlink" title="3. 计算机图形学的应用"></a>3. 计算机图形学的应用</h3><p>计算机图形学的应用领域非常广泛，涉及多个行业和技术领域：</p><h4 id="3-1-电影与动画"><a href="#3-1-电影与动画" class="headerlink" title="3.1 电影与动画"></a>3.1 电影与动画</h4><ul><li><strong>电影特效</strong>：计算机图形学在电影中的应用包括复杂的动画生成和物理仿真，尤其是动画电影和科幻电影中。</li><li><strong>动作捕捉</strong>：通过捕捉真人的动作并映射到虚拟角色，广泛用于电影和游戏中的角色动画。</li></ul><h4 id="3-2-游戏"><a href="#3-2-游戏" class="headerlink" title="3.2 游戏"></a>3.2 游戏</h4><ul><li><strong>实时渲染</strong>：游戏中广泛应用实时渲染技术，结合光影效果、物理引擎等，提升游戏的视觉体验。</li></ul><h4 id="3-3-图像与设计"><a href="#3-3-图像与设计" class="headerlink" title="3.3 图像与设计"></a>3.3 图像与设计</h4><ul><li><strong>广告与艺术</strong>：计算机图形学已成为广告设计和艺术创作的重要工具，通过数字手段创造出逼真的视觉效果。</li><li><strong>UI 设计</strong>：随着用户界面设计的复杂化，计算机图形学帮助设计出更加人性化和美观的用户界面。</li></ul><h4 id="3-4-训练与模拟"><a href="#3-4-训练与模拟" class="headerlink" title="3.4 训练与模拟"></a>3.4 训练与模拟</h4><ul><li><strong>仿真系统</strong>：如飞行模拟器、驾驶训练系统，利用计算机图形学技术提供高度逼真的训练环境。</li></ul><h4 id="3-5-地理科学与医学影像"><a href="#3-5-地理科学与医学影像" class="headerlink" title="3.5 地理科学与医学影像"></a>3.5 地理科学与医学影像</h4><ul><li><strong>地理信息系统（GIS）和数字城市</strong>：计算机图形学在地理科学中的应用包括几何对齐算法、数字地球和数字城市的构建。</li><li><strong>医学影像</strong>：通过三维重建技术，医学图像可以在计算机上进行可视化分析，帮助医生更准确地诊断和治疗。</li></ul><h4 id="3-6-计算机辅助设计（CAD）"><a href="#3-6-计算机辅助设计（CAD）" class="headerlink" title="3.6 计算机辅助设计（CAD）"></a>3.6 计算机辅助设计（CAD）</h4><ul><li>CAD 已广泛应用于多个行业，尤其是在工业设计和建筑设计中，计算机图形学帮助设计师创建精确的三维模型。</li></ul><h3 id="4-如何学习计算机图形学"><a href="#4-如何学习计算机图形学" class="headerlink" title="4. 如何学习计算机图形学"></a>4. 如何学习计算机图形学</h3><h4 id="4-1-学习动机"><a href="#4-1-学习动机" class="headerlink" title="4.1 学习动机"></a>4.1 学习动机</h4><ul><li><strong>广泛应用</strong>：计算机图形学在电影、游戏、教育、科学等多个领域有着广泛的应用，且市场需求巨大。</li><li><strong>兴趣驱动</strong>：学习计算机图形学可以发挥个人的创造力，通过编程和技术手段绘制出绚丽的图像。</li></ul><h4 id="4-2-学习计算机图形学的必备条件"><a href="#4-2-学习计算机图形学的必备条件" class="headerlink" title="4.2 学习计算机图形学的必备条件"></a>4.2 学习计算机图形学的必备条件</h4><ul><li><strong>跨学科知识</strong>：需要掌握数学（几何、线性代数）、物理学、计算机科学以及艺术设计等多学科的知识。</li><li><strong>好奇心与创造力</strong>：对未知的探索欲望和对技术的追求是学习计算机图形学的重要动力。</li><li><strong>实践能力</strong>：通过编程实践（如 C++、OpenGL）掌握图形学的基本算法和技术。</li></ul><h4 id="4-3-课程目标"><a href="#4-3-课程目标" class="headerlink" title="4.3 课程目标"></a>4.3 课程目标</h4><p>通过本教程，你将会学习到：</p><ul><li><strong>基础计算机图形学算法</strong>：如几何处理、真实感渲染的算法与数据结构。</li><li><strong>OpenGL 编程</strong>：掌握图形编程的基本技术，了解如何实现从建模到渲染的完整过程。</li></ul><h3 id="5-计算机图形学的前沿与资源"><a href="#5-计算机图形学的前沿与资源" class="headerlink" title="5. 计算机图形学的前沿与资源"></a>5. 计算机图形学的前沿与资源</h3><h4 id="5-1-国际会议"><a href="#5-1-国际会议" class="headerlink" title="5.1 国际会议"></a>5.1 国际会议</h4><ul><li><strong>ACM SIGGRAPH</strong>：计算机图形学领域最重要的国际会议之一，致力于展示最新的图形学技术和研究成果。</li><li><strong>Eurographics</strong>、<strong>Pacific Graphics</strong>、<strong>Chinagraph</strong>：其他重要的国际会议，涵盖了几何处理、渲染、动画等多个方向。</li></ul><h4 id="5-2-相关期刊"><a href="#5-2-相关期刊" class="headerlink" title="5.2 相关期刊"></a>5.2 相关期刊</h4><ul><li><strong>ACM Transactions on Graphics</strong></li><li><strong>IEEE Transactions on Graphics and Visualization</strong></li><li><strong>Computer Graphics Forum</strong></li><li><strong>Computer-aided Design</strong></li><li><strong>中国图象图形学报</strong></li></ul><p>这些期刊汇集了图形学领域的最新研究成果，是学习和了解前沿技术的重要资源。</p><h4 id="5-3-在线资源"><a href="#5-3-在线资源" class="headerlink" title="5.3 在线资源"></a>5.3 在线资源</h4><ul><li><strong>NVIDIA GameWorks™</strong>：提供丰富的图形学开发示例和工具。</li><li><strong>CGAL</strong>：计算几何算法库。</li><li><strong>OpenMesh</strong>：用于三维网格处理的开源库。</li><li><strong>Blender</strong>：开源的三维建模与渲染工具。</li><li><strong>Unity 3D</strong>：广泛用于游戏开发的引擎，具备强大的图形渲染能力。</li></ul><p>以上资源为学习和实践计算机图形学技术提供了强有力的支持。</p><hr><p>通过第二讲的学习，我们了解了计算机图形学的发展历程、技术变革和广泛应用，同时也为后续的课程学习奠定了理论和技术基础。</p><h2 id="计算机图形学-第三讲"><a href="#计算机图形学-第三讲" class="headerlink" title="计算机图形学 第三讲"></a>计算机图形学 第三讲</h2><h3 id="1-OpenGL-编程入门"><a href="#1-OpenGL-编程入门" class="headerlink" title="1. OpenGL 编程入门"></a>1. OpenGL 编程入门</h3><h4 id="1-1-OpenGL-是什么？"><a href="#1-1-OpenGL-是什么？" class="headerlink" title="1.1 OpenGL 是什么？"></a>1.1 OpenGL 是什么？</h4><p><strong>OpenGL</strong>，即 <strong>Open Graphics Library</strong>，是用于渲染 <strong>2D</strong> 和 <strong>3D</strong> 矢量图形的跨平台、跨语言的应用程序接口（API）。它的主要特性包括：</p><ul><li><strong>跨平台</strong>：可以在不同平台上使用，如 Windows、Linux、macOS 等。</li><li><strong>跨语言</strong>：支持多种编程语言，如 C、C++、Python 等。</li><li><strong>硬件依赖</strong>：虽然 OpenGL 是跨平台的，但其具体实现依赖于硬件厂商，通常由显示设备制造商提供。</li><li><strong>渲染功能</strong>：OpenGL 主要用于图形渲染，不提供音频或窗口管理等功能，需要配合其他工具库（如 <strong>GLUT</strong>）使用。</li></ul><h5 id="OpenGL-的发展过程"><a href="#OpenGL-的发展过程" class="headerlink" title="OpenGL 的发展过程"></a>OpenGL 的发展过程</h5><ul><li>1992年，由 <strong>Silicon Graphics Inc. (SGI)</strong> 领导成立 <strong>OpenGL 架构审查委员会</strong>（ARB），负责 OpenGL 规范的维护和扩展。</li><li>2006年，OpenGL ARB 将控制权移交给 <strong>Khronos Group</strong>。</li><li>OpenGL 的最新版本为 <strong>OpenGL 4.6</strong>，发布于2017年。</li></ul><h5 id="OpenGL-相关的其他选择"><a href="#OpenGL-相关的其他选择" class="headerlink" title="OpenGL 相关的其他选择"></a>OpenGL 相关的其他选择</h5><p>除了 OpenGL 之外，还存在其他图形渲染解决方案，如：</p><ul><li><strong>DirectX</strong>：主要用于 Windows 平台。</li><li><strong>NVIDIA CUDA</strong>：尽管不是图形库，但提供了使用 GPU 进行高性能计算的开发环境。</li><li><strong>Vulkan</strong>：由 Khronos Group 开发，继承了 OpenGL，但不再兼容旧版本。</li></ul><h4 id="1-2-OpenGL-能做什么？"><a href="#1-2-OpenGL-能做什么？" class="headerlink" title="1.2 OpenGL 能做什么？"></a>1.2 OpenGL 能做什么？</h4><p>OpenGL 的核心功能是图形渲染，具体来说，它可以：</p><ul><li><strong>定义物体形状</strong>：如顶点、几何形状等。</li><li><strong>定义材料属性和光照</strong>：控制物体的颜色、光照反射等。</li><li><strong>转换物体到屏幕坐标系</strong>：通过光栅化（Rasterization）将几何体转换为屏幕空间中的像素。</li><li><strong>计算每个片段（Fragment）的颜色</strong>：混合每个片段的颜色，最终生成屏幕上的像素。</li></ul><h4 id="1-3-OpenGL-Utility-Toolkit（GLUT）"><a href="#1-3-OpenGL-Utility-Toolkit（GLUT）" class="headerlink" title="1.3 OpenGL Utility Toolkit（GLUT）"></a>1.3 OpenGL Utility Toolkit（GLUT）</h4><p><strong>GLUT</strong> 是一个实用工具包，虽然不是 OpenGL 的官方组成部分，但它提供了系统级别的输入输出功能。GLUT 提供以下功能：</p><ul><li><strong>窗口管理</strong>：定义窗口，控制窗口大小，捕获键盘和鼠标事件。</li><li><strong>基本几何体绘制函数</strong>：如正方体、球体、Utah 茶壶等，支持实心和线框模式。</li><li><strong>菜单功能</strong>：可以为应用程序添加简单的菜单结构。</li></ul><h5 id="GLUT-安装"><a href="#GLUT-安装" class="headerlink" title="GLUT 安装"></a>GLUT 安装</h5><p>对于 Windows 平台，可以按照以下步骤安装 GLUT：</p><ol><li>下载 GLUT 库（推荐使用 FreeGLUT）。</li><li>将 <code>glut.dll</code> 文件复制到 <code>&#123;Windows DLL dir&#125;/glut32.dll</code>。</li><li>将 <code>glut.lib</code> 文件复制到 <code>&#123;VC++ lib path&#125;/glut32.lib</code>。</li><li>将 <code>glut.h</code> 文件复制到 <code>&#123;VC++ include path&#125;/GL/glut.h</code>。</li><li>在代码中添加 <code>#include &lt;GL/glut&gt;</code>。</li></ol><p>在实际开发中，推荐使用更现代的工具，如 <strong>Qt</strong>，并提供了相应的程序模板。</p><h3 id="2-OpenGL-是如何工作的？"><a href="#2-OpenGL-是如何工作的？" class="headerlink" title="2. OpenGL 是如何工作的？"></a>2. OpenGL 是如何工作的？</h3><h4 id="2-1-OpenGL-的状态机模型"><a href="#2-1-OpenGL-的状态机模型" class="headerlink" title="2.1 OpenGL 的状态机模型"></a>2.1 OpenGL 的状态机模型</h4><p>OpenGL 是一个 <strong>状态机</strong>，其工作原理是通过函数调用设置内部状态变量（如当前颜色、光源位置等）。每个状态变量都有初始值，且一旦设置状态，直到显式改变之前，状态保持不变。</p><h4 id="2-2-OpenGL-渲染管线（Pipeline）"><a href="#2-2-OpenGL-渲染管线（Pipeline）" class="headerlink" title="2.2 OpenGL 渲染管线（Pipeline）"></a>2.2 OpenGL 渲染管线（Pipeline）</h4><p>OpenGL 的渲染过程可以用以下<strong>简易管线</strong>（pipeline）表示：</p><ol><li><strong>Display List</strong>：存储预编译的 OpenGL 命令列表，不能修改，执行速度快。</li><li><strong>Evaluator</strong>：处理曲线和曲面的计算，将控制点描述的曲线&#x2F;曲面离散化为顶点。</li><li><strong>Per-Vertex Operations</strong>：基于顶点进行的操作，如空间变换。</li><li><strong>Primitive Assembly</strong>：将顶点组装成图元（如点、线、三角形等）。</li><li><strong>Rasterization</strong>：将图元转换为片段（fragment），每个片段对应屏幕上的一个像素。</li><li><strong>Per-Fragment Operations</strong>：对每个片段进行颜色和深度计算，最终确定屏幕上每个像素的颜色。</li><li><strong>Frame Buffer</strong>：保存渲染结果，并传输到屏幕进行显示。</li></ol><h4 id="2-3-OpenGL-中的函数分类"><a href="#2-3-OpenGL-中的函数分类" class="headerlink" title="2.3 OpenGL 中的函数分类"></a>2.3 OpenGL 中的函数分类</h4><p>OpenGL 的函数可以分为以下几类：</p><ul><li><strong>图元</strong>：定义基本的几何体，如点、线、三角形。</li><li><strong>属性</strong>：设置图元的属性，如颜色、材质等。</li><li><strong>变换</strong>：控制图元的空间变换，如平移、旋转、缩放。</li><li><strong>输入与控制</strong>：由 GLUT 等工具库提供，用于处理窗口、鼠标、键盘等输入事件。</li><li><strong>查询</strong>：查询 OpenGL 的状态或属性。</li></ul><h3 id="3-OpenGL-程序结构简介"><a href="#3-OpenGL-程序结构简介" class="headerlink" title="3. OpenGL 程序结构简介"></a>3. OpenGL 程序结构简介</h3><h4 id="3-1-OpenGL-程序的基本文件需求"><a href="#3-1-OpenGL-程序的基本文件需求" class="headerlink" title="3.1 OpenGL 程序的基本文件需求"></a>3.1 OpenGL 程序的基本文件需求</h4><p>为了编写一个 OpenGL 程序，通常需要以下文件：</p><ul><li><strong>头文件</strong>：<ul><li><code>#include &lt;GL/gl.h&gt;</code>：OpenGL 核心头文件。</li><li><code>#include &lt;GL/glu.h&gt;</code>：OpenGL 实用库头文件。</li><li><code>#include &lt;GL/glut.h&gt;</code>：GLUT 头文件。</li></ul></li><li><strong>库文件</strong>：<ul><li>静态库：<code>opengl32.lib</code>、<code>glu32.lib</code>、<code>glut32.lib</code>，需要将这些库放置在编译器的 lib 目录下。</li><li>动态库：<code>opengl32.dll</code>、<code>glu32.dll</code>、<code>glut32.dll</code>，需要将这些动态库放置在系统目录中（如 <code>c:/Windows/System32</code>）。</li></ul></li></ul><h4 id="3-2-OpenGL-程序的基本结构"><a href="#3-2-OpenGL-程序的基本结构" class="headerlink" title="3.2 OpenGL 程序的基本结构"></a>3.2 OpenGL 程序的基本结构</h4><p>OpenGL 程序通常是<strong>事件驱动编程</strong>，其基本结构如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. Configure &amp; Open Window</span><br><span class="line">2. Initializing Works</span><br><span class="line">3. Handle User Event</span><br><span class="line">4. Render</span><br></pre></td></tr></table></figure><p>每个 OpenGL 程序通常包含一个无限循环，等待用户输入事件（如鼠标点击、键盘按下）并执行相应的渲染操作。</p><h4 id="3-3-OpenGL-Hello-World-示例"><a href="#3-3-OpenGL-Hello-World-示例" class="headerlink" title="3.3 OpenGL Hello World 示例"></a>3.3 OpenGL Hello World 示例</h4><p>下面是一个简单的 OpenGL “Hello World” 示例，展示了如何绘制一个基本窗口并渲染内容：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glut.h&gt;</span> <span class="comment">// 包含 GLUT 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 清空窗口</span></span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绘制一个白色四边形</span></span><br><span class="line">    <span class="built_in">glBegin</span>(GL_POLYGON);</span><br><span class="line">        <span class="built_in">glColor3f</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>); <span class="comment">// 设置颜色为白色</span></span><br><span class="line">        <span class="built_in">glVertex2f</span>(<span class="number">-0.5</span>, <span class="number">-0.5</span>); <span class="comment">// 顶点1</span></span><br><span class="line">        <span class="built_in">glVertex2f</span>( <span class="number">0.5</span>, <span class="number">-0.5</span>); <span class="comment">// 顶点2</span></span><br><span class="line">        <span class="built_in">glVertex2f</span>( <span class="number">0.5</span>,  <span class="number">0.5</span>); <span class="comment">// 顶点3</span></span><br><span class="line">        <span class="built_in">glVertex2f</span>(<span class="number">-0.5</span>,  <span class="number">0.5</span>); <span class="comment">// 顶点4</span></span><br><span class="line">    <span class="built_in">glEnd</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 刷新显示</span></span><br><span class="line">    <span class="built_in">glFlush</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 GLUT</span></span><br><span class="line">    <span class="built_in">glutInit</span>(&amp;argc, argv);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置显示模式</span></span><br><span class="line">    <span class="built_in">glutInitDisplayMode</span>(GLUT_SINGLE | GLUT_RGB);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置窗口大小</span></span><br><span class="line">    <span class="built_in">glutInitWindowSize</span>(<span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置窗口位置</span></span><br><span class="line">    <span class="built_in">glutInitWindowPosition</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建窗口</span></span><br><span class="line">    <span class="built_in">glutCreateWindow</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册显示回调函数</span></span><br><span class="line">    <span class="built_in">glutDisplayFunc</span>(display);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入 GLUT 主循环</span></span><br><span class="line">    <span class="built_in">glutMainLoop</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码讲解：</strong><br><code>glutInit()</code>：初始化 GLUT 库。<br><code>glutInitDisplayMode()</code>：设置显示模式，<code>GLUT_SINGLE</code> 表示单缓冲，<code>GLUT_RGB</code> 表示使用 RGB 颜色模式。<br><code>glutInitWindowSize()</code>：设置窗口大小（400x300）。<br><code>glutInitWindowPosition()</code>：设置窗口在屏幕上的初始位置。<br><code>glutCreateWindow()</code>：创建一个名为 “Hello World” 的窗口。<br><code>glutDisplayFunc()</code>：注册一个显示回调函数，当窗口需要重绘时调用。<br><code>glutMainLoop()</code>：进入 GLUT 主循环，等待事件。</p><h4 id="3-4-OpenGL-回调函数"><a href="#3-4-OpenGL-回调函数" class="headerlink" title="3.4 OpenGL 回调函数"></a>3.4 OpenGL 回调函数</h4><p>OpenGL 使用回调函数处理用户交互事件，如鼠标点击、键盘输入等。回调函数允许我们在事件发生时调用自定义的处理函数。</p><p><strong>回调函数工作原理：</strong></p><ul><li>主线程等待事件（如鼠标点击、键盘按下）。</li><li>当事件发生时，系统调用注册的回调函数，并将特定事件的信息传递给它。</li></ul><h4 id="3-5-GLUT-回调函数示例"><a href="#3-5-GLUT-回调函数示例" class="headerlink" title="3.5 GLUT 回调函数示例"></a>3.5 GLUT 回调函数示例</h4><p>以下是 GLUT 回调函数的示例代码，展示如何处理键盘和鼠标事件：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 键盘回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">keyboardCB</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> key, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;a 键被按下&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mousebutton</span><span class="params">(<span class="type">int</span> button, <span class="type">int</span> state, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (button == GLUT_LEFT_BUTTON &amp;&amp; state == GLUT_DOWN) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;左键点击，坐标: (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">glutInit</span>(&amp;argc, argv);</span><br><span class="line">    <span class="built_in">glutInitDisplayMode</span>(GLUT_DOUBLE | GLUT_RGB);</span><br><span class="line">    <span class="built_in">glutInitWindowSize</span>(<span class="number">250</span>, <span class="number">250</span>);</span><br><span class="line">    <span class="built_in">glutCreateWindow</span>(<span class="string">&quot;GLUT 回调示例&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册回调函数</span></span><br><span class="line">    <span class="built_in">glutKeyboardFunc</span>(keyboardCB); <span class="comment">// 键盘事件</span></span><br><span class="line">    <span class="built_in">glutMouseFunc</span>(mousebutton);   <span class="comment">// 鼠标事件</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glutMainLoop</span>(); <span class="comment">// 进入主循环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码讲解</strong>：<br><code>keyboardCB()</code>：处理键盘事件，当按下 ‘a’ 键时输出相应信息。<br><code>mousebutton()</code>：处理鼠标事件，当鼠标左键按下时输出点击的坐标。<br><code>glutKeyboardFunc()</code> 和 <code>glutMouseFunc()</code>：注册键盘和鼠标回调函数。</p><h3 id="4-OpenGL-基本概念与语句"><a href="#4-OpenGL-基本概念与语句" class="headerlink" title="4. OpenGL 基本概念与语句"></a>4. OpenGL 基本概念与语句</h3><h4 id="4-1-OpenGL-上下文（Context）与视口（Viewport）"><a href="#4-1-OpenGL-上下文（Context）与视口（Viewport）" class="headerlink" title="4.1 OpenGL 上下文（Context）与视口（Viewport）"></a>4.1 OpenGL 上下文（Context）与视口（Viewport）</h4><p>上下文：OpenGL 的 context 存储与当前 OpenGL 实例相关的所有状态信息（如颜色、光照、纹理等）。<br>视口：屏幕中显示 OpenGL 绘制内容的矩形区域，通常定义为窗口的一部分或整个窗口。</p><h4 id="4-2-OpenGL-坐标系统"><a href="#4-2-OpenGL-坐标系统" class="headerlink" title="4.2 OpenGL 坐标系统"></a>4.2 OpenGL 坐标系统</h4><p>OpenGL 使用世界坐标系和窗口坐标系：</p><p>世界坐标系原点在左下角，y 轴向上，通常不以像素为单位。<br>窗口坐标系原点在左上角，y 轴向下，使用像素作为单位。</p><h4 id="4-3-OpenGL-常用函数"><a href="#4-3-OpenGL-常用函数" class="headerlink" title="4.3 OpenGL 常用函数"></a>4.3 OpenGL 常用函数</h4><p>OpenGL 提供了许多函数用于处理几何体、颜色、状态设置等。常见函数包括：</p><p><code>glVertex*()</code>：输入几何体的顶点。<br><code>glColor*()</code>：设置颜色。<br><code>glBegin()</code> 和 <code>glEnd()</code>：定义图元类型（如点、线、多边形等）。<br>通过本讲的学习，我们了解了 OpenGL 的基本概念、渲染管线以及如何编写简单的 OpenGL 程序。接下来的课程将深入探讨 OpenGL 的矩阵操作、变换、投影等更高级的图形编程技术。</p><h2 id="计算机图形学-第四讲"><a href="#计算机图形学-第四讲" class="headerlink" title="计算机图形学 第四讲"></a>计算机图形学 第四讲</h2><h3 id="1-计算机图形系统"><a href="#1-计算机图形系统" class="headerlink" title="1. 计算机图形系统"></a>1. 计算机图形系统</h3><h4 id="1-1-图像的来源与生成"><a href="#1-1-图像的来源与生成" class="headerlink" title="1.1 图像的来源与生成"></a>1.1 图像的来源与生成</h4><ul><li><strong>图像从何而来？</strong><ul><li>图像需要通过软件和硬件的共同协作生成。</li></ul></li><li><strong>软件：</strong> 例如Maya、RenderMan等建模和渲染软件。</li><li><strong>硬件：</strong> 显卡（PC或大规模渲染集群上的显卡）。</li></ul><h4 id="1-2-输入设备"><a href="#1-2-输入设备" class="headerlink" title="1.2 输入设备"></a>1.2 输入设备</h4><ul><li><p><strong>消费电子产品：</strong></p><ul><li>摄影摄像设备变得越来越普及，智能手机摄像头的像素快速提升。</li><li>例如：诺基亚N90（2005年，200万像素）与iPhone 6s Plus（2015年，前置500万像素，后置1200万像素）。</li><li>提出了一个问题：<strong>5美刀的手机摄像头能否拍出5000美刀的单反的效果？</strong></li></ul></li><li><p><strong>几何体形状：</strong></p><ul><li>使用深度摄像头（如Kinect）或三维扫描仪进行形状建模。</li><li>例如，4步构建简易三维扫描系统：<a href="https://www.instructables.com/id/3-D-Laser-Scanner/">https://www.instructables.com/id/3-D-Laser-Scanner/</a></li></ul></li></ul><h4 id="1-3-输出设备"><a href="#1-3-输出设备" class="headerlink" title="1.3 输出设备"></a>1.3 输出设备</h4><ul><li><p><strong>阴极射线管（CRT）：</strong></p><ul><li>通过电子枪发射电子束，经过聚焦和偏转系统，形成图像。</li><li>包括向量显示器（如1979年的Asteroids游戏）和光栅显示器。</li></ul></li><li><p><strong>平板显示器：</strong></p><ul><li>液晶显示器（LCD）、等离子显示器（Plasma）、发光二极管（LED）等。</li><li>优点包括低能耗、低辐射、无闪烁和无几何失真。</li></ul></li></ul><h4 id="1-4-图像的基本概念"><a href="#1-4-图像的基本概念" class="headerlink" title="1.4 图像的基本概念"></a>1.4 图像的基本概念</h4><ul><li><p><strong>采样：</strong></p><ul><li>图像是二维域中的有规律采样，每个采样点代表颜色（如RGB）。</li></ul></li><li><p><strong>RGB和Alpha通道：</strong></p><ul><li>图像通常由三个通道（R、G、B）组成。</li><li>Alpha通道用于表示透明度，取值范围为[0, 1]。</li></ul></li></ul><h3 id="2-图像建模"><a href="#2-图像建模" class="headerlink" title="2. 图像建模"></a>2. 图像建模</h3><h4 id="2-1-像素与图像"><a href="#2-1-像素与图像" class="headerlink" title="2.1 像素与图像"></a>2.1 像素与图像</h4><ul><li><p><strong>像素：</strong> 是采样点加上值（而非方块）。</p><ul><li>在不同显示设备上，像素的形状可能会有所不同，例如在CRT显示器上接近圆形，而在LCD屏幕上接近长方形。</li></ul></li><li><p><strong>离散图像与连续图像：</strong></p><ul><li>离散图像：常见的图像存储形式，定义域为离散。</li><li>连续图像：真实世界中的表现形式，定义域为连续。</li></ul></li></ul><h4 id="2-2-矢量图与光栅图"><a href="#2-2-矢量图与光栅图" class="headerlink" title="2.2 矢量图与光栅图"></a>2.2 矢量图与光栅图</h4><ul><li><p><strong>矢量图：</strong></p><ul><li>由绘制命令驱动，如<code>move(x, y)</code>，可缩放矢量图形。</li></ul></li><li><p><strong>光栅图：</strong></p><ul><li>基于像素，由于离散采样可能产生锯齿效果。</li></ul></li></ul><h4 id="2-3-图像理解"><a href="#2-3-图像理解" class="headerlink" title="2.3 图像理解"></a>2.3 图像理解</h4><ul><li><strong>图像是数据点的集合：</strong><ul><li>可视为RGB空间中的点集合，计算灰度图像是降维问题。</li></ul></li><li><strong>图像是矩阵：</strong><ul><li>可以使用矩阵分解、低秩矩阵等方法进行处理。</li></ul></li><li><strong>图像是函数：</strong><ul><li>可使用网格对其近似，比如四边形域函数、三角形域函数。</li></ul></li><li><strong>图像是图：</strong><ul><li>使用图算法（如最大流最小割）进行分割。</li></ul></li></ul><h3 id="3-基于采样的图形-vs-基于几何的图形"><a href="#3-基于采样的图形-vs-基于几何的图形" class="headerlink" title="3. 基于采样的图形 vs 基于几何的图形"></a>3. 基于采样的图形 vs 基于几何的图形</h3><h4 id="3-1-基于采样的图形"><a href="#3-1-基于采样的图形" class="headerlink" title="3.1 基于采样的图形"></a>3.1 基于采样的图形</h4><ul><li><strong>优点：</strong><ul><li>易于操作，图像定义在规则网格上，可以修改每个格点的颜色或位置。</li></ul></li><li><strong>缺点：</strong><ul><li>缺乏额外信息（如深度、空间位置），无法更换观察视角，只能对像素进行操作。</li></ul></li></ul><h4 id="3-2-基于几何的图形"><a href="#3-2-基于几何的图形" class="headerlink" title="3.2 基于几何的图形"></a>3.2 基于几何的图形</h4><ul><li><p><strong>几何对象：</strong></p><ul><li>创建几何对象及其附属外观属性，通过计算机图形学或可视化方法渲染。</li><li>2D工具：Adobe Illustrator、CorelDRAW。</li><li>3D工具：Autodesk AutoCAD、POV-Ray。</li></ul></li><li><p><strong>几何图元：</strong></p><ul><li>简单几何体（球体、椎体、圆柱体等）和复杂图元（Spline、NURBS、隐函数、显函数、参数函数）。</li></ul></li></ul><h4 id="3-3-融合方法"><a href="#3-3-融合方法" class="headerlink" title="3.3 融合方法"></a>3.3 融合方法</h4><ul><li><strong>基于采样与基于几何的融合：</strong><ul><li>用于提高渲染速度和图像质量，例如在图像上绘制几何体，或在3D场景中使用纹理贴图。</li></ul></li></ul><h3 id="4-物理成像系统"><a href="#4-物理成像系统" class="headerlink" title="4. 物理成像系统"></a>4. 物理成像系统</h3><h4 id="4-1-成像原理"><a href="#4-1-成像原理" class="headerlink" title="4.1 成像原理"></a>4.1 成像原理</h4><ul><li><p><strong>基本元素：</strong></p><ul><li>物体、观察者、光源及其属性（如光源与物体材质的属性）。</li></ul></li><li><p><strong>模拟相机模型：</strong></p><ul><li>物体、观察者、光源相互独立，2D图形可视为3D图形的特例。</li><li>OpenGL、Direct3D等API基于此模型。</li></ul></li></ul><h4 id="4-2-光源类型"><a href="#4-2-光源类型" class="headerlink" title="4.2 光源类型"></a>4.2 光源类型</h4><ul><li><p><strong>点光源：</strong></p><ul><li>如灯泡，光线从一点向四面八方发射。</li></ul></li><li><p><strong>方向光源：</strong></p><ul><li>如太阳，假设所有光束平行。</li></ul></li><li><p><strong>区域光源：</strong></p><ul><li>如吸顶灯，表面上的每个点沿所有方向发光。</li></ul></li></ul><h3 id="5-图形渲染管线"><a href="#5-图形渲染管线" class="headerlink" title="5. 图形渲染管线"></a>5. 图形渲染管线</h3><h4 id="5-1-渲染定义"><a href="#5-1-渲染定义" class="headerlink" title="5.1 渲染定义"></a>5.1 渲染定义</h4><ul><li><strong>渲染：</strong> 将一组对象转换为像素阵列的过程。<ul><li>渲染管线：将3D场景转换为2D图像的一系列步骤。</li></ul></li></ul><h4 id="5-2-渲染管线步骤"><a href="#5-2-渲染管线步骤" class="headerlink" title="5.2 渲染管线步骤"></a>5.2 渲染管线步骤</h4><ul><li><strong>Application（应用阶段）：</strong> CPU完成碰撞检测、物理模拟、全局加速算法、动画等任务。</li><li><strong>Geometry（几何阶段）：</strong> GPU完成几何变换，确定需要绘制的内容及位置。</li><li><strong>Rasterizer（光栅化阶段）：</strong> GPU将屏幕空间中的二维顶点转换为像素，考虑深度和着色属性。</li></ul><h4 id="5-3-渲染过程"><a href="#5-3-渲染过程" class="headerlink" title="5.3 渲染过程"></a>5.3 渲染过程</h4><ul><li><p><strong>纹理映射：</strong></p><ul><li>将图像贴在几何体上，fragment的颜色由图像中相应位置的颜色决定。</li></ul></li><li><p><strong>深度测试：</strong></p><ul><li>通过深度测试去除被遮挡的几何体部分。</li></ul></li><li><p><strong>Blending（颜色混合）：</strong></p><ul><li>按顺序渲染fragment，并将其线性合成。</li></ul></li></ul><h4 id="5-4-Frame-buffer"><a href="#5-4-Frame-buffer" class="headerlink" title="5.4 Frame-buffer"></a>5.4 Frame-buffer</h4><ul><li><strong>双缓存：</strong><ul><li>使用两个独立缓存，避免闪烁。</li></ul></li></ul><h4 id="5-5-渲染与建模"><a href="#5-5-渲染与建模" class="headerlink" title="5.5 渲染与建模"></a>5.5 渲染与建模</h4><ul><li><strong>建模：</strong><ul><li>创建模型，设置材质，将模型置于场景中，设置光源和摄像机。</li></ul></li><li><strong>渲染：</strong><ul><li>使用虚拟相机“拍照”，对顶点进行处理，生成fragment，并决定最终像素颜色。</li></ul></li></ul><h3 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h3><h4 id="6-1-渲染管线基本步骤"><a href="#6-1-渲染管线基本步骤" class="headerlink" title="6.1 渲染管线基本步骤"></a>6.1 渲染管线基本步骤</h4><ul><li><strong>顶点处理：</strong> 对每个顶点进行独立变换。</li><li><strong>光栅化：</strong> 将几何体转化为fragment。</li><li><strong>Fragment处理：</strong> 计算每个fragment的属性（如颜色）。</li><li><strong>合并：</strong> 将fragment合并为最终的像素。</li></ul><h2 id="计算机图形学-第五讲"><a href="#计算机图形学-第五讲" class="headerlink" title="计算机图形学 第五讲"></a>计算机图形学 第五讲</h2><h3 id="1-基本几何概念"><a href="#1-基本几何概念" class="headerlink" title="1. 基本几何概念"></a>1. 基本几何概念</h3><h4 id="1-1-几何定义与研究对象"><a href="#1-1-几何定义与研究对象" class="headerlink" title="1.1 几何定义与研究对象"></a>1.1 几何定义与研究对象</h4><ul><li><p><strong>几何研究的是n维空间中物体的表达</strong>。在计算机图形学中，关注的是二维和三维空间中的几何形态。</p><ul><li><strong>目标</strong>：通过最小的几何形状集合来表达复杂的物体。</li><li><strong>三种基本几何元素</strong>：<ol><li><strong>点（Point）</strong>：代表空间中的位置。</li><li><strong>标量（Scalar）</strong>：表示大小，但无方向。</li><li><strong>向量（Vector）</strong>：既有大小，也有方向。</li></ol></li></ul></li><li><p><strong>笛卡尔坐标系</strong>：点在空间中的位置用笛卡尔坐标表示，例如 (x, y, z)。通过代数运算可以操作这些点，但它并非物理空间的精确模拟。</p></li></ul><h4 id="1-2-标量与向量"><a href="#1-2-标量与向量" class="headerlink" title="1.2 标量与向量"></a>1.2 标量与向量</h4><ul><li><p><strong>标量（Scalar）</strong>：</p><ul><li>标量只有大小，没有方向。常见的标量运算如加法和乘法是闭合的，满足交换律、结合律，并具有逆运算。</li><li>标量本身没有几何意义。</li></ul></li><li><p><strong>向量（Vector）</strong>：</p><ul><li>向量同时具有大小和方向。可以表示力、速度等物理量。</li><li>向量通常在几何中表示为带有箭头的线段，箭头方向表示向量的方向，线段的长度表示向量的大小。</li><li>向量的运算可以通过加法、点积、叉积等方式进行。</li></ul></li></ul><h4 id="1-3-向量的运算"><a href="#1-3-向量的运算" class="headerlink" title="1.3 向量的运算"></a>1.3 向量的运算</h4><ul><li><p><strong>向量加法</strong>：</p><ul><li><strong>规则</strong>：向量的加法可以通过平行四边形法则实现。</li><li><strong>性质</strong>：向量加法满足交换律和结合律，每个向量都有逆元素。</li></ul></li><li><p><strong>向量点积（内积）</strong>：</p><ul><li><strong>定义</strong>：点积是两个向量分量相乘之和。</li><li><strong>用途</strong>：点积可以用于计算两个向量之间的夹角，也可以用于计算向量在另一个向量上的投影。</li><li><strong>公式</strong>：<br>$$<br>\mathbf{a} \cdot \mathbf{b} &#x3D; |\mathbf{a}| |\mathbf{b}| \cos(\theta)<br>$$<br>其中，θ 是两个向量之间的夹角。</li></ul></li><li><p><strong>向量叉积（外积）</strong>：</p><ul><li><strong>定义</strong>：叉积是仅在三维空间中定义的运算，其结果是一个垂直于原向量的向量。</li><li><strong>方向</strong>：叉积的方向由右手定则给出。</li><li><strong>公式</strong>：<br>$$<br>\mathbf{a} \times \mathbf{b} &#x3D; |\mathbf{a}| |\mathbf{b}| \sin(\theta) \mathbf{n}<br>$$<br>其中，θ 是两个向量之间的夹角，n 是垂直于 a 和 b 的单位向量。</li></ul></li></ul><h4 id="1-4-线性空间"><a href="#1-4-线性空间" class="headerlink" title="1.4 线性空间"></a>1.4 线性空间</h4><ul><li><strong>定义</strong>：线性空间，也称为向量空间，是由向量和标量组成的一个空间。在线性空间中，向量的加法和标量乘法满足特定的规则。</li><li><strong>矩阵的列向量空间</strong>：<ul><li>矩阵的列向量可以形成一个线性空间，矩阵乘法可以被看作是对向量的线性变换。</li></ul></li></ul><h4 id="1-5-点与向量的区别"><a href="#1-5-点与向量的区别" class="headerlink" title="1.5 点与向量的区别"></a>1.5 点与向量的区别</h4><ul><li><strong>向量无位置依赖</strong>：所有长度相等、方向一致的向量都是相等的，向量的存在与位置无关。</li><li><strong>点表示位置</strong>：点表示空间中的一个具体位置，通常需要通过向量从原点进行偏移来表示点的位置。</li></ul><h4 id="1-6-仿射空间"><a href="#1-6-仿射空间" class="headerlink" title="1.6 仿射空间"></a>1.6 仿射空间</h4><ul><li><strong>定义</strong>：仿射空间是一个包含标量、点和向量的空间，在该空间中可以进行向量和点的加法运算。</li><li><strong>坐标系的使用</strong>：仿射空间中的变换可以通过线性变换实现，将向量从一个坐标系变换到另一个坐标系。</li></ul><h4 id="1-7-线性组合与参数化表示"><a href="#1-7-线性组合与参数化表示" class="headerlink" title="1.7 线性组合与参数化表示"></a>1.7 线性组合与参数化表示</h4><ul><li><strong>线性组合</strong>：向量的线性组合是给定多个向量和标量的乘积的和。通过线性组合可以表示直线、曲线、平面等几何对象。</li><li><strong>参数化表示</strong>：<ul><li><strong>直线</strong>：可以通过线性组合的方式表示为<br>$$<br>\mathbf{P}(t) &#x3D; \mathbf{P}_0 + t(\mathbf{P}_1 - \mathbf{P}_0)<br>$$</li><li><strong>曲线</strong>：由一个参数决定，通常是非线性函数。</li><li><strong>曲面</strong>：由两个参数决定，通常也是非线性函数。</li></ul></li></ul><h3 id="2-表现形式"><a href="#2-表现形式" class="headerlink" title="2. 表现形式"></a>2. 表现形式</h3><h4 id="2-1-标架（Frame）"><a href="#2-1-标架（Frame）" class="headerlink" title="2.1 标架（Frame）"></a>2.1 标架（Frame）</h4><ul><li><strong>定义</strong>：标架是一个包含原点和基向量的坐标系。在几何学中，我们常通过标架来描述几何对象的位置和方向。</li><li><strong>基向量</strong>：n 维向量空间可以通过 n 个线性无关的基向量进行表示，任何向量都可以表示为基向量的线性组合。</li></ul><h4 id="2-2-齐次坐标"><a href="#2-2-齐次坐标" class="headerlink" title="2.2 齐次坐标"></a>2.2 齐次坐标</h4><ul><li><strong>定义</strong>：齐次坐标是一种表示点和向量的方法，统一了点和向量的表示形式。通过引入额外的一个维度，齐次坐标可以处理许多几何变换。</li><li><strong>点与向量的区别</strong>：在齐次坐标中，当 w &#x3D; 0 时，表示向量；当 w ≠ 0 时，表示点。</li><li><strong>应用</strong>：齐次坐标在计算机图形学中非常重要，所有的标准几何变换（如旋转、平移、缩放）都可以通过 4x4 矩阵进行齐次坐标的操作。</li></ul><h4 id="2-3-坐标系变换"><a href="#2-3-坐标系变换" class="headerlink" title="2.3 坐标系变换"></a>2.3 坐标系变换</h4><ul><li><strong>坐标变换</strong>：坐标系变换是通过基向量的线性组合实现的。当一个向量在一个坐标系中表示时，可以通过矩阵运算将其转换到另一个坐标系中。</li><li><strong>4x4 矩阵</strong>：在齐次坐标中，坐标系变换可以通过 4x4 的矩阵乘法来实现。这种矩阵形式统一了点和向量的表示，同时保证了计算效率。</li></ul><h4 id="2-4-齐次坐标的优势"><a href="#2-4-齐次坐标的优势" class="headerlink" title="2.4 齐次坐标的优势"></a>2.4 齐次坐标的优势</h4><ul><li><strong>统一的变换方式</strong>：齐次坐标能够统一点和向量的变换，使得硬件可以高效地进行三维几何的变换操作。</li><li><strong>矩阵叠加</strong>：多个变换可以通过矩阵乘法直接叠加，这使得复杂的变换可以通过简单的矩阵运算实现。</li></ul><h3 id="3-变换"><a href="#3-变换" class="headerlink" title="3. 变换"></a>3. 变换</h3><h4 id="3-1-广义变换"><a href="#3-1-广义变换" class="headerlink" title="3.1 广义变换"></a>3.1 广义变换</h4><ul><li><strong>定义</strong>：广义变换是从一个点或向量映射到另一个点或向量的过程。通过对点集进行变换，可以实现物体的变换。</li><li><strong>常见变换</strong>：包括平移、旋转、缩放、错切等变换。</li></ul><h4 id="3-2-仿射变换"><a href="#3-2-仿射变换" class="headerlink" title="3.2 仿射变换"></a>3.2 仿射变换</h4><ul><li><strong>定义</strong>：仿射变换是保持直线共线性的变换。它包括了物理世界中的许多重要变换，如平移、旋转、缩放、错切等。</li><li><strong>共线性</strong>：在仿射变换中，直线的端点进行变换后，其他点可以通过重新连接端点得到。</li></ul><h4 id="3-3-平移变换"><a href="#3-3-平移变换" class="headerlink" title="3.3 平移变换"></a>3.3 平移变换</h4><ul><li><p><strong>定义</strong>：平移变换是将点从一个位置移动到另一个位置的过程。</p></li><li><p><strong>公式</strong>：<br>$$<br>\mathbf{P’} &#x3D; \mathbf{P} + \mathbf{d}<br>$$<br>其中，d 是平移向量，表示平移的方向和距离。</p></li><li><p><strong>齐次坐标表示</strong>：  </p><div style="text-align: center;">$$T = \begin{pmatrix}1 & 0 & 0 & d_x \\0 & 1 & 0 & d_y \\0 & 0 & 1 & d_z \\0 & 0 & 0 & 1\end{pmatrix}$$</div><p>可以通过 4x4 齐次坐标矩阵表示平移变换。</p></li></ul><h4 id="3-4-旋转变换"><a href="#3-4-旋转变换" class="headerlink" title="3.4 旋转变换"></a>3.4 旋转变换</h4><ul><li><p><strong>二维旋转</strong>：</p><ul><li><strong>定义</strong>：二维旋转是以原点为旋转中心，将向量逆时针旋转一定的角度。该变换是线性的。</li><li><strong>公式</strong>：    <div style="text-align: center;">$$\mathbf{P}' = \begin{pmatrix}\cos(\theta) & -\sin(\theta) \\\sin(\theta) & \cos(\theta)\end{pmatrix}\mathbf{P}$$  </div>其中，θ 是旋转角度。</li></ul></li><li><p><strong>三维旋转</strong>：</p><ul><li><strong>绕任意轴旋转</strong>：三维旋转可以围绕任意轴进行，实现三维旋转的方式有多种，包括使用四元数和旋转矩阵。</li></ul></li><li><p><strong>四元数旋转</strong>：</p><ul><li><strong>优势</strong>：四元数是一种表示旋转的最佳方式之一，具有稳定的插值效果。四元数的冗余信息少，计算效率高。</li><li><strong>定义</strong>：四元数 q 可以表示为<br>$$<br>q &#x3D; w + xi + yj + zk<br>$$<br>其中，w, x, y, z 是实数，i, j, k 是单位四元数。</li></ul></li></ul><h4 id="3-5-非刚体变换"><a href="#3-5-非刚体变换" class="headerlink" title="3.5 非刚体变换"></a>3.5 非刚体变换</h4><ul><li><p><strong>缩放变换</strong>：</p><ul><li><strong>定义</strong>：缩放变换是改变物体大小的变换，可以分别对 x, y, z 轴进行不同的缩放。</li><li><strong>公式</strong>：  <div style="text-align: center;">$$S = \begin{pmatrix}s_x & 0 & 0 & 0 \\0 & s_y & 0 & 0 \\0 & 0 & s_z & 0 \\0 & 0 & 0 & 1 \\\end{pmatrix}$$</div>其中，s_x, s_y, s_z 是三个方向上的缩放系数。</li></ul></li><li><p><strong>错切变换</strong>：</p><ul><li><strong>定义</strong>：错切变换是一种将物体形变为平行四边形的变换。它可以沿一个轴方向对物体进行拉伸或压缩。</li><li><strong>公式</strong>： <div style="text-align: center;"> $$H = \begin{pmatrix}1 & k_x & 0 & 0 \\0 & 1 & k_y & 0 \\0 & 0 & 1 & 0 \\0 & 0 & 0 & 1 \\\end{pmatrix}$$</div>其中，k_x 和 k_y 是错切系数。</li></ul></li></ul><h4 id="3-6-矩阵表示"><a href="#3-6-矩阵表示" class="headerlink" title="3.6 矩阵表示"></a>3.6 矩阵表示</h4><ul><li><p><strong>矩阵运算</strong>：</p><ul><li>所有点和向量都可以表示为 4D 列向量，变换可以通过 4x4 矩阵进行。</li><li><strong>矩阵乘法</strong>：多个变换可以通过矩阵乘法进行叠加，变换的逆运算也可以通过矩阵求逆来实现。</li></ul></li><li><p><strong>矩阵乘法的非交换性</strong>：</p><ul><li>矩阵乘法不满足交换律，因此不同顺序的变换会得到不同的结果。</li></ul></li></ul><h3 id="4-OpenGL-中的变换"><a href="#4-OpenGL-中的变换" class="headerlink" title="4. OpenGL 中的变换"></a>4. OpenGL 中的变换</h3><h4 id="4-1-OpenGL-中的变换概述"><a href="#4-1-OpenGL-中的变换概述" class="headerlink" title="4.1 OpenGL 中的变换概述"></a>4.1 OpenGL 中的变换概述</h4><ul><li><strong>状态机</strong>：OpenGL 是一个状态机，变换矩阵是状态的一部分。在绘制顶点前必须设置好变换矩阵来达到预期的效果。</li><li><strong>建模</strong>：在建模过程中，物体通常是在物体坐标空间中定义的，需要通过变换将物体从其坐标空间移动到场景中。</li><li><strong>矩阵堆栈</strong>：OpenGL 提供了多个堆栈来保存不同类型的变换矩阵（如 Modelview、Projection、Texture）。</li></ul><h4 id="4-2-CTM（当前变换矩阵）"><a href="#4-2-CTM（当前变换矩阵）" class="headerlink" title="4.2 CTM（当前变换矩阵）"></a>4.2 CTM（当前变换矩阵）</h4><ul><li><strong>CTM</strong>：当前变换矩阵是一个 4x4 的齐次坐标矩阵，它可以通过一系列函数进行更改，并作用于渲染管线中后续定义的顶点上。</li></ul><h4 id="4-3-修改-CTM"><a href="#4-3-修改-CTM" class="headerlink" title="4.3 修改 CTM"></a>4.3 修改 CTM</h4><ul><li><p><strong>设置 CTM 模式</strong>：  </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glMatrixMode</span>(mode);</span><br></pre></td></tr></table></figure><p>mode 取值为 GL_MODELVIEW, GL_PROJECTION, GL_TEXTURE。</p></li><li><p><strong>载入 CTM</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">glLoadIdentity(void);</span><br><span class="line">glLoadMatrix&#123;fd&#125;(*m);</span><br></pre></td></tr></table></figure><p>m 是指针，指向长度为 16 的数组（column major）。</p></li><li><p><strong>乘 CTM</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">glMultMatrix&#123;fd&#125;(*m);</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-4-变换示例：沿任意轴旋转"><a href="#4-4-变换示例：沿任意轴旋转" class="headerlink" title="4.4 变换示例：沿任意轴旋转"></a>4.4 变换示例：沿任意轴旋转</h4><ul><li><strong>旋转示例</strong>：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glMatrixMode</span>(GL_MODELVIEW);</span><br><span class="line"><span class="built_in">glLoadIdentity</span>();</span><br><span class="line"><span class="built_in">glTranslatef</span>(<span class="number">4.0f</span>, <span class="number">3.0f</span>, <span class="number">2.0f</span>);</span><br><span class="line"><span class="built_in">glRotatef</span>(<span class="number">45.0f</span>, <span class="number">1.0f</span>, <span class="number">3.0f</span>, <span class="number">5.0f</span>);</span><br><span class="line"><span class="built_in">glTranslatef</span>(<span class="number">-4.0f</span>, <span class="number">-3.0f</span>, <span class="number">-2.0f</span>);</span><br><span class="line"><span class="built_in">glBegin</span>(...);</span><br><span class="line"><span class="built_in">glVertex</span>(...);</span><br><span class="line"><span class="built_in">glEnd</span>(...);</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-5-矩阵堆栈"><a href="#4-5-矩阵堆栈" class="headerlink" title="4.5 矩阵堆栈"></a>4.5 矩阵堆栈</h4><ul><li><strong>矩阵堆栈操作</strong>：<ul><li><code>glPushMatrix()</code>：将当前矩阵保存到堆栈顶。</li><li><code>glPopMatrix()</code>：将堆栈顶的矩阵恢复为当前矩阵。</li></ul></li></ul><h4 id="4-6-矩阵应用示例：绘制场景"><a href="#4-6-矩阵应用示例：绘制场景" class="headerlink" title="4.6 矩阵应用示例：绘制场景"></a>4.6 矩阵应用示例：绘制场景</h4><ul><li><strong>绘制单个物体</strong>：定义一个绘制单元立方体的函数 drawUnitBox()，使用 OpenGL 的 GL_TRIANGLE_STRIP 进行绘制。</li><li><strong>绘制桌子</strong>：通过缩放和平移操作绘制桌子的桌面和桌脚。</li><li><strong>绘制多个物体</strong>：通过 glPushMatrix() 和 glPopMatrix() 实现矩阵的保存和恢复，从而绘制多个物体。</li></ul><h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h3><h4 id="5-1-基本概念"><a href="#5-1-基本概念" class="headerlink" title="5.1 基本概念"></a>5.1 基本概念</h4><ul><li><strong>基本元素</strong>：点、标量、向量。</li><li><strong>线性空间与仿射空间</strong>：通过线性组合与齐次坐标实现。</li></ul><h4 id="5-2-变换"><a href="#5-2-变换" class="headerlink" title="5.2 变换"></a>5.2 变换</h4><ul><li><strong>常见变换</strong>：平移、旋转、缩放、错切。<ul><li>注意：多个变换合成时的顺序会影响最终的结果。</li></ul></li></ul><h4 id="5-3-OpenGL-实现"><a href="#5-3-OpenGL-实现" class="headerlink" title="5.3 OpenGL 实现"></a>5.3 OpenGL 实现</h4><ul><li><strong>变换函数</strong>：OpenGL 提供了多种函数来操作当前变换矩阵（CTM），如 glTranslate(), glScale(), glRotate() 等。</li></ul><h3 id="拓展内容说明："><a href="#拓展内容说明：" class="headerlink" title="拓展内容说明："></a>拓展内容说明：</h3><ol><li><strong>向量的运算</strong>：在向量的加法、点积和叉积部分，添加了公式和解释，帮助理解这些运算的几何意义。</li><li><strong>齐次坐标的优点</strong>：补充了齐次坐标在图形学中的优势，解释了为什么齐次坐标能够高效地表示三维变换。</li><li><strong>非刚体变换</strong>：对缩放和错切变换进行了详细的公式推导，帮助读者理解这些变换的矩阵形式。</li><li><strong>OpenGL 的矩阵操作</strong>：补充了如何在 OpenGL 中实现变换的具体代码示例，并解释了矩阵堆栈的作用和使用场景。</li></ol><h2 id="计算机图形学-第六讲"><a href="#计算机图形学-第六讲" class="headerlink" title="计算机图形学 第六讲"></a>计算机图形学 第六讲</h2><h3 id="1-二维观察"><a href="#1-二维观察" class="headerlink" title="1. 二维观察"></a>1. 二维观察</h3><h4 id="1-1-二维观察概述"><a href="#1-1-二维观察概述" class="headerlink" title="1.1 二维观察概述"></a>1.1 二维观察概述</h4><ul><li><strong>二维观察</strong>（2D Viewing）：主要指在有限的屏幕上绘制二维平面图形。</li><li><strong>问题</strong>：现实世界的二维平面可能是无限的，而屏幕有固定的大小，因此需要截取二维世界中的某个部分进行显示。<ul><li><strong>视窗（Window）</strong>：二维世界中的一个矩形区域，定义了要显示的内容。</li><li><strong>视口（Viewport）</strong>：屏幕上显示内容的区域，由像素组成。</li></ul></li></ul><h4 id="1-2-视窗与视口"><a href="#1-2-视窗与视口" class="headerlink" title="1.2 视窗与视口"></a>1.2 视窗与视口</h4><ul><li><strong>视窗（Window）</strong>：在二维世界中的一个连续的矩形区域，通常用一对坐标 (xmin, ymin) 和 (xmax, ymax) 来定义。</li><li><strong>视口（Viewport）</strong>：屏幕上由离散像素组成的矩阵。通过视窗的映射，内容会被绘制在视口内。</li></ul><h4 id="1-3-二维观察变换"><a href="#1-3-二维观察变换" class="headerlink" title="1.3 二维观察变换"></a>1.3 二维观察变换</h4><ul><li><strong>二维观察变换</strong>：将二维世界中的视窗映射到屏幕中的视口。这个过程涉及平移和缩放。<ul><li><strong>注意</strong>：屏幕空间的原点在左上角，y 轴向下。</li><li><strong>保持纵横比</strong>：为了避免图像变形，x 和 y 方向的缩放因子需要一致。即使视窗和视口的纵横比不一致，也要通过调整缩放因子来适配。</li></ul></li></ul><h4 id="1-4-OpenGL命令"><a href="#1-4-OpenGL命令" class="headerlink" title="1.4 OpenGL命令"></a>1.4 OpenGL命令</h4><ul><li><p><strong>gluOrtho2D</strong>：用于创建投影矩阵，将二维相机空间中的坐标变换为屏幕空间中的坐标。<br><code>gluOrtho2D(left, right, bottom, top);</code></p></li><li><p><strong>glViewport</strong>：定义最终绘制图像的视口，指定左下角位置 (x, y) 和视口的宽度与高度。<br><code>glViewport(x, y, width, height);</code></p></li></ul><h3 id="2-三维观察"><a href="#2-三维观察" class="headerlink" title="2. 三维观察"></a>2. 三维观察</h3><h4 id="2-1-三维观察概述"><a href="#2-1-三维观察概述" class="headerlink" title="2.1 三维观察概述"></a>2.1 三维观察概述</h4><ul><li><strong>三维观察（3D Viewing）</strong>：将三维世界投影到二维屏幕上。<ul><li><strong>区别于二维观察</strong>：三维观察的复杂性在于需要更多参数来控制观察角度和投影方式。</li><li><strong>降维</strong>：三维观察实际上是将三维空间的内容通过投影变换降维到二维平面上，类似于通过相机拍摄物体。</li></ul></li></ul><h4 id="2-2-建模与观察"><a href="#2-2-建模与观察" class="headerlink" title="2.2 建模与观察"></a>2.2 建模与观察</h4><ul><li><strong>建模变换</strong>：用于改变物体在世界坐标中的位置。</li><li><strong>观察变换</strong>：用于改变从世界坐标到屏幕的投影过程，它不会改变世界中的物体本身。</li></ul><h4 id="2-3-三维投影类型"><a href="#2-3-三维投影类型" class="headerlink" title="2.3 三维投影类型"></a>2.3 三维投影类型</h4><ul><li><p><strong>平行投影</strong>：投影线为平行线，投影方向称为 DOP（Direction of Projection）。</p><ul><li><strong>平面投影</strong>：保持了线性，直线仍然是直线，尽管平行线未必仍然平行。</li></ul></li><li><p><strong>透视投影</strong>：投影线汇聚于一点，称为 COP（Center of Projection）。这种投影方式模拟了“近大远小”的视觉效果。</p></li></ul><h4 id="2-4-经典观察"><a href="#2-4-经典观察" class="headerlink" title="2.4 经典观察"></a>2.4 经典观察</h4><ul><li><p><strong>多角度正交投影</strong>：投影平面平行于对象的某个主面，投影线垂直于投影平面。常见于 CAD 和建筑设计中。</p><ul><li><strong>优点</strong>：保持距离和角度不变，适用于精确测量。</li><li><strong>缺点</strong>：难以直观地观察物体的整体形状，通常需要添加等角投影图来帮助理解。</li></ul></li><li><p><strong>轴测投影</strong>：投影线仍然垂直于投影平面，但投影平面相对于对象的方向可以任意。会产生投影缩短现象，线段长度在图像空间中比对象空间中短。</p></li><li><p><strong>斜平行投影</strong>：一种最为一般的平行投影方式，投影线与投影平面成任意角度。常用于建筑物的图像生成。</p></li><li><p><strong>透视投影</strong>：投影线汇聚于一点，物体近大远小，并存在灭点（Vanishing Point）。透视投影不能保持平行，因此不能用于精确测量。</p></li></ul><h3 id="3-计算机观察"><a href="#3-计算机观察" class="headerlink" title="3. 计算机观察"></a>3. 计算机观察</h3><h4 id="3-1-计算机观察概述"><a href="#3-1-计算机观察概述" class="headerlink" title="3.1 计算机观察概述"></a>3.1 计算机观察概述</h4><ul><li><strong>虚拟照相机模型</strong>：计算机观察基于虚拟照相机模型，理论上可以生成任何一种经典投影图。<ul><li><strong>区别于经典观察</strong>：计算机图形学强调对象定义和相机参数设置的独立性。</li></ul></li></ul><h4 id="3-2-三个主要步骤"><a href="#3-2-三个主要步骤" class="headerlink" title="3.2 三个主要步骤"></a>3.2 三个主要步骤</h4><ul><li><p><strong>定位照相机</strong>：独立于对象的定义，设置相机的位置和方向。</p><ul><li><strong>通过修改 Modelview 矩阵实现</strong>。</li></ul></li><li><p><strong>设置透镜</strong>：选择平行投影或透视投影。</p><ul><li><strong>通过修改 Projection 矩阵实现</strong>。</li></ul></li><li><p><strong>设置裁剪体</strong>：定义视见体的范围，确定哪些内容将被投影到屏幕上。</p></li></ul><h4 id="3-3-OpenGL中的虚拟照相机"><a href="#3-3-OpenGL中的虚拟照相机" class="headerlink" title="3.3 OpenGL中的虚拟照相机"></a>3.3 OpenGL中的虚拟照相机</h4><ul><li><p><strong>初始状态</strong>：OpenGL 中的默认相机位于原点，朝向 z 轴负方向。默认的 frustum 是以原点为中心，宽度为 2 的立方体。</p></li><li><p><strong>Modelview 变换</strong>：负责描述物体和相机之间的相对运动。OpenGL 将建模和观察变换合并为一个 Modelview 变换，以提高计算效率。</p></li></ul><h3 id="4-定位照相机"><a href="#4-定位照相机" class="headerlink" title="4. 定位照相机"></a>4. 定位照相机</h3><h4 id="4-1-照相机的三要素"><a href="#4-1-照相机的三要素" class="headerlink" title="4.1 照相机的三要素"></a>4.1 照相机的三要素</h4><ul><li><strong>观察参考点（VRP, View Reference Point）</strong>：相机的观察参考位置。</li><li><strong>观察方向（View Direction）</strong>：相机的观察方向。</li><li><strong>正方向（Up Direction）</strong>：定义了视窗在观察参考平面上的角度。</li></ul><h4 id="4-2-观察坐标系"><a href="#4-2-观察坐标系" class="headerlink" title="4.2 观察坐标系"></a>4.2 观察坐标系</h4><ul><li><strong>初始状态</strong>：观察坐标系与世界坐标系重合。</li><li><strong>观察坐标系变换</strong>：通过 View Orientation Matrix 将世界坐标系变换为观察坐标系。</li></ul><h4 id="4-3-OpenGL中的定位照相机"><a href="#4-3-OpenGL中的定位照相机" class="headerlink" title="4.3 OpenGL中的定位照相机"></a>4.3 OpenGL中的定位照相机</h4><ul><li><p><strong>gluLookAt</strong>：用于设置相机位置和方向。  </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">gluLookAt</span>(</span><br><span class="line">    eyex, eyey, eyez,   <span class="comment">// 相机位置</span></span><br><span class="line">    atx, aty, atz,      <span class="comment">// 观察点</span></span><br><span class="line">    upx, upy, upz       <span class="comment">// 上方向向量</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p><strong>模型变换与观察变换</strong>：在 OpenGL 中，模型变换和观察变换被合并为一个 Modelview 矩阵。观察变换最先调用，应用于场景中的所有物体。</p></li></ul><h3 id="5-平行投影"><a href="#5-平行投影" class="headerlink" title="5. 平行投影"></a>5. 平行投影</h3><h4 id="5-1-正投影"><a href="#5-1-正投影" class="headerlink" title="5.1 正投影"></a>5.1 正投影</h4><ul><li><strong>正投影</strong>：场景中的所有物体沿垂直方向投影到观察参考平面上。</li><li><strong>正投影矩阵</strong>：<br><code>glOrtho(left, right, bottom, top, near, far);</code></li></ul><h4 id="5-2-斜平行投影"><a href="#5-2-斜平行投影" class="headerlink" title="5.2 斜平行投影"></a>5.2 斜平行投影</h4><ul><li><strong>斜平行投影</strong>：投影线与投影平面成任意角度。可以视为正投影与错切变换的组合：<ul><li><strong>错切变换矩阵</strong>：  <div style="text-align: center;">$$M = \begin{bmatrix}1 & 0 & \cot(\alpha) & 0 \\0 & 1 & \cot(\beta) & 0 \\0 & 0 & 0 & 0 \\0 & 0 & 0 & 1\end{bmatrix}$$</div></li></ul></li></ul><h3 id="6-透视投影"><a href="#6-透视投影" class="headerlink" title="6. 透视投影"></a>6. 透视投影</h3><h4 id="6-1-透视投影概述"><a href="#6-1-透视投影概述" class="headerlink" title="6.1 透视投影概述"></a>6.1 透视投影概述</h4><ul><li><strong>透视投影</strong>：投影线汇聚于一点，模拟真实世界中的视觉效果。</li><li><strong>特点</strong>：近大远小，存在灭点。透视投影是保直线的，但不是仿射变换。</li></ul><h4 id="6-2-齐次坐标中的透视投影"><a href="#6-2-齐次坐标中的透视投影" class="headerlink" title="6.2 齐次坐标中的透视投影"></a>6.2 齐次坐标中的透视投影</h4><ul><li><p><strong>透视投影矩阵</strong>：  </p><div style="text-align: center;">$$P = \begin{bmatrix}1 & 0 & 0 & 0 \\0 & 1 & 0 & 0 \\0 & 0 & 1 & \frac{1}{d} \\0 & 0 & 1 & 0\end{bmatrix}$$</div>其中，d 是投影距离。</li><li><p><strong>透视除法</strong>：透视投影的非线性缩短效果通过透视除法实现，离投影中心越远，缩短越大。</p></li></ul><h4 id="6-3-OpenGL中的透视投影"><a href="#6-3-OpenGL中的透视投影" class="headerlink" title="6.3 OpenGL中的透视投影"></a>6.3 OpenGL中的透视投影</h4><ul><li><p><strong>glFrustum</strong>：定义视锥体，用于透视投影。<br><code>glFrustum(left, right, bottom, top, near, far);</code></p></li><li><p><strong>gluPerspective</strong>：简化透视投影的定义。<br><code>gluPerspective(fovy, aspect, near, far);</code></p></li></ul><h3 id="7-小结"><a href="#7-小结" class="headerlink" title="7. 小结"></a>7. 小结</h3><ul><li><strong>二维观察</strong>：通过视窗和视口的映射，将二维世界的内容映射到屏幕上。</li><li><strong>三维观察</strong>：通过投影将三维世界内容映射到二维屏幕上，常用两种投影方式：平行投影和透视投影。</li><li><strong>计算机观察</strong>：通过虚拟相机模型实现三维场景的投影，涉及设置相机位置、投影方式和裁剪体。</li></ul><h3 id="拓展内容说明：-1"><a href="#拓展内容说明：-1" class="headerlink" title="拓展内容说明："></a>拓展内容说明：</h3><ol><li><strong>向量的运算</strong>：在向量的加法、点积和叉积部分，添加了公式和解释，帮助理解这些运算的几何意义。</li><li><strong>齐次坐标的优点</strong>：补充了齐次坐标在图形学中的优势，解释了为什么齐次坐标能够高效地表示三维变换。</li><li><strong>非刚体变换</strong>：对缩放和错切变换进行了详细的公式推导，帮助读者理解这些变换的矩阵形式。</li><li><strong>OpenGL 的矩阵操作</strong>：补充了如何在 OpenGL 中实现变换的具体代码示例，并解释了矩阵堆栈的作用和使用场景。</li></ol><h2 id="计算机图形学-第七讲"><a href="#计算机图形学-第七讲" class="headerlink" title="计算机图形学 第七讲"></a>计算机图形学 第七讲</h2><h3 id="1-光栅化简介"><a href="#1-光栅化简介" class="headerlink" title="1. 光栅化简介"></a>1. 光栅化简介</h3><h4 id="1-1-光栅化定义"><a href="#1-1-光栅化定义" class="headerlink" title="1.1 光栅化定义"></a>1.1 光栅化定义</h4><ul><li><strong>光栅化</strong>是将几何图元（如线段、多边形等）转换为像素的过程。通过光栅化，图形被离散化为屏幕上的像素。</li><li>与之对应的是<strong>光线追踪</strong>，它通过模拟光线传播来生成图像。</li><li><strong>Raster graphics</strong> 操作像素，而 <strong>Vector graphics</strong> 操作几何元素，但最终都需转换成像素。</li></ul><h4 id="1-2-计算机图形绘制过程"><a href="#1-2-计算机图形绘制过程" class="headerlink" title="1.2 计算机图形绘制过程"></a>1.2 计算机图形绘制过程</h4><ul><li><strong>投影</strong>：将几何图元的顶点从三维空间映射到二维平面。</li><li><strong>光栅化</strong>：将几何图元从连续的几何对象转换为离散的像素。<ul><li>决定哪些像素与图元相关。</li><li>确定每个像素的颜色。</li><li>通过一系列高效的扫描转换算法在硬件上实现。</li></ul></li></ul><h3 id="2-线段光栅化"><a href="#2-线段光栅化" class="headerlink" title="2. 线段光栅化"></a>2. 线段光栅化</h3><h4 id="2-1-绘制目标"><a href="#2-1-绘制目标" class="headerlink" title="2.1 绘制目标"></a>2.1 绘制目标</h4><ul><li>使用像素绘制两点 <code>(x1, y1)</code> 与 <code>(x2, y2)</code> 之间的线段。<ul><li>选中像素应尽可能靠近理想线段。</li><li>绘制出的线段应看起来尽量“直”。</li><li>起点应包括在像素序列中。</li><li>绘制应尽可能快速。</li></ul></li></ul><h4 id="2-2-思路一：使用解析式"><a href="#2-2-思路一：使用解析式" class="headerlink" title="2.2 思路一：使用解析式"></a>2.2 思路一：使用解析式</h4><ul><li>直线可以表示为方程 <code>y = mx + c</code>，其中 m 为斜率，c 为截距。</li><li><strong>DDA 算法</strong>（Digital Differential Analyzer）通过递增 x 来计算 y 的变化。</li></ul><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">line_DDA</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> dx = x2 - x1, dy = y2 - y1, steps;</span><br><span class="line">    <span class="type">float</span> delta_x, delta_y, x = x1, y = y1;</span><br><span class="line"></span><br><span class="line">    steps = (<span class="built_in">abs</span>(dx) &gt; <span class="built_in">abs</span>(dy)) ? (<span class="built_in">abs</span>(dx)) : (<span class="built_in">abs</span>(dy));</span><br><span class="line">    delta_x = dx / (<span class="type">float</span>)steps;</span><br><span class="line">    delta_y = dy / (<span class="type">float</span>)steps;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_pixel</span>(<span class="built_in">round</span>(x), <span class="built_in">round</span>(y));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; steps; ++i) &#123;</span><br><span class="line">        x += delta_x;</span><br><span class="line">        y += delta_y;</span><br><span class="line">        <span class="built_in">set_pixel</span>(<span class="built_in">round</span>(x), <span class="built_in">round</span>(y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-思路二：Bresenham-算法"><a href="#2-3-思路二：Bresenham-算法" class="headerlink" title="2.3 思路二：Bresenham 算法"></a>2.3 思路二：Bresenham 算法</h4><ul><li><strong>Bresenham’s Algorithm</strong> 提供了一种更高效的线段绘制方法。<ul><li>它仅使用整数运算，避免了 DDA 中的浮点运算。</li><li>通过比较像素与直线的相对位置，判断下一步需要绘制的像素是 <code>(xi + 1, yi)</code> 还是 <code>(xi + 1, yi + 1)</code>。</li></ul></li></ul><p>Bresenham 算法 伪代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void line_Bresenham(int x1, int y1, int x2, int y2) &#123;</span><br><span class="line">    int dx = x2 - x1</span><br><span class="line">    int dy = y2 - y1</span><br><span class="line">    int p = 2 * dy - dx</span><br><span class="line">    int y = y1</span><br><span class="line">    </span><br><span class="line">    for (int x = x1; x &lt;= x2; ++x) &#123;</span><br><span class="line">        set_pixel(x, y)</span><br><span class="line">        if (p &gt;= 0) &#123;</span><br><span class="line">            y += 1</span><br><span class="line">            p += 2 * (dy - dx)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            p += 2 * dy</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准代码示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_pixel</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在此处实现绘制像素的逻辑</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Drawing pixel at (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">line_Bresenham</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> dx = x2 - x1;</span><br><span class="line">    <span class="type">int</span> dy = y2 - y1;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">2</span> * dy - dx;</span><br><span class="line">    <span class="type">int</span> y = y1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = x1; x &lt;= x2; ++x) &#123;</span><br><span class="line">        <span class="built_in">set_pixel</span>(x, y);</span><br><span class="line">        <span class="keyword">if</span> (p &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            y += <span class="number">1</span>;</span><br><span class="line">            p += <span class="number">2</span> * (dy - dx);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p += <span class="number">2</span> * dy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 示例：绘制从 (2, 3) 到 (10, 7) 的直线</span></span><br><span class="line">    <span class="built_in">line_Bresenham</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>解释</p><ul><li>参数:<ul><li>x1, y1: 线段起点坐标。</li><li>x2, y2: 线段终点坐标。</li></ul></li></ul></li><li><p>变量:</p><ul><li>dx: 线段在 x 方向上的变化量。</li><li>dy: 线段在 y 方向上的变化量。</li><li>p: 决策变量，用于判断下一个像素的 y 坐标。</li><li>y: 当前绘制的 y 坐标。</li></ul></li><li><p>算法过程:</p><ul><li>计算 dx 和 dy。</li><li>初始化决策变量 p。</li><li>在 x 方向上循环，从 x1 到 x2：<ul><li>绘制当前像素。</li><li>根据 p 的值决定 y 是否增加，更新 p 的值。</li></ul></li></ul></li><li><p>应用</p><ul><li>Bresenham 算法被广泛应用于图形学中，用于高效地绘制直线。由于其只使用整数运算，因此在性能和精度上都优于浮点运算的方法。</li></ul></li></ul><h3 id="3-多边形光栅化"><a href="#3-多边形光栅化" class="headerlink" title="3. 多边形光栅化"></a>3. 多边形光栅化</h3><h4 id="3-1-多边形光栅化概述"><a href="#3-1-多边形光栅化概述" class="headerlink" title="3.1 多边形光栅化概述"></a>3.1 多边形光栅化概述</h4><ul><li><strong>多边形光栅化</strong>决定哪些像素与多边形相关。常见的两种方法为：<ul><li><strong>扫描转换</strong>（Scan-conversion）：沿扫描线逐行扫描，设置边界内的像素。</li><li><strong>填充</strong>（Fill）：从多边形内部的某个像素开始向外扩展。</li></ul></li></ul><h4 id="3-2-判断点是否在多边形内"><a href="#3-2-判断点是否在多边形内" class="headerlink" title="3.2 判断点是否在多边形内"></a>3.2 判断点是否在多边形内</h4><ul><li><strong>Even-odd 测试</strong>：如果从多边形外任意一点引出一条直线与多边形的边相交次数为奇数，则点在多边形内。</li><li><strong>Winding number 测试</strong>：计算多边形围绕该点的转角度数，如果转角度不为零，该点在多边形内。</li></ul><h4 id="3-3-三角形光栅化"><a href="#3-3-三角形光栅化" class="headerlink" title="3.3 三角形光栅化"></a>3.3 三角形光栅化</h4><ul><li><strong>任意多边形可拆分为多个三角形</strong>。三角形光栅化是多边形光栅化的基础。</li><li><strong>插值计算颜色</strong>：常使用基于<strong>重心坐标</strong>（Barycentric Coordinate）的插值方法。</li></ul><p>公式如下：<br>$$<br>p &#x3D; (1 - a - b) * p1 + a * p2 + b * p3;<br>$$</p><ul><li><strong>Edge-equation 方法</strong>：通过判断点是否位于三角形的三条边的同一侧来确定点是否在三角形内。</li></ul><h3 id="4-抗锯齿"><a href="#4-抗锯齿" class="headerlink" title="4. 抗锯齿"></a>4. 抗锯齿</h3><h4 id="4-1-锯齿现象"><a href="#4-1-锯齿现象" class="headerlink" title="4.1 锯齿现象"></a>4.1 锯齿现象</h4><ul><li><strong>锯齿现象</strong>（Aliasing）是由于对几何物体的离散化导致的。它包括：<ul><li>边缘的锯齿状效果。</li><li>渲染细节丢失。</li><li>微小物体的丢失。</li></ul></li></ul><h4 id="4-2-抗锯齿方法"><a href="#4-2-抗锯齿方法" class="headerlink" title="4.2 抗锯齿方法"></a>4.2 抗锯齿方法</h4><ul><li><p><strong>超级采样抗锯齿（Super-sampling anti-aliasing, SSAA）</strong>：</p><ul><li>在比目标分辨率更高的分辨率下进行采样，然后将多个像素合并为一个像素。</li></ul></li><li><p><strong>比率方法（Ratio method）</strong>：</p><ul><li>根据像素到线段的距离来决定颜色比例。</li></ul></li><li><p><strong>区域采样（Area sampling）</strong>：</p><ul><li>扫描几何图元覆盖的像素区域，并根据像素距离边界的远近调整颜色。</li></ul></li></ul><h4 id="4-3-显卡上的常见抗锯齿设置"><a href="#4-3-显卡上的常见抗锯齿设置" class="headerlink" title="4.3 显卡上的常见抗锯齿设置"></a>4.3 显卡上的常见抗锯齿设置</h4><ul><li><p><strong>多重采样抗锯齿（MSAA）</strong>：</p><ul><li>只对多边形的边缘进行抗锯齿处理，比 SSAA 更高效。</li></ul></li><li><p><strong>快速近似抗锯齿（FXAA）</strong>：</p><ul><li>一种基于后期处理的抗锯齿方法，完全使用图像处理方式进行模糊。</li></ul></li></ul><h3 id="5-小结-1"><a href="#5-小结-1" class="headerlink" title="5. 小结"></a>5. 小结</h3><ul><li><strong>光栅化</strong>是计算机图形学中将几何图元转化为像素的过程。</li><li><strong>Bresenham 算法</strong>通过整数运算提供了高效的线段绘制方法。</li><li><strong>多边形光栅化</strong>可通过扫描转换或填充方法来实现，三角形光栅化是其基础。</li><li><strong>抗锯齿</strong>用于解决离散化过程中出现的锯齿问题，常用的方法包括超级采样和区域采样。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CG ≠ CV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tencent 蓝鲸智云开发</title>
      <link href="/2024/11/20/Tencent_Practical_Training/"/>
      <url>/2024/11/20/Tencent_Practical_Training/</url>
      
        <content type="html"><![CDATA[<h1 id="云平台运维开发实践（腾讯蓝鲸合作项目）"><a href="#云平台运维开发实践（腾讯蓝鲸合作项目）" class="headerlink" title="云平台运维开发实践（腾讯蓝鲸合作项目）"></a>云平台运维开发实践（腾讯蓝鲸合作项目）</h1><h2 id="手把手搭建蓝鲸开发框架环境（Windows-系统-）"><a href="#手把手搭建蓝鲸开发框架环境（Windows-系统-）" class="headerlink" title="手把手搭建蓝鲸开发框架环境（Windows 系统 ）"></a>手把手搭建蓝鲸开发框架环境（Windows 系统 ）</h2><h2 id="基本开发部署"><a href="#基本开发部署" class="headerlink" title="基本开发部署"></a>基本开发部署</h2><h2 id="主机资源管理"><a href="#主机资源管理" class="headerlink" title="主机资源管理"></a>主机资源管理</h2><h2 id="主机日志备份"><a href="#主机日志备份" class="headerlink" title="主机日志备份"></a>主机日志备份</h2><h2 id="用户画像分析"><a href="#用户画像分析" class="headerlink" title="用户画像分析"></a>用户画像分析</h2><p>这部分有点复杂喵，笔者尚未整理喵呜</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operation System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Who is Lavoisier</title>
      <link href="/2024/11/20/Who_is_Lavoisier/"/>
      <url>/2024/11/20/Who_is_Lavoisier/</url>
      
        <content type="html"><![CDATA[<p><strong>他以非凡的智慧，引领化学从朦胧的定性迷雾，步入了精确的定量殿堂；</strong></p><p><strong>他轻挥命名的魔杖，赋予氧以生命的气息，氢以轻盈的灵魂，让元素世界拥有了永恒的标签；</strong></p><p><strong>他洞悉未知的奥秘，如同预言家般，在迷雾中勾勒出硅的轮廓，为化学宝库添上了一颗璀璨的明珠；</strong></p><p><strong>他不仅是一位探索者，更是度量衡的筑梦师，携手先驱，共同奠定了公制的基石，让科学的语言得以统一，跨越时空传递真理的回响。</strong></p><h3 id="拉瓦锡：化学革命的先驱者，智慧星空的璀璨星辰"><a href="#拉瓦锡：化学革命的先驱者，智慧星空的璀璨星辰" class="headerlink" title="拉瓦锡：化学革命的先驱者，智慧星空的璀璨星辰"></a>拉瓦锡：化学革命的先驱者，智慧星空的璀璨星辰</h3><h4 id="化学界的牛顿，理性光辉的引领者"><a href="#化学界的牛顿，理性光辉的引领者" class="headerlink" title="化学界的牛顿，理性光辉的引领者"></a>化学界的牛顿，理性光辉的引领者</h4><p>在1743年8月26日那个晨曦微露的清晨，法国巴黎的一户富裕家庭中，安托万-洛朗·德·拉瓦锡（Antoine-Laurent de Lavoisier），这位日后将化学界带入全新纪元的巨擘，悄然降临于世。自幼年起，拉瓦锡便以他那对自然科学近乎痴迷的热爱与超乎常人的天赋，预示着他将在科学史上书写下不朽的篇章。他，被誉为“现代化学之父”，是化学革命的领航者，其名字如同星辰般在科学的夜空中熠熠生辉。</p><p>拉瓦锡的贡献，宛如一把锋利的手术刀，精准地剖析了物质变化的奥秘。通过一系列精妙绝伦的实验设计，他犹如一位洞察秋毫的智者，揭示了质量守恒定律——在化学反应的纷繁复杂中，物质的总质量始终如一，这一发现如同一记重锤，击碎了沿袭数百年的燃素说迷雾，为化学研究铺设了一条通往定量分析的康庄大道。他首次提出了“氧气”这一革命性的概念，如同一束穿透迷雾的光芒，照亮了燃烧与腐蚀的本质，揭示了这些过程实为物质与空气中氧气亲密共舞的奥秘。拉瓦锡的成就，不仅推动了化学科学的飞速发展，更为后世科学家开辟了一片全新的思维疆域。</p><h4 id="多领域建树，科学探索的无界行者"><a href="#多领域建树，科学探索的无界行者" class="headerlink" title="多领域建树，科学探索的无界行者"></a>多领域建树，科学探索的无界行者</h4><p>拉瓦锡的才华与兴趣，犹如江河之水，滔滔不绝，不仅限于化学领域。在生物学、地质学等多个学科的广袤天地间，他同样留下了深刻的足迹。在农业化学领域，他的研究如同春雨般滋润了农业生产的土壤，促进了肥料的应用与发展，显著提升了农业生产的效率，为人类的温饱事业贡献了不可磨灭的力量。拉瓦锡的多才多艺与广泛兴趣，使他成为了科学史上的一座丰碑，其身影在多个学科领域内熠熠生辉，无人能及。</p><h4 id="科学伴侣玛丽-安娜：爱与智慧的双重交响"><a href="#科学伴侣玛丽-安娜：爱与智慧的双重交响" class="headerlink" title="科学伴侣玛丽-安娜：爱与智慧的双重交响"></a>科学伴侣玛丽-安娜：爱与智慧的双重交响</h4><p>在拉瓦锡辉煌的科学生涯中，玛丽-安娜·皮埃尔特·保罗泽（Marie-Anne Pierrette Paulze）的身影始终如影随形，如同一首动人的交响乐，为这段科学传奇增添了无尽的温情与色彩。1771年，年仅13岁的玛丽-安娜，以一颗纯真而炽热的心，嫁给了比她年长15岁的拉瓦锡。这段婚姻，超越了世俗的界限，是心灵的深度契合，是智慧与情感的完美交融。玛丽-安娜不仅拥有美貌与才华，更对科学抱有无尽的热爱与追求。她精通多国语言，擅长绘画与音乐，但最为人称道的，是她对科学的无限热情与执着。</p><p>在拉瓦锡的研究中，玛丽-安娜不仅是默默的支持者，更是不可或缺的伙伴。她自学化学知识，掌握实验室技能，成为了拉瓦锡最得力的助手。她绘制的化学仪器图谱，精美绝伦，宛如艺术品，为当时的科学研究提供了宝贵的视觉资料。她翻译英文与拉丁文的科学文献，为拉瓦锡提供了最前沿的科研信息。在实验室内，她与拉瓦锡并肩作战，共同探索未知的奥秘；在日常生活中，她给予他无微不至的关怀与支持，让拉瓦锡得以全身心投入科学研究。</p><h4 id="革命风暴下的悲壮落幕与永恒的瞬间"><a href="#革命风暴下的悲壮落幕与永恒的瞬间" class="headerlink" title="革命风暴下的悲壮落幕与永恒的瞬间"></a>革命风暴下的悲壮落幕与永恒的瞬间</h4><p>然而，命运的波澜总是难以预料。法国大革命的风暴如狂风骤雨般席卷整个国家，社会动荡不安。作为税务官的拉瓦锡，因被指控参与不公的税收制度而身陷囹圄。尽管众多科学家与社会名流纷纷为他求情，但终究未能改变命运的走向。1794年5月8日，拉瓦锡被送上了断头台，他短暂而辉煌的一生就此画上了悲壮的句号。然而，就在这生命的最后一刻，拉瓦锡并未选择默默接受命运，而是以一种悲壮的方式，进行了一项震惊后世的实验——断头实验。他向刽子手提出了一个惊人的请求：在头颅被砍下的瞬间，请刽子手仔细观察他的眼睛，如果他还有意识的话，会通过眨眼来表示。刽子手被拉瓦锡的勇气和决心所打动，勉强答应了这个请求。</p><p>在头颅被砍下的瞬间，刽子手惊奇地发现，拉瓦锡的眼睛竟然连续眨了11次！这一发现震惊了在场的所有人，也引发了后世科学家对“人被砍头后是否还有意识”这一问题的广泛关注。拉瓦锡的这一行为，不仅是对科学的一次勇敢探索，更是对生命的一次深刻反思。这一瞬间，定格了拉瓦锡的生命，也永恒地铭刻在了科学史上。</p><p>玛丽-安娜在失去丈夫的悲痛中，却未曾沉沦。她以惊人的毅力和决心，继续着丈夫未竟的事业。她整理出版了拉瓦锡的遗作，确保了其科学遗产得以流传后世。她积极参与科学教育，培养了一批批优秀的年轻科学家，为科学事业的发展注入了新的活力。玛丽-安娜以行动证明，即使在最黑暗的时刻，光明也能穿透阴霾，照亮前行的道路。</p><h4 id="永恒的光辉，照亮科学的征途"><a href="#永恒的光辉，照亮科学的征途" class="headerlink" title="永恒的光辉，照亮科学的征途"></a>永恒的光辉，照亮科学的征途</h4><p>拉瓦锡与玛丽-安娜的故事，如同一部跨越时空的史诗，不仅是一段跨越年龄的爱情传奇，更是科学与人文精神交织的赞歌。拉瓦锡的科学成就，不仅奠定了现代化学的基石，更深刻影响了众多学科的发展。玛丽-安娜的支持与奉献，则是他成功背后最坚实的力量。他们的故事，如同璀璨的星辰，永远照亮着后来者的道路，告诉我们：无论面临多大的困难与挑战，只要有坚定的信念与不懈的努力，就能创造出不朽的成就。</p><p>拉瓦锡在断头台上的那一眨眼，仿佛是对后来者的无声激励，提醒着我们，即使在生命的尽头，也要保持对知识的渴望，对真理的追求。正如拉瓦锡所言：“在科学上没有平坦的大道可走，只有不畏艰险沿着陡峭山路攀登的人，才有希望达到光辉的顶点。”这句话，不仅是他个人奋斗的真实写照，更是对所有追求真理者的鼓舞与激励。拉瓦锡与玛丽-安娜的故事，如同一盏明灯，永远照亮着科学的征途，激励着后来者勇往直前，不断探索未知的世界，追寻那永恒的光辉。</p><p><em>倘若您的目光有幸触及此言，衷心感激您能耐心品读至终。让我们在心灵的深处，共同向他致以最崇高的敬意，感激他的光辉成就，如同星辰般永恒照耀着科学的征途。</em></p>]]></content>
      
      
      <categories>
          
          <category> Before Starting </category>
          
      </categories>
      
      
        <tags>
            
            <tag> history </tag>
            
            <tag> Who am &quot;I&quot; </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/11/19/Hello_World/"/>
      <url>/2024/11/19/Hello_World/</url>
      
        <content type="html"><![CDATA[<p>在人类文明的历史长河中，有些时刻如同流星划过夜空，短暂而耀眼；而有些，则像恒星般长久地照亮着未来的道路。“Hello World”，这短短几个字，就是计算机时代一颗永不熄灭的星辰。它不仅是程序员职业生涯中的第一个里程碑，更是连接过去辉煌与未来无限可能的纽带。</p><h4 id="回溯时光：计算机的起源与进化"><a href="#回溯时光：计算机的起源与进化" class="headerlink" title="回溯时光：计算机的起源与进化"></a>回溯时光：计算机的起源与进化</h4><h5 id="梦想的起点"><a href="#梦想的起点" class="headerlink" title="梦想的起点"></a>梦想的起点</h5><p>故事要从19世纪讲起，当时英国数学家查尔斯·巴贝奇构想了一种能够自动执行计算任务的机械装置——差分机。虽然因为技术和资金的限制未能完成，但它为后来的计算机科学家们提供了宝贵的灵感。巴贝奇的梦想，就像一颗种子，最终在20世纪结出了硕果。</p><h5 id="战火中的巨人"><a href="#战火中的巨人" class="headerlink" title="战火中的巨人"></a>战火中的巨人</h5><p>二战期间，为了破解德军的密码系统，英国数学家艾伦·图灵设计了图灵机，这是一种理论上能够解决所有可计算问题的模型。而到了1943年，美国宾夕法尼亚大学研制成功了世界上第一台电子计算机ENIAC，它拥有惊人的计算速度，能够处理复杂的军事计算任务。ENIAC的出现，标志着电子计算机时代的正式开启。</p><h5 id="编程语言的革命"><a href="#编程语言的革命" class="headerlink" title="编程语言的革命"></a>编程语言的革命</h5><p>随着时间的流逝，计算机开始逐渐走出实验室，进入大学、企业和家庭。但是，早期的编程工作异常艰难，程序员需要直接用二进制代码编写程序。直到20世纪50年代末期，FORTRAN（公式翻译器）的问世彻底改变了这一局面，它允许程序员使用接近自然语言的命令来编写程序，极大地提高了开发效率。从此以后，更多高级编程语言如雨后春笋般涌现，包括COBOL、LISP、C语言等，它们共同推动了软件行业的繁荣。</p><h4 id="Hello-World：编程之旅的起点"><a href="#Hello-World：编程之旅的起点" class="headerlink" title="Hello World：编程之旅的起点"></a>Hello World：编程之旅的起点</h4><h5 id="第一缕晨光"><a href="#第一缕晨光" class="headerlink" title="第一缕晨光"></a>第一缕晨光</h5><p>1978年，对于无数程序员来说，是值得纪念的一年。这一年，《The C Programming Language》一书出版，书中包含了这样一个简单的例子：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码虽小，意义非凡。它就像是编程世界的第一缕晨光，温暖而明亮，指引着后来者踏上探索未知的道路。</p><h5 id="传承与发展"><a href="#传承与发展" class="headerlink" title="传承与发展"></a>传承与发展</h5><p>从那以后，“Hello World”成为了编程教育的传统，几乎每个学习编程的人都是从这里起步。无论是初学者还是经验丰富的开发者，每当他们面对一种全新的编程语言或开发环境时，都会首先尝试运行这段经典的代码。它不仅是一个练习，更是一种仪式，象征着对知识的渴望和对创新的追求。</p><h4 id="数字时代的交响乐章"><a href="#数字时代的交响乐章" class="headerlink" title="数字时代的交响乐章"></a>数字时代的交响乐章</h4><h5 id="创造者的乐园"><a href="#创造者的乐园" class="headerlink" title="创造者的乐园"></a>创造者的乐园</h5><p>如今，计算机技术已经渗透到生活的每一个角落，从智能手机到智能家居，从虚拟现实到人工智能，技术的发展正以前所未有的速度改变着世界。而这一切的背后，都离不开那些勇于探索、不断求知的程序员们。他们用一行行代码构建起了数字世界的基石，让梦想照进了现实。</p><h5 id="未来的诗篇"><a href="#未来的诗篇" class="headerlink" title="未来的诗篇"></a>未来的诗篇</h5><p>面对未来，我们有理由相信，计算机科学将继续书写更加辉煌的篇章。“Hello World”不仅仅是一句问候，它代表着每一次技术突破带来的喜悦，每一个难题被解决后的成就感，以及对美好未来的无限憧憬。正如诗人笔下的诗篇，既有对过去的回忆，也有对当下的感悟，更有对未来的向往。</p><p>在这个由代码编织的世界里，每一个程序员都是诗人，他们用智慧和创造力谱写着属于自己的故事。而“Hello World”，则永远是这首壮丽史诗中最动听的开篇。</p><p>让我们一起，向着更加美好的未来，发出最响亮的呼唤：</p><p><strong>“Hello World！”</strong></p><p>特别鸣谢大佬“闪烁之狐”提供的<code>theme</code>————<code>matery</code>.受益匪浅，顶礼膜拜！</p>]]></content>
      
      
      <categories>
          
          <category> Before Starting </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hello World! </tag>
            
            <tag> history </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Computer Network</title>
      <link href="/2024/11/19/Computer_Network/"/>
      <url>/2024/11/19/Computer_Network/</url>
      
        <content type="html"><![CDATA[<p>本文基于《Computer Networking A Top-Down Approach (7th Edition)》的课本内容，对 SYSU-CSE DCS222 计算机核心专业课《计算机网络》进行较为详尽的知识点总结，涵盖少量实例分析。</p><h2 id="第一章：计算机网络概论"><a href="#第一章：计算机网络概论" class="headerlink" title="第一章：计算机网络概论"></a>第一章：计算机网络概论</h2><p>本章为引言，介绍计算机领域的发展趋势，结合 <a href="https://www.gartner.com/cn/newsroom/press-releases/2024-emerging-tech-hc">Gartner 2024年新兴技术成熟度曲线</a> </p><h3 id="1-1-重要性与应用领域"><a href="#1-1-重要性与应用领域" class="headerlink" title="1.1 重要性与应用领域"></a>1.1 重要性与应用领域</h3><p><strong>1. 关键应用领域</strong></p><ul><li>互联网</li><li>移动网络</li><li>云计算 </li><li>电子商务</li><li>交通运输</li><li>国家安全</li><li>软件定义网络(SDN)</li></ul><h3 id="1-2-基本概念与原理"><a href="#1-2-基本概念与原理" class="headerlink" title="1.2 基本概念与原理"></a>1.2 基本概念与原理</h3><p><strong>1. 网络通信类比</strong></p><ul><li>通过邮政系统类比理解网络通信过程</li><li>信封对应数据包</li><li>分拣中心对应路由器</li><li>传输过程的特点:<ul><li>逐个路由</li><li>无时间保证</li><li>无序到达</li><li>可能丢失</li></ul></li></ul><p><strong>2. 网络分层结构</strong></p><ul><li>应用层(Application Layer)</li><li>传输层(Transport Layer)</li><li>网络层(Network Layer)</li><li>链路层(Link Layer)</li><li>物理层(Physical Layer)</li></ul><h3 id="1-3-互联网特征"><a href="#1-3-互联网特征" class="headerlink" title="1.3 互联网特征"></a>1.3 互联网特征</h3><p><strong>1. 基本特征</strong></p><ul><li>数据包独立路由</li><li>无传输时间保证</li><li>无顺序保证</li><li>无可靠性保证</li><li>数据完整性无保证</li><li>数据包可能分片</li><li>数据包可能重复</li></ul><p><strong>2. 各层功能</strong></p><ul><li>传输层:提供端到端的可靠数据传输</li><li>网络层:提供”尽力而为”的数据报传递</li><li>链路层:在点对点链路间传输数据</li></ul><h3 id="1-4-重要问题与挑战"><a href="#1-4-重要问题与挑战" class="headerlink" title="1.4 重要问题与挑战"></a>1.4 重要问题与挑战</h3><p><strong>1. 网络设计问题</strong></p><ul><li>路由器数量与位置优化</li><li>处理能力分配</li><li>传输时间保证</li><li>安全性保证</li></ul><p><strong>2. 技术发展趋势</strong></p><ul><li>自主AI系统</li><li>开发者生产力</li><li>全面用户体验</li><li>以人为本的安全和隐私</li></ul><hr><h2 id="第二章：应用层"><a href="#第二章：应用层" class="headerlink" title="第二章：应用层"></a><strong>第二章：应用层</strong></h2><h3 id="章节结构与主要内容"><a href="#章节结构与主要内容" class="headerlink" title="章节结构与主要内容"></a><strong>章节结构与主要内容</strong></h3><ul><li>2.1 网络应用的基本原理</li><li>2.2 Web 和 HTTP 协议</li><li>2.3 电子邮件协议（SMTP、POP3、IMAP）</li><li>2.4 域名系统（DNS）</li><li>2.5 对等（P2P）网络应用</li><li>2.6 视频流与内容分发网络（CDN）</li><li>2.7 使用 UDP 和 TCP 的套接字编程</li></ul><hr><h3 id="2-1-网络应用的基本原理"><a href="#2-1-网络应用的基本原理" class="headerlink" title="2.1 网络应用的基本原理"></a><strong>2.1 网络应用的基本原理</strong></h3><p><strong>目标</strong>：了解网络应用的概念及实现方式，重点关注应用层协议设计。</p><h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a><strong>基础概念</strong></h4><ol><li><p><strong>网络应用</strong>：</p><ul><li><strong>定义</strong>：运行在网络端系统上的程序，利用网络进行通信。</li><li><strong>示例</strong>：电子邮件、Web 浏览、视频流、即时通讯。</li></ul></li><li><p><strong>应用架构</strong>：</p><ul><li><strong>客户端-服务器架构</strong>：<ul><li><strong>服务器</strong>：始终在线，具有固定 IP 地址（如 Web 服务器）。</li><li><strong>客户端</strong>：与服务器通信，可能动态连接网络。</li></ul></li><li><strong>对等（P2P）架构</strong>：<ul><li>没有固定服务器，所有节点既是客户端又是服务器。</li><li>适用于文件共享（如 BitTorrent）、VoIP（如 Skype）。</li></ul></li></ul></li><li><p><strong>通信方式</strong>：</p><ul><li><strong>进程间通信</strong>：主机内部通过操作系统进行的通信。</li><li><strong>套接字</strong>：进程与网络之间的接口，类似于应用程序的“门”。</li></ul></li></ol><hr><h3 id="2-2-Web-和-HTTP-协议"><a href="#2-2-Web-和-HTTP-协议" class="headerlink" title="2.2 Web 和 HTTP 协议"></a><strong>2.2 Web 和 HTTP 协议</strong></h3><h4 id="HTTP-基础"><a href="#HTTP-基础" class="headerlink" title="HTTP 基础"></a><strong>HTTP 基础</strong></h4><ul><li><strong>定义</strong>：超文本传输协议（HTTP）是 Web 的应用层协议，基于请求-响应模式。</li><li><strong>通信模型</strong>：<ol><li><strong>客户端</strong>：发送 HTTP 请求（浏览器）。</li><li><strong>服务器</strong>：接收请求并返回 HTTP 响应（Web 服务器）。</li></ol></li></ul><h4 id="HTTP-特性"><a href="#HTTP-特性" class="headerlink" title="HTTP 特性"></a><strong>HTTP 特性</strong></h4><ul><li><strong>无状态</strong>：服务器不存储客户端的状态信息。</li><li><strong>传输方式</strong>：<ul><li><strong>非持久连接</strong>：每次请求一个对象，关闭连接。</li><li><strong>持久连接</strong>：支持多个对象通过单一连接传输，提高效率。</li></ul></li></ul><h4 id="HTTP-消息格式"><a href="#HTTP-消息格式" class="headerlink" title="HTTP 消息格式"></a><strong>HTTP 消息格式</strong></h4><ol><li><p><strong>请求消息</strong>：</p><ul><li><p>包含请求行、头部字段和可选的消息体。</p></li><li><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>响应消息</strong>：</p><ul><li><p>包含状态行、头部字段和可选的数据部分。</p></li><li><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 100</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a><strong>状态码</strong></h4><ul><li><strong>2xx</strong>：成功（如 200 OK）</li><li><strong>3xx</strong>：重定向（如 301 Moved Permanently）</li><li><strong>4xx</strong>：客户端错误（如 404 Not Found）</li><li><strong>5xx</strong>：服务器错误（如 500 Internal Server Error）</li></ul><h4 id="Web-缓存与代理"><a href="#Web-缓存与代理" class="headerlink" title="Web 缓存与代理"></a><strong>Web 缓存与代理</strong></h4><ul><li><strong>缓存</strong>：减少对原始服务器的需求，提升响应速度。</li><li><strong>条件请求</strong>：通过 <code>If-Modified-Since</code> 头部字段检查缓存是否过期。</li></ul><hr><h3 id="2-3-电子邮件协议"><a href="#2-3-电子邮件协议" class="headerlink" title="2.3 电子邮件协议"></a><strong>2.3 电子邮件协议</strong></h3><h4 id="主要组件"><a href="#主要组件" class="headerlink" title="主要组件"></a><strong>主要组件</strong></h4><ol><li><strong>用户代理（UA）</strong>：邮件客户端（如 Outlook）用于收发邮件。</li><li><strong>邮件服务器</strong>：存储和转发电子邮件。</li><li><strong>协议</strong>：SMTP 用于邮件发送，POP3&#x2F;IMAP 用于邮件接收。</li></ol><h4 id="SMTP（简单邮件传输协议）"><a href="#SMTP（简单邮件传输协议）" class="headerlink" title="SMTP（简单邮件传输协议）"></a><strong>SMTP（简单邮件传输协议）</strong></h4><ul><li><strong>特性</strong>：<ul><li>基于 TCP 的可靠传输，使用端口 25。</li><li><strong>“推送”模式</strong>：邮件从发送端主动推送到接收端。</li></ul></li><li><strong>交互流程</strong>：<ol><li>客户端连接服务器。</li><li>进行握手（HELO）。</li><li>发送邮件（MAIL FROM、RCPT TO、DATA）。</li><li>结束会话（QUIT）。</li></ol></li></ul><h4 id="POP3-与-IMAP"><a href="#POP3-与-IMAP" class="headerlink" title="POP3 与 IMAP"></a><strong>POP3 与 IMAP</strong></h4><ol><li><strong>POP3</strong>：<ul><li>下载并删除模式（默认）或下载并保留模式。</li><li>会话无状态。</li></ul></li><li><strong>IMAP</strong>：<ul><li>保持邮件存储在服务器端。</li><li>支持多客户端同步，允许邮件分类和搜索。</li></ul></li></ol><hr><h3 id="2-4-域名系统（DNS）"><a href="#2-4-域名系统（DNS）" class="headerlink" title="2.4 域名系统（DNS）"></a><strong>2.4 域名系统（DNS）</strong></h3><h4 id="DNS-的作用"><a href="#DNS-的作用" class="headerlink" title="DNS 的作用"></a><strong>DNS 的作用</strong></h4><ul><li><strong>定义</strong>：将域名解析为 IP 地址的分布式数据库。</li><li><strong>功能</strong>：<ul><li>主机名到 IP 地址的转换。</li><li>别名解析（如 <a href="http://www.google.com/">www.google.com</a> → 真实服务器名）。</li><li>邮件服务器别名（MX 记录）。</li></ul></li></ul><h4 id="DNS-结构"><a href="#DNS-结构" class="headerlink" title="DNS 结构"></a><strong>DNS 结构</strong></h4><ol><li><strong>层次化数据库</strong>：<ul><li><strong>根域名服务器</strong>：最高层，用于指向顶级域名服务器。</li><li><strong>顶级域名服务器（TLD）</strong>：管理 <code>.com</code>、<code>.org</code> 等。</li><li><strong>权威域名服务器</strong>：提供特定主机的 IP 地址。</li></ul></li><li><strong>本地 DNS 服务器</strong>：<ul><li>ISP 提供，缓存常用的域名解析结果。</li></ul></li></ol><h4 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a><strong>查询过程</strong></h4><ul><li><strong>递归查询</strong>：DNS 服务器代替客户端完成所有解析工作。</li><li><strong>迭代查询</strong>：DNS 服务器仅提供下一步指引。</li></ul><h4 id="关键记录类型"><a href="#关键记录类型" class="headerlink" title="关键记录类型"></a><strong>关键记录类型</strong></h4><ul><li><strong>A 记录</strong>：主机名到 IPv4 地址的映射。</li><li><strong>NS 记录</strong>：指向权威 DNS 服务器。</li><li><strong>CNAME 记录</strong>：主机别名。</li><li><strong>MX 记录</strong>：邮件服务器。</li></ul><hr><h3 id="2-5-对等（P2P）网络应用"><a href="#2-5-对等（P2P）网络应用" class="headerlink" title="2.5 对等（P2P）网络应用"></a><strong>2.5 对等（P2P）网络应用</strong></h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h4><ul><li>无需集中式服务器，任意两个节点可以直接通信。</li><li><strong>优点</strong>：<ul><li>自扩展性：每个新节点既贡献资源也消耗资源。</li><li>没有单点故障。</li></ul></li><li><strong>缺点</strong>：<ul><li>难以管理，IP 地址动态变化。</li></ul></li></ul><h4 id="文件分发：BitTorrent"><a href="#文件分发：BitTorrent" class="headerlink" title="文件分发：BitTorrent"></a><strong>文件分发：BitTorrent</strong></h4><ul><li><strong>工作原理</strong>：<ul><li>文件被分割成小块（chunks）。</li><li>节点彼此下载所需块，同时上传已有块。</li></ul></li><li><strong>优化策略：Tit-for-Tat（以牙还牙）</strong>：<ul><li>优先与上传速度最快的节点交换数据。</li></ul></li></ul><hr><h3 id="2-6-视频流与内容分发网络（CDN）"><a href="#2-6-视频流与内容分发网络（CDN）" class="headerlink" title="2.6 视频流与内容分发网络（CDN）"></a><strong>2.6 视频流与内容分发网络（CDN）</strong></h3><h4 id="流媒体传输"><a href="#流媒体传输" class="headerlink" title="流媒体传输"></a><strong>流媒体传输</strong></h4><ul><li><strong>动态自适应流（DASH）</strong>：<ul><li>视频被分割为多种编码速率的块。</li><li>客户端根据带宽动态选择合适的块。</li></ul></li></ul><h4 id="内容分发网络（CDN）"><a href="#内容分发网络（CDN）" class="headerlink" title="内容分发网络（CDN）"></a><strong>内容分发网络（CDN）</strong></h4><ul><li><strong>定义</strong>：通过分布式服务器网络存储和传输内容，提高传输效率。</li><li><strong>部署方式</strong>：<ul><li><strong>深度部署</strong>：将服务器部署到接近用户的网络边缘（如 Akamai）。</li><li><strong>回家部署</strong>：在多个中心位置设置大型服务器集群（如 Limelight）。</li></ul></li></ul><hr><h3 id="2-7-使用-UDP-和-TCP-的套接字编程"><a href="#2-7-使用-UDP-和-TCP-的套接字编程" class="headerlink" title="2.7 使用 UDP 和 TCP 的套接字编程"></a><strong>2.7 使用 UDP 和 TCP 的套接字编程</strong></h3><h4 id="套接字基础"><a href="#套接字基础" class="headerlink" title="套接字基础"></a><strong>套接字基础</strong></h4><ul><li><strong>定义</strong>：应用程序与传输层之间的接口。</li><li><strong>分类</strong>：<ul><li><strong>UDP 套接字</strong>：无连接，适合快速传输但可能丢包。</li><li><strong>TCP 套接字</strong>：面向连接，确保可靠、顺序传输。</li></ul></li></ul><h4 id="编程示例"><a href="#编程示例" class="headerlink" title="编程示例"></a><strong>编程示例</strong></h4><ol><li><strong>UDP 示例</strong>：<ul><li>客户端发送数据包，服务器接收并返回。</li><li>无需建立连接，代码简单，但不保证数据可靠性。</li></ul></li><li><strong>TCP 示例</strong>：<ul><li>客户端与服务器通过三次握手建立连接。</li><li>适合需要可靠传输的应用，如文件传输。</li></ul></li></ol><hr><h3 id="总结与复习重点"><a href="#总结与复习重点" class="headerlink" title="总结与复习重点"></a><strong>总结与复习重点</strong></h3><ol><li><strong>核心协议</strong>：HTTP、SMTP、DNS、TCP&#x2F;UDP。</li><li><strong>应用架构</strong>：<ul><li>客户端-服务器模型适合集中式应用。</li><li>P2P 模型适合分布式文件共享。</li></ul></li><li><strong>关键机制</strong>：<ul><li>DNS 的分层与缓存机制。</li><li>HTTP 的无状态性与缓存优化。</li><li>DASH 自适应视频流传输。</li></ul></li><li><strong>实践应用</strong>：<ul><li>DNS 故障排查。</li><li>使用套接字实现简单的网络应用。</li></ul></li></ol><hr><h3 id="推荐学习资源"><a href="#推荐学习资源" class="headerlink" title="推荐学习资源"></a><strong>推荐学习资源</strong></h3><ol><li><strong>书籍</strong>：<ul><li>《计算机网络——自顶向下方法》by Kurose &amp; Ross</li></ul></li><li><strong>在线教程</strong>：<ul><li><a href="https://www.codecademy.com/">Codecademy 网络基础课程</a></li><li>Coursera 上的网络专修课程。</li></ul></li><li><strong>工具</strong>：<ul><li>Wireshark：协议分析工具，用于捕获和分析网络流量。</li></ul></li></ol><hr><h2 id="第三章：传输层"><a href="#第三章：传输层" class="headerlink" title="第三章：传输层"></a><strong>第三章：传输层</strong></h2><h3 id="章节结构"><a href="#章节结构" class="headerlink" title="章节结构"></a><strong>章节结构</strong></h3><ol><li><strong>传输层服务</strong></li><li><strong>多路复用与解复用</strong></li><li><strong>无连接传输：UDP</strong></li><li><strong>可靠数据传输的基本原理</strong></li><li><strong>面向连接传输：TCP</strong><ul><li>段结构</li><li>可靠数据传输</li><li>流量控制</li><li>连接管理</li></ul></li><li><strong>拥塞控制的基本原理</strong></li><li><strong>TCP 拥塞控制</strong></li></ol><hr><h3 id="3-1-传输层服务"><a href="#3-1-传输层服务" class="headerlink" title="3.1 传输层服务"></a><strong>3.1 传输层服务</strong></h3><h4 id="传输层的作用"><a href="#传输层的作用" class="headerlink" title="传输层的作用"></a><strong>传输层的作用</strong></h4><ul><li>提供主机间<strong>进程到进程的逻辑通信</strong>。</li><li>传输层协议运行在<strong>端系统</strong>：<ul><li><strong>发送端</strong>：将应用层消息划分为段，交给网络层。</li><li><strong>接收端</strong>：将接收的段重组为消息，并交给应用层。</li></ul></li></ul><h4 id="主要传输层协议"><a href="#主要传输层协议" class="headerlink" title="主要传输层协议"></a><strong>主要传输层协议</strong></h4><ol><li><strong>TCP（传输控制协议）</strong><ul><li>面向连接，可靠传输。</li><li>提供流量控制和拥塞控制。</li></ul></li><li><strong>UDP（用户数据报协议）</strong><ul><li>无连接，尽力而为，不保证可靠性。</li></ul></li></ol><p><strong>传输层与网络层的区别</strong>：</p><ul><li>网络层提供主机到主机的通信。</li><li>传输层提供进程到进程的通信（更细粒度）。</li></ul><hr><h3 id="3-2-多路复用与解复用"><a href="#3-2-多路复用与解复用" class="headerlink" title="3.2 多路复用与解复用"></a><strong>3.2 多路复用与解复用</strong></h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h4><ul><li><strong>多路复用</strong>：发送端将来自多个应用的数据封装到传输层段中，分发到网络层。</li><li><strong>解复用</strong>：接收端根据段头信息（端口号）将数据交付给正确的应用进程。</li></ul><h4 id="如何工作"><a href="#如何工作" class="headerlink" title="如何工作"></a><strong>如何工作</strong></h4><ul><li>IP 数据报包含：<ol><li>源 IP 地址、目标 IP 地址。</li><li>源端口号、目标端口号（用于选择正确的套接字）。</li></ol></li><li><strong>UDP 多路复用与解复用</strong>：<ul><li>仅使用目标端口号。</li><li>相同目标端口号的数据报可能来自不同源地址&#x2F;端口号，但会被交付到同一个套接字。</li></ul></li><li><strong>TCP 多路复用与解复用</strong>：<ul><li>使用 4 元组（源 IP、源端口、目标 IP、目标端口）标识连接。</li><li>每个 TCP 连接都有唯一的套接字。</li></ul></li></ul><hr><h3 id="3-3-无连接传输：UDP"><a href="#3-3-无连接传输：UDP" class="headerlink" title="3.3 无连接传输：UDP"></a><strong>3.3 无连接传输：UDP</strong></h3><h4 id="UDP-的特点"><a href="#UDP-的特点" class="headerlink" title="UDP 的特点"></a><strong>UDP 的特点</strong></h4><ol><li><strong>简单、无连接</strong>：<ul><li>不需要握手过程。</li><li>每个段独立处理。</li></ul></li><li><strong>不可靠传输</strong>：<ul><li>数据可能丢失或乱序。</li><li>不提供流量控制或拥塞控制。</li></ul></li></ol><h4 id="UDP-的优点"><a href="#UDP-的优点" class="headerlink" title="UDP 的优点"></a><strong>UDP 的优点</strong></h4><ul><li>低开销（小报头）。</li><li>适合对时延敏感的应用（如实时多媒体、DNS）。</li></ul><h4 id="UDP-报文段结构"><a href="#UDP-报文段结构" class="headerlink" title="UDP 报文段结构"></a><strong>UDP 报文段结构</strong></h4><ul><li>头部字段：<ul><li>源端口号、目标端口号。</li><li>长度：段的总字节数。</li><li>校验和：用于错误检测。</li></ul></li></ul><hr><h3 id="3-4-可靠数据传输的基本原理"><a href="#3-4-可靠数据传输的基本原理" class="headerlink" title="3.4 可靠数据传输的基本原理"></a><strong>3.4 可靠数据传输的基本原理</strong></h3><h4 id="可靠数据传输协议（RDT）"><a href="#可靠数据传输协议（RDT）" class="headerlink" title="可靠数据传输协议（RDT）"></a><strong>可靠数据传输协议（RDT）</strong></h4><ol><li><strong>RDT 1.0</strong>：假设信道可靠，无数据丢失或损坏。</li><li><strong>RDT 2.0</strong>：支持有错误的信道。<ul><li><strong>错误检测</strong>：通过校验和。</li><li><strong>反馈机制</strong>：使用 ACK（确认）和 NAK（否认）消息。</li><li><strong>缺陷</strong>：如果 ACK&#x2F;NAK 损坏，无法判断是否需要重传。</li></ul></li><li><strong>RDT 2.1 和 2.2</strong>：<ul><li>添加序列号以区分重复分组。</li><li>使用<strong>无 NAK 协议</strong>（重复 ACK 代替 NAK）。</li></ul></li><li><strong>RDT 3.0</strong>：处理丢包的信道。<ul><li>添加超时机制。</li><li><strong>停等协议</strong>：每次发送一个分组，等待确认后再发送下一个。</li></ul></li></ol><hr><h3 id="3-5-面向连接传输：TCP"><a href="#3-5-面向连接传输：TCP" class="headerlink" title="3.5 面向连接传输：TCP"></a><strong>3.5 面向连接传输：TCP</strong></h3><h4 id="TCP-的特点"><a href="#TCP-的特点" class="headerlink" title="TCP 的特点"></a><strong>TCP 的特点</strong></h4><ol><li><strong>面向连接</strong>：<ul><li>需要三次握手建立连接。</li><li>每个连接由 4 元组（源 IP、源端口、目标 IP、目标端口）标识。</li></ul></li><li><strong>可靠性</strong>：<ul><li>使用序列号和确认号。</li><li>重传机制：基于超时或<strong>快速重传</strong>（三次重复 ACK）。</li></ul></li><li><strong>流量控制</strong>：防止发送端超出接收端的处理能力。</li><li><strong>拥塞控制</strong>：防止网络过载。</li></ol><h4 id="TCP-段结构"><a href="#TCP-段结构" class="headerlink" title="TCP 段结构"></a><strong>TCP 段结构</strong></h4><ul><li>关键字段：<ol><li><strong>序列号</strong>：分组中第一个字节的编号。</li><li><strong>确认号</strong>：期望接收的下一个字节序号。</li><li><strong>接收窗口</strong>：接收端可用的缓冲区大小（用于流量控制）。</li><li><strong>标志位</strong>：SYN（同步）、FIN（结束）、ACK（确认）等。</li></ol></li></ul><h4 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a><strong>TCP 流量控制</strong></h4><ul><li>基于滑动窗口机制：<ul><li>发送端根据接收端的<strong>接收窗口（rwnd）</strong>调整发送速率。</li><li>防止接收端缓冲区溢出。</li></ul></li></ul><h4 id="TCP-连接管理"><a href="#TCP-连接管理" class="headerlink" title="TCP 连接管理"></a><strong>TCP 连接管理</strong></h4><ol><li><strong>连接建立</strong>：三次握手。<ul><li>客户端发送 SYN，同步序列号。</li><li>服务器发送 SYN-ACK，确认并同步序列号。</li><li>客户端发送 ACK，连接建立。</li></ul></li><li><strong>连接关闭</strong>：四次挥手。<ul><li>双方分别发送 FIN 和 ACK 关闭连接。</li></ul></li></ol><hr><h3 id="3-6-拥塞控制的基本原理"><a href="#3-6-拥塞控制的基本原理" class="headerlink" title="3.6 拥塞控制的基本原理"></a><strong>3.6 拥塞控制的基本原理</strong></h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a><strong>定义</strong></h4><ul><li><strong>拥塞</strong>：网络中过多的数据导致性能下降。</li><li><strong>拥塞控制</strong>：解决网络资源竞争，避免拥塞发生。</li></ul><h4 id="拥塞的表现"><a href="#拥塞的表现" class="headerlink" title="拥塞的表现"></a><strong>拥塞的表现</strong></h4><ol><li>分组丢失（路由器缓冲区溢出）。</li><li>分组排队延迟增大。</li></ol><h4 id="拥塞的代价"><a href="#拥塞的代价" class="headerlink" title="拥塞的代价"></a><strong>拥塞的代价</strong></h4><ul><li>不必要的重传降低了有效吞吐量。</li><li>上游传输资源浪费。</li></ul><hr><h3 id="3-7-TCP-拥塞控制"><a href="#3-7-TCP-拥塞控制" class="headerlink" title="3.7 TCP 拥塞控制"></a><strong>3.7 TCP 拥塞控制</strong></h3><h4 id="TCP-的拥塞控制机制"><a href="#TCP-的拥塞控制机制" class="headerlink" title="TCP 的拥塞控制机制"></a><strong>TCP 的拥塞控制机制</strong></h4><ol><li><strong>慢启动（Slow Start）</strong>：<ul><li>初始拥塞窗口（cwnd）为 1 MSS。</li><li>每次接收 ACK，将 cwnd 翻倍。</li><li>指数增长，直到达到<strong>慢启动阈值（ssthresh）</strong>。</li></ul></li><li><strong>拥塞避免（Congestion Avoidance）</strong>：<ul><li>cwnd 每 RTT 增加 1 MSS（线性增长）。</li></ul></li><li><strong>快速重传与快速恢复</strong>：<ul><li><strong>快速重传</strong>：接收 3 个重复 ACK 后立即重传丢失分组。</li><li><strong>快速恢复</strong>：将 cwnd 减半，而不是重置为 1 MSS。</li></ul></li></ol><h4 id="TCP-的-AIMD-算法"><a href="#TCP-的-AIMD-算法" class="headerlink" title="TCP 的 AIMD 算法"></a><strong>TCP 的 AIMD 算法</strong></h4><ul><li><strong>加性增加，乘性减少</strong>：<ul><li>每 RTT 增加 cwnd。</li><li>检测到丢包时，将 cwnd 减半。</li></ul></li></ul><h4 id="TCP-吞吐量公式"><a href="#TCP-吞吐量公式" class="headerlink" title="TCP 吞吐量公式"></a><strong>TCP 吞吐量公式</strong></h4><ul><li>平均吞吐量 ≈ <code>(3/4) * W / RTT</code>。<ul><li>W：丢包时的窗口大小。</li><li>RTT：往返时延。</li></ul></li></ul><hr><h3 id="3-8-高速网络与新型传输协议"><a href="#3-8-高速网络与新型传输协议" class="headerlink" title="3.8 高速网络与新型传输协议"></a><strong>3.8 高速网络与新型传输协议</strong></h3><h4 id="TCP-在高速网络中的挑战"><a href="#TCP-在高速网络中的挑战" class="headerlink" title="TCP 在高速网络中的挑战"></a><strong>TCP 在高速网络中的挑战</strong></h4><ul><li>大带宽、长时延的链路需要更大的窗口大小。</li><li><strong>TCP CUBIC</strong>：Linux 默认 TCP 拥塞控制算法。<ul><li>通过更快地接近最大窗口（Wmax）提高吞吐量。</li></ul></li></ul><h4 id="QUIC-协议"><a href="#QUIC-协议" class="headerlink" title="QUIC 协议"></a><strong>QUIC 协议</strong></h4><ul><li>基于 UDP 的新型传输协议，改进了 TCP 的性能：<ul><li>更快的连接建立（一次握手）。</li><li>内置的可靠性、拥塞控制和加密。</li></ul></li></ul><hr><h3 id="总结与复习重点-1"><a href="#总结与复习重点-1" class="headerlink" title="总结与复习重点"></a><strong>总结与复习重点</strong></h3><ol><li><strong>传输层功能</strong>：从主机到主机的通信扩展到进程到进程。</li><li><strong>协议对比</strong>：<ul><li><strong>UDP</strong>：简单、无连接、不可靠。</li><li><strong>TCP</strong>：复杂、面向连接、可靠。</li></ul></li><li><strong>关键机制</strong>：<ul><li>多路复用与解复用。</li><li>TCP 的流量控制与拥塞控制。</li><li>可靠数据传输的实现原理。</li></ul></li><li><strong>应用场景</strong>：<ul><li>UDP 适用于实时应用（如视频流）。</li><li>TCP 适用于可靠性要求高的应用（如文件传输）。</li></ul></li></ol><hr><h3 id="推荐学习资源-1"><a href="#推荐学习资源-1" class="headerlink" title="推荐学习资源"></a><strong>推荐学习资源</strong></h3><ol><li><strong>书籍</strong>：<ul><li>《计算机网络：自顶向下方法》（Kurose 和 Ross）。</li></ul></li><li><strong>工具</strong>：<ul><li>Wireshark：网络协议分析工具。</li></ul></li><li><strong>在线教程</strong>：<ul><li>Coursera 网络课程。</li><li><a href="http://gaia.cs.umass.edu/kurose_ross/interactive/">Kurose &amp; Ross 在线交互练习</a>。</li></ul></li></ol><hr><h2 id="第四章：网络层——数据平面"><a href="#第四章：网络层——数据平面" class="headerlink" title="第四章：网络层——数据平面"></a><strong>第四章：网络层——数据平面</strong></h2><h3 id="章节结构-1"><a href="#章节结构-1" class="headerlink" title="章节结构"></a><strong>章节结构</strong></h3><ol><li><strong>网络层概述</strong></li><li><strong>路由器的内部结构</strong></li><li><strong>IP 协议</strong><ul><li>数据报格式</li><li>分片与重组</li><li>IPv4 地址</li><li>网络地址转换（NAT）</li><li>IPv6</li></ul></li><li><strong>泛化转发与软件定义网络（SDN）</strong><ul><li>匹配</li><li>动作</li><li>OpenFlow 示例</li></ul></li></ol><hr><h3 id="4-1-网络层概述"><a href="#4-1-网络层概述" class="headerlink" title="4.1 网络层概述"></a><strong>4.1 网络层概述</strong></h3><h4 id="网络层的作用"><a href="#网络层的作用" class="headerlink" title="网络层的作用"></a><strong>网络层的作用</strong></h4><p>网络层的主要功能是提供<strong>主机到主机</strong>的通信服务，负责将传输层消息封装成数据报并传递至目的地。</p><ul><li><strong>发送端</strong>：将传输层消息封装到 IP 数据报中。</li><li><strong>接收端</strong>：从 IP 数据报中提取传输层消息，并传递给传输层。</li><li><strong>路由器</strong>：检查每个通过的 IP 数据报头部信息，并决定如何转发。</li></ul><h4 id="网络层的两大核心功能"><a href="#网络层的两大核心功能" class="headerlink" title="网络层的两大核心功能"></a><strong>网络层的两大核心功能</strong></h4><ol><li><strong>转发</strong>：<ul><li>在路由器内部，将数据包从输入端口移动到适当的输出端口。</li><li>类比：从高速公路的一个出口进入另一个出口。</li></ul></li><li><strong>路由</strong>：<ul><li>决定数据包从源到目的地的路径。</li><li>类比：规划从起点到终点的整体旅行路线。</li></ul></li></ol><h4 id="数据平面与控制平面"><a href="#数据平面与控制平面" class="headerlink" title="数据平面与控制平面"></a><strong>数据平面与控制平面</strong></h4><ul><li><strong>数据平面</strong>：<ul><li><strong>定义</strong>：每个路由器的本地功能，决定如何根据数据报头部信息将其转发到正确的输出端口。</li><li><strong>特点</strong>：局部、快速，通常在硬件中实现。</li></ul></li><li><strong>控制平面</strong>：<ul><li><strong>定义</strong>：全网范围的逻辑，用于决定数据包在网络中的路由路径。</li><li><strong>两种实现方式</strong>：<ol><li><strong>传统路由算法</strong>：所有计算在路由器内完成。</li><li><strong>软件定义网络（SDN）</strong>：集中式控制器在远程服务器上计算路由。</li></ol></li></ul></li></ul><hr><h3 id="4-2-路由器的内部结构"><a href="#4-2-路由器的内部结构" class="headerlink" title="4.2 路由器的内部结构"></a><strong>4.2 路由器的内部结构</strong></h3><h4 id="路由器架构的主要组件"><a href="#路由器架构的主要组件" class="headerlink" title="路由器架构的主要组件"></a><strong>路由器架构的主要组件</strong></h4><ol><li><p><strong>输入端口</strong>：</p><ul><li>功能：<ol><li>终止物理链路（物理层）。</li><li>执行数据链路层协议（如以太网）。</li><li>根据转发表查找数据包的输出端口。</li></ol></li><li><strong>去中心化处理</strong>：输入端口可以独立完成查表操作（“匹配+动作”），以实现高效率。</li><li><strong>排队与阻塞</strong>：当到达速率超过交换速率时，可能出现排队和丢包。</li></ul></li><li><p><strong>交换结构</strong>：</p><ul><li><strong>功能</strong>：将数据包从输入端口传输到正确的输出端口。</li><li>实现方式：<ol><li><strong>内存交换</strong>：数据包通过共享内存进行传输（速度受限于内存带宽）。</li><li><strong>总线交换</strong>：通过共享总线传输数据包（速度受限于总线带宽）。</li><li><strong>交叉交换</strong>：使用交叉开关网络，支持多个输入输出同时通信（高性能）。</li></ol></li></ul></li><li><p><strong>输出端口</strong>：</p><ul><li>功能：<ol><li>存储从交换结构传来的数据包。</li><li>执行排队调度并发送数据包。</li></ol></li><li><strong>排队与丢包</strong>：当数据包到达速率超过输出链路速率时可能出现缓冲区溢出。</li></ul></li><li><p><strong>路由处理器</strong>：</p><ul><li>功能：执行路由协议、维护转发表、管理网络层控制功能。</li><li><strong>实现</strong>：通常通过软件运行在路由器 CPU 上。</li></ul></li></ol><h4 id="示例：最长前缀匹配"><a href="#示例：最长前缀匹配" class="headerlink" title="示例：最长前缀匹配"></a><strong>示例：最长前缀匹配</strong></h4><ul><li><p>路由器使用最长前缀匹配查找转发表中的路由。</p></li><li><p><strong>例子</strong>：</p><ul><li><p>数据包目的地址：<code>11001000 00010111 00011000 10101010</code>。</p></li><li><p>转发表：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前缀              接口</span><br><span class="line">11001000 00010111 00010*** *********   0</span><br><span class="line">11001000 00010111 00011000 *********   1</span><br><span class="line">11001000 00010111 00011*** *********   2</span><br></pre></td></tr></table></figure><p>匹配规则：选择匹配位数最多的条目，因此选择接口 <code>1</code>。</p></li></ul></li></ul><hr><h3 id="4-3-IP-协议"><a href="#4-3-IP-协议" class="headerlink" title="4.3 IP 协议"></a><strong>4.3 IP 协议</strong></h3><h4 id="IP-数据报格式"><a href="#IP-数据报格式" class="headerlink" title="IP 数据报格式"></a><strong>IP 数据报格式</strong></h4><ul><li><strong>关键字段</strong>：<ol><li><strong>版本号</strong>：IPv4 或 IPv6。</li><li><strong>首部长度</strong>：IP 首部的长度（通常为 20 字节）。</li><li><strong>源 IP 地址和目标 IP 地址</strong>。</li><li><strong>生存时间（TTL）</strong>：防止数据包无限循环。</li><li><strong>数据总长度</strong>：数据报的总字节数（包括首部和数据）。</li></ol></li></ul><hr><h4 id="IP-分片与重组"><a href="#IP-分片与重组" class="headerlink" title="IP 分片与重组"></a><strong>IP 分片与重组</strong></h4><ul><li><strong>原因</strong>：不同链路的最大传输单元（MTU）可能不同。</li><li><strong>过程</strong>：<ul><li>大数据报在路由器中被分片。</li><li>分片的数据报在目的地重组。</li></ul></li><li><strong>示例</strong>：<ul><li>初始数据报大小：4000 字节。</li><li>MTU：1500 字节。</li><li>结果：<ol><li>分片 1：1480 字节数据 + 20 字节头部。</li><li>分片 2：1480 字节数据 + 20 字节头部。</li><li>分片 3：1040 字节数据 + 20 字节头部。</li></ol></li></ul></li></ul><hr><h4 id="IPv4-地址与子网"><a href="#IPv4-地址与子网" class="headerlink" title="IPv4 地址与子网"></a><strong>IPv4 地址与子网</strong></h4><ul><li><strong>IP 地址</strong>：<ul><li>32 位标识符，包括网络部分和主机部分。</li><li><strong>CIDR（无类别域间路由）</strong>：使用前缀表示法（如 <code>200.23.16.0/23</code>）。</li></ul></li><li><strong>子网</strong>：<ul><li>定义：相同网络部分的设备集合，子网内设备无需路由即可通信。</li><li><strong>子网掩码</strong>：用于提取网络部分（如 <code>/24</code> 表示前 24 位为网络部分）。</li></ul></li></ul><hr><h4 id="动态主机配置协议（DHCP）"><a href="#动态主机配置协议（DHCP）" class="headerlink" title="动态主机配置协议（DHCP）"></a><strong>动态主机配置协议（DHCP）</strong></h4><ul><li><strong>功能</strong>：动态分配 IP 地址。</li><li><strong>工作流程</strong>：<ol><li>主机发送 DHCP Discover 广播消息。</li><li>DHCP 服务器回复 DHCP Offer。</li><li>主机发送 DHCP Request 确认请求。</li><li>DHCP 服务器发送 DHCP ACK 确认分配。</li></ol></li></ul><hr><h4 id="网络地址转换（NAT）"><a href="#网络地址转换（NAT）" class="headerlink" title="网络地址转换（NAT）"></a><strong>网络地址转换（NAT）</strong></h4><ul><li><p><strong>功能</strong>：将私有 IP 地址映射为全局唯一的公共 IP 地址。</p></li><li><p><strong>优点</strong>：</p><ol><li>节省 IP 地址。</li><li>提高网络安全性（隐藏内部网络结构）。</li></ol></li><li><p><strong>示例</strong>：</p><ul><li><p>内部地址：<code>10.0.0.1</code>。</p></li><li><p>NAT 地址：<code>138.76.29.7</code>。</p></li><li><p>NAT 表：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">内部地址:端口 外部地址:端口</span><br><span class="line">10.0.0.1:3345    138.76.29.7:5001</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h4 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a><strong>IPv6</strong></h4><ul><li><strong>动机</strong>：IPv4 地址耗尽。</li><li><strong>特点</strong>：<ol><li>扩展地址空间（128 位地址）。</li><li>固定长度的 40 字节头部。</li><li>移除校验和字段以简化处理。</li></ol></li><li><strong>过渡机制</strong>：隧道技术（将 IPv6 数据报封装为 IPv4 数据报的有效载荷）。</li></ul><hr><h3 id="4-4-泛化转发与软件定义网络（SDN）"><a href="#4-4-泛化转发与软件定义网络（SDN）" class="headerlink" title="4.4 泛化转发与软件定义网络（SDN）"></a><strong>4.4 泛化转发与软件定义网络（SDN）</strong></h3><h4 id="泛化转发"><a href="#泛化转发" class="headerlink" title="泛化转发"></a><strong>泛化转发</strong></h4><ul><li><strong>定义</strong>：根据任意头部字段而非仅目的地址进行转发。</li><li><strong>实现</strong>：采用流表（flow table），由控制器计算并分发。</li><li><strong>流表字段</strong>：<ul><li>匹配（Match）：头部字段值。</li><li>动作（Action）：对匹配数据包执行的操作（如转发、丢弃、修改）。</li><li>计数器（Counters）：记录匹配流量的字节数与包数。</li></ul></li></ul><h4 id="OpenFlow-示例"><a href="#OpenFlow-示例" class="headerlink" title="OpenFlow 示例"></a><strong>OpenFlow 示例</strong></h4><ul><li><p><strong>场景</strong>：主机 <code>h5</code> 和 <code>h6</code> 的数据包需通过交换机 <code>s1</code> 和 <code>s2</code> 转发到主机 <code>h3</code> 或 <code>h4</code>。</p></li><li><p><strong>流表规则</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">匹配条件             动作</span><br><span class="line">src=10.3.*.*, dest=10.2.*.*  转发到端口 3</span><br><span class="line">ingress port=2, dest=10.2.0.3 转发到端口 4</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="总结与复习重点-2"><a href="#总结与复习重点-2" class="headerlink" title="总结与复习重点"></a><strong>总结与复习重点</strong></h3><ol><li><strong>核心功能</strong>：<ul><li>转发（数据平面）与路由（控制平面）。</li></ul></li><li><strong>关键协议</strong>：<ul><li>IPv4、IPv6、NAT、DHCP。</li></ul></li><li><strong>路由器内部</strong>：<ul><li>输入端口、交换结构、输出端口和路由处理器。</li></ul></li><li><strong>新技术</strong>：<ul><li>泛化转发与 SDN，简化网络管理。</li></ul></li></ol><hr><h3 id="推荐学习资源-2"><a href="#推荐学习资源-2" class="headerlink" title="推荐学习资源"></a><strong>推荐学习资源</strong></h3><ol><li><strong>书籍</strong>：《计算机网络：自顶向下方法》。</li><li><strong>工具</strong>：Wireshark 数据包捕获与分析。</li><li><strong>在线资源</strong>：<a href="http://gaia.cs.umass.edu/kurose_ross/interactive/">Kurose &amp; Ross 在线练习</a>。</li></ol><hr><h2 id="第五章：网络层——控制平面"><a href="#第五章：网络层——控制平面" class="headerlink" title="第五章：网络层——控制平面"></a><strong>第五章：网络层——控制平面</strong></h2><h3 id="章节结构-2"><a href="#章节结构-2" class="headerlink" title="章节结构"></a><strong>章节结构</strong></h3><ol><li><strong>引言</strong></li><li><strong>路由协议</strong><ul><li>链路状态算法（Link State）</li><li>距离向量算法（Distance Vector）</li></ul></li><li><strong>互联网内部自治系统路由（OSPF）</strong></li><li><strong>自治系统之间的路由（BGP）</strong></li><li><strong>软件定义网络（SDN）控制平面</strong></li><li><strong>互联网控制报文协议（ICMP）</strong></li><li><strong>网络管理与 SNMP</strong></li></ol><hr><h3 id="5-1-引言"><a href="#5-1-引言" class="headerlink" title="5.1 引言"></a><strong>5.1 引言</strong></h3><h4 id="网络层的两大功能"><a href="#网络层的两大功能" class="headerlink" title="网络层的两大功能"></a><strong>网络层的两大功能</strong></h4><ol><li><strong>转发（Forwarding）</strong>：<ul><li>数据平面功能：将数据包从输入端口移动到适当的输出端口。</li></ul></li><li><strong>路由（Routing）</strong>：<ul><li>控制平面功能：计算从源到目的地的路径。</li></ul></li></ol><h4 id="两种控制平面实现方式"><a href="#两种控制平面实现方式" class="headerlink" title="两种控制平面实现方式"></a><strong>两种控制平面实现方式</strong></h4><ol><li><strong>传统的分布式控制</strong>：<ul><li>每个路由器运行独立的路由算法，计算自己的转发表。</li></ul></li><li><strong>逻辑集中式控制（SDN）</strong>：<ul><li>采用集中式控制器，由控制器计算并分发转发表。</li></ul></li></ol><hr><h3 id="5-2-路由协议"><a href="#5-2-路由协议" class="headerlink" title="5.2 路由协议"></a><strong>5.2 路由协议</strong></h3><p>路由协议的目标是确定从源主机到目的主机的“最佳路径”（如最低成本或最短时间）。</p><h4 id="网络抽象：图模型"><a href="#网络抽象：图模型" class="headerlink" title="网络抽象：图模型"></a><strong>网络抽象：图模型</strong></h4><ul><li><strong>节点</strong>：路由器。</li><li><strong>边</strong>：路由器之间的链路，带有成本（如带宽、时延或拥塞水平）。</li><li><strong>路径成本</strong>：路径上所有链路成本的总和。</li></ul><h4 id="路由算法分类"><a href="#路由算法分类" class="headerlink" title="路由算法分类"></a><strong>路由算法分类</strong></h4><ol><li><strong>全局路由算法（链路状态算法）</strong>：<ul><li>所有路由器都有网络拓扑的完整信息。</li><li>通过链路状态广播实现。</li></ul></li><li><strong>分布式路由算法（距离向量算法）</strong>：<ul><li>每个路由器只知道与其直接相连的邻居信息。</li><li>通过与邻居交换信息迭代计算。</li></ul></li></ol><hr><h4 id="链路状态算法（Link-State）"><a href="#链路状态算法（Link-State）" class="headerlink" title="链路状态算法（Link State）"></a><strong>链路状态算法（Link State）</strong></h4><p>使用 <strong>Dijkstra 算法</strong> 计算单源最短路径。</p><h5 id="Dijkstra-算法步骤"><a href="#Dijkstra-算法步骤" class="headerlink" title="Dijkstra 算法步骤"></a><strong>Dijkstra 算法步骤</strong></h5><ol><li>初始化：<ul><li>将源节点加入集合 <code>N&#39;</code>，初始路径成本为 0。</li><li>对于其他节点，设置初始路径成本为 ∞。</li></ul></li><li>迭代：<ul><li>从未加入 <code>N&#39;</code> 的节点中选择路径成本最小的节点，并将其加入 <code>N&#39;</code>。</li><li>更新其他节点的路径成本。</li></ul></li><li>重复，直到所有节点都被加入 <code>N&#39;</code>。</li></ol><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h5><p>给定以下网络拓扑：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u---1---x---2---y---3---z</span><br></pre></td></tr></table></figure><ol><li>初始状态：<code>N&#39; = &#123;u&#125;</code>，路径成本为 <code>D(u) = 0</code>，其他节点为 ∞。</li><li>第一步加入 <code>x</code>：<code>D(x) = 1</code>。</li><li>第二步加入 <code>y</code>：<code>D(y) = 3</code>。</li><li>第三步加入 <code>z</code>：<code>D(z) = 6</code>。</li></ol><h5 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a><strong>算法复杂度</strong></h5><ul><li>时间复杂度：O(n²)（n 是节点数）。</li><li>使用更高效的数据结构（如优先队列）可优化为 O(n log n)。</li></ul><hr><h4 id="距离向量算法（Distance-Vector）"><a href="#距离向量算法（Distance-Vector）" class="headerlink" title="距离向量算法（Distance Vector）"></a><strong>距离向量算法（Distance Vector）</strong></h4><p>基于 <strong>Bellman-Ford 方程</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dx(y) = min &#123;c(x, v) + Dv(y)&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>Dx(y)</code> 是从节点 x 到节点 y 的最短路径成本。</li><li><code>c(x, v)</code> 是节点 x 到邻居 v 的链路成本。</li><li><code>Dv(y)</code> 是邻居 v 到 y 的最短路径成本。</li></ul><h5 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a><strong>工作机制</strong></h5><ol><li>每个节点维护一个距离向量，表示到每个目的地的路径成本。</li><li>节点周期性向邻居发送自己的距离向量。</li><li>接收到邻居的距离向量后，更新自己的距离向量。</li></ol><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h5><ol><li><p>节点 x 的初始距离向量：<code>Dx = [0, 2, 7]</code>。</p></li><li><p>从邻居 y 接收到 <code>Dy = [2, 0, 1]</code> 后，更新：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dx(z) = min&#123;c(x, y) + Dy(z), Dx(z)&#125; = min&#123;2 + 1, 7&#125; = 3</span><br></pre></td></tr></table></figure></li></ol><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a><strong>问题</strong></h5><ul><li><strong>计数到无穷问题</strong>：路径成本可能无限增加（如链路失效时）。</li><li><strong>解决方法</strong>：毒性逆转（Poisoned Reverse），即路由器通过某节点到目标的路径成本报告为 ∞。</li></ul><hr><h3 id="5-3-互联网内部自治系统路由：OSPF"><a href="#5-3-互联网内部自治系统路由：OSPF" class="headerlink" title="5.3 互联网内部自治系统路由：OSPF"></a><strong>5.3 互联网内部自治系统路由：OSPF</strong></h3><h4 id="OSPF（开放最短路径优先）特点"><a href="#OSPF（开放最短路径优先）特点" class="headerlink" title="OSPF（开放最短路径优先）特点"></a><strong>OSPF（开放最短路径优先）特点</strong></h4><ol><li><strong>链路状态路由协议</strong>：<ul><li>每个路由器维护整个自治系统（AS）的拓扑图。</li><li>使用 Dijkstra 算法计算最短路径。</li></ul></li><li><strong>分层结构</strong>：<ul><li>将 AS 分为多个区域（Area），每个区域内进行链路状态广播。</li><li>区域边界路由器负责汇总区域信息。</li></ul></li><li><strong>特性</strong>：<ul><li>支持多条等价成本路径。</li><li>强调安全通信（认证机制）。</li></ul></li></ol><hr><h3 id="5-4-自治系统之间的路由：BGP"><a href="#5-4-自治系统之间的路由：BGP" class="headerlink" title="5.4 自治系统之间的路由：BGP"></a><strong>5.4 自治系统之间的路由：BGP</strong></h3><h4 id="BGP（边界网关协议）特点"><a href="#BGP（边界网关协议）特点" class="headerlink" title="BGP（边界网关协议）特点"></a><strong>BGP（边界网关协议）特点</strong></h4><ol><li><strong>作用</strong>：<ul><li>在自治系统（AS）之间传播可达性信息。</li><li>选择“最佳”路径到达外部网络。</li></ul></li><li><strong>两种 BGP 会话</strong>：<ul><li><strong>eBGP</strong>：AS 之间的 BGP 会话。</li><li><strong>iBGP</strong>：AS 内部的 BGP 会话。</li></ul></li><li><strong>路径选择规则</strong>：<ul><li>根据 AS-PATH（路径中经过的 AS 列表）选择最短路径。</li><li>使用策略决定是否接受或传播路径。</li></ul></li></ol><h4 id="BGP-消息类型"><a href="#BGP-消息类型" class="headerlink" title="BGP 消息类型"></a><strong>BGP 消息类型</strong></h4><ol><li><strong>OPEN</strong>：建立会话并进行身份验证。</li><li><strong>UPDATE</strong>：传播新路径或撤销旧路径。</li><li><strong>KEEPALIVE</strong>：保持连接存活。</li><li><strong>NOTIFICATION</strong>：报告错误或关闭连接。</li></ol><hr><h3 id="5-5-软件定义网络（SDN）控制平面"><a href="#5-5-软件定义网络（SDN）控制平面" class="headerlink" title="5.5 软件定义网络（SDN）控制平面"></a><strong>5.5 软件定义网络（SDN）控制平面</strong></h3><h4 id="SDN-的核心思想"><a href="#SDN-的核心思想" class="headerlink" title="SDN 的核心思想"></a><strong>SDN 的核心思想</strong></h4><ul><li>控制平面与数据平面分离：<ul><li>数据平面：负责包的转发。</li><li>控制平面：通过集中式控制器管理整个网络的转发表。</li></ul></li><li><strong>优点</strong>：<ul><li>提高网络管理的灵活性（集中式配置）。</li><li>支持复杂的流量工程（如负载均衡）。</li></ul></li></ul><h4 id="OpenFlow-协议"><a href="#OpenFlow-协议" class="headerlink" title="OpenFlow 协议"></a><strong>OpenFlow 协议</strong></h4><ul><li>定义控制器与交换机之间的通信。</li><li><strong>消息类型</strong>：<ol><li><strong>控制器到交换机</strong>：<ul><li>修改流表（如添加、删除规则）。</li><li>查询交换机状态。</li></ul></li><li><strong>交换机到控制器</strong>：<ul><li>报告异常事件（如端口状态变化）。</li><li>将未匹配的数据包发送到控制器。</li></ul></li></ol></li></ul><hr><h3 id="5-6-互联网控制报文协议（ICMP）"><a href="#5-6-互联网控制报文协议（ICMP）" class="headerlink" title="5.6 互联网控制报文协议（ICMP）"></a><strong>5.6 互联网控制报文协议（ICMP）</strong></h3><h4 id="ICMP-的功能"><a href="#ICMP-的功能" class="headerlink" title="ICMP 的功能"></a><strong>ICMP 的功能</strong></h4><ol><li><strong>错误报告</strong>：<ul><li>如目标不可达（Type 3）。</li><li>TTL 超时（Type 11）。</li></ul></li><li><strong>诊断工具</strong>：<ul><li><strong>Ping</strong>：测试连通性（Echo 请求与应答）。</li><li><strong>Traceroute</strong>：跟踪数据包路径。</li></ul></li></ol><hr><h3 id="5-7-网络管理与-SNMP"><a href="#5-7-网络管理与-SNMP" class="headerlink" title="5.7 网络管理与 SNMP"></a><strong>5.7 网络管理与 SNMP</strong></h3><h4 id="SNMP（简单网络管理协议）"><a href="#SNMP（简单网络管理协议）" class="headerlink" title="SNMP（简单网络管理协议）"></a><strong>SNMP（简单网络管理协议）</strong></h4><ol><li><strong>组成</strong>：<ul><li><strong>管理实体</strong>：收集和分析网络数据。</li><li><strong>代理（Agent）</strong>：驻留在被管理设备上，维护管理信息库（MIB）。</li></ul></li><li><strong>工作模式</strong>：<ul><li><strong>请求&#x2F;响应模式</strong>：管理实体主动请求数据。</li><li><strong>陷阱模式（Trap）</strong>：代理主动向管理实体报告异常。</li></ul></li></ol><hr><h3 id="总结与复习重点-3"><a href="#总结与复习重点-3" class="headerlink" title="总结与复习重点"></a><strong>总结与复习重点</strong></h3><ol><li><strong>路由协议</strong>：<ul><li>OSPF（链路状态）和 BGP（路径向量）。</li><li>计数到无穷问题及其解决方法。</li></ul></li><li><strong>SDN 核心</strong>：<ul><li>控制平面与数据平面分离。</li><li>OpenFlow 协议实现集中式管理。</li></ul></li><li><strong>网络工具</strong>：<ul><li>ICMP 用于网络诊断。</li><li>SNMP 用于网络管理。</li></ul></li></ol><hr><h3 id="推荐学习资源-3"><a href="#推荐学习资源-3" class="headerlink" title="推荐学习资源"></a><strong>推荐学习资源</strong></h3><ol><li><strong>书籍</strong>：《计算机网络：自顶向下方法》by Kurose 和 Ross。</li><li><strong>工具</strong>：使用 Wireshark 捕获和分析路由协议。</li><li><strong>在线资源</strong>：<a href="http://gaia.cs.umass.edu/kurose_ross/interactive/">Kurose &amp; Ross 在线交互练习</a>。</li></ol><hr><h2 id="第六章：链路层与局域网"><a href="#第六章：链路层与局域网" class="headerlink" title="第六章：链路层与局域网"></a><strong>第六章：链路层与局域网</strong></h2><h3 id="章节结构-3"><a href="#章节结构-3" class="headerlink" title="章节结构"></a><strong>章节结构</strong></h3><ol><li><strong>引言与服务</strong></li><li><strong>错误检测与纠正</strong></li><li><strong>多路访问协议</strong></li><li><strong>局域网（LANs）</strong><ul><li>地址与 ARP</li><li>以太网</li><li>交换机</li><li>虚拟局域网（VLANs）</li></ul></li><li><strong>链路虚拟化：多协议标签交换（MPLS）</strong></li><li><strong>数据中心网络</strong></li><li><strong>Web 请求的生命周期</strong></li></ol><hr><h3 id="6-1-引言与服务"><a href="#6-1-引言与服务" class="headerlink" title="6.1 引言与服务"></a><strong>6.1 引言与服务</strong></h3><h4 id="链路层的作用"><a href="#链路层的作用" class="headerlink" title="链路层的作用"></a><strong>链路层的作用</strong></h4><ul><li>链路层负责在<strong>相邻节点</strong>之间传递数据报（datagram）。</li><li>数据报在链路层被封装成帧（frame）。</li></ul><h4 id="链路层的主要服务"><a href="#链路层的主要服务" class="headerlink" title="链路层的主要服务"></a><strong>链路层的主要服务</strong></h4><ol><li><p><strong>帧封装与链路访问</strong>：</p><ul><li>将网络层数据报封装为帧，添加头部和尾部。</li><li>若为共享介质，提供介质访问控制（MAC）。</li><li><strong>MAC 地址</strong>：用于标识帧的源和目标节点，与 <strong>IP 地址</strong>不同。</li></ul></li><li><p><strong>可靠传输</strong>：</p><ul><li><strong>无线链路</strong>上可能需要链路层的可靠性补充。</li></ul></li><li><p><strong>错误检测与纠正</strong>：</p><ul><li>检测数据传输中可能出现的比特错误。</li><li>错误纠正允许无需重传即可修正比特错误。</li></ul></li><li><p><strong>流量控制</strong>：</p><ul><li>在相邻节点之间实现发送与接收的速率匹配。</li></ul></li><li><p><strong>半双工与全双工通信</strong>：</p><ul><li>半双工：双向传输，但同一时间只允许一个方向的数据流动。</li><li>全双工：双向同时传输。</li></ul></li></ol><hr><h3 id="6-2-错误检测与纠正"><a href="#6-2-错误检测与纠正" class="headerlink" title="6.2 错误检测与纠正"></a><strong>6.2 错误检测与纠正</strong></h3><h4 id="错误检测"><a href="#错误检测" class="headerlink" title="错误检测"></a><strong>错误检测</strong></h4><ol><li><p><strong>奇偶校验（Parity Check）</strong>：</p><ul><li><strong>单比特奇偶校验</strong>：检测单个比特错误。</li><li><strong>二维奇偶校验</strong>：不仅能检测，还可以纠正单比特错误。</li></ul></li><li><p><strong>校验和（Checksum）</strong>：</p><ul><li>在传输层（如 UDP）使用。</li><li>将数据视为 16 位整数的序列，计算 1 的补码和，用于错误检测。</li></ul></li><li><p><strong>循环冗余校验（CRC）</strong>：</p><ul><li><p>检测能力强，广泛应用于以太网、WiFi 等。</p></li><li><p>基于数据和生成多项式 <code>G</code>，计算校验位 <code>R</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R = remainder(D * 2^r / G)</span><br></pre></td></tr></table></figure></li><li><p>检测突发错误的概率非常高。</p></li></ul></li></ol><hr><h3 id="6-3-多路访问协议"><a href="#6-3-多路访问协议" class="headerlink" title="6.3 多路访问协议"></a><strong>6.3 多路访问协议</strong></h3><h4 id="链路类型"><a href="#链路类型" class="headerlink" title="链路类型"></a><strong>链路类型</strong></h4><ol><li><strong>点对点链路</strong>：如拨号 PPP 链路。</li><li><strong>广播链路</strong>：多节点共享同一通信介质（如以太网、WiFi）。</li></ol><h4 id="多路访问协议分类"><a href="#多路访问协议分类" class="headerlink" title="多路访问协议分类"></a><strong>多路访问协议分类</strong></h4><ol><li><strong>信道划分协议</strong>：<ul><li><strong>时分多路访问（TDMA）</strong>：分时复用。</li><li><strong>频分多路访问（FDMA）</strong>：分频复用。</li></ul></li><li><strong>随机访问协议</strong>：<ul><li>允许冲突发生，通过随机重传恢复。</li><li><strong>ALOHA</strong>、<strong>CSMA&#x2F;CD</strong>（以太网）、<strong>CSMA&#x2F;CA</strong>（WiFi）。</li></ul></li><li><strong>轮流协议</strong>：<ul><li>节点轮流访问信道。</li><li>如<strong>轮询</strong>和<strong>令牌传递</strong>协议。</li></ul></li></ol><h4 id="典型协议"><a href="#典型协议" class="headerlink" title="典型协议"></a><strong>典型协议</strong></h4><ol><li><p><strong>ALOHA</strong>：</p><ul><li><strong>纯 ALOHA</strong>：节点立即发送，冲突概率高，效率约为 18%。</li><li><strong>时隙 ALOHA</strong>：节点在时隙开始时发送，效率提升至 37%。</li></ul></li><li><p><strong>CSMA（载波侦听多路访问）</strong>：</p><ul><li>在发送前监听信道是否空闲。</li><li><strong>CSMA&#x2F;CD（冲突检测）</strong>：<ul><li>适用于有线网络（如以太网）。</li><li>发生冲突时，立即中止传输，节省信道资源。</li></ul></li></ul></li><li><p><strong>令牌传递协议</strong>：</p><ul><li>控制令牌在节点间传递，持有令牌的节点可发送数据。</li><li>避免冲突，但可能面临令牌丢失问题。</li></ul></li></ol><hr><h3 id="6-4-局域网（LANs）"><a href="#6-4-局域网（LANs）" class="headerlink" title="6.4 局域网（LANs）"></a><strong>6.4 局域网（LANs）</strong></h3><h4 id="MAC-地址与-ARP"><a href="#MAC-地址与-ARP" class="headerlink" title="MAC 地址与 ARP"></a><strong>MAC 地址与 ARP</strong></h4><ol><li><p><strong>MAC 地址</strong>：</p><ul><li>长度：48 位，通常以 16 进制表示（如 <code>1A-2F-BB-76-09-AD</code>）。</li><li>特点：与硬件绑定，全球唯一（由 IEEE 管理分配）。</li><li>区别：<ul><li><strong>IP 地址</strong>：用于全局网络通信，基于网络拓扑。</li><li><strong>MAC 地址</strong>：用于局部链路通信。</li></ul></li></ul></li><li><p><strong>ARP（地址解析协议）</strong>：</p><ul><li>功能：通过 IP 地址解析 MAC 地址。</li><li>工作过程：<ol><li>主机广播 ARP 请求，目标 IP 地址为查询对象。</li><li>目标主机回复其 MAC 地址。</li><li>查询主机将 IP-MAC 映射缓存到 ARP 表中。</li></ol></li></ul></li></ol><hr><h4 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a><strong>以太网</strong></h4><ol><li><p><strong>以太网帧结构</strong>：</p><ul><li>包含目的 MAC 地址、源 MAC 地址、类型字段、数据和 CRC 校验。</li><li><strong>类型字段</strong>：标识上层协议（如 IP 协议）。</li></ul></li><li><p><strong>特点</strong>：</p><ul><li><strong>无连接</strong>：发送端和接收端之间没有握手。</li><li><strong>不可靠</strong>：<ul><li>丢弃错误帧，无确认或重传机制。</li><li>数据可靠性由上层协议（如 TCP）保证。</li></ul></li></ul></li><li><p><strong>拓扑结构</strong>：</p><ul><li><strong>总线型</strong>：所有节点共享同一条通信线路。</li><li><strong>星型</strong>：使用交换机连接，各节点独立通信，无冲突。</li></ul></li></ol><hr><h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a><strong>交换机</strong></h4><ol><li><p><strong>功能</strong>：</p><ul><li>链路层设备，基于 MAC 地址转发帧。</li><li>提供<strong>全双工通信</strong>，不同端口间无冲突。</li></ul></li><li><p><strong>工作机制</strong>：</p><ul><li><strong>自学习</strong>：<ul><li>通过接收帧学习源 MAC 地址与端口的对应关系。</li><li>维护转发表，记录 MAC 地址、端口和时间戳。</li></ul></li><li><strong>转发与过滤</strong>：<ul><li>若目标地址在转发表中，则将帧转发至对应端口。</li><li>若不在表中，则广播帧。</li></ul></li></ul></li><li><p><strong>优势</strong>：</p><ul><li>支持多路并行传输。</li><li>隔离冲突域，提高网络效率。</li></ul></li></ol><hr><h4 id="VLAN（虚拟局域网）"><a href="#VLAN（虚拟局域网）" class="headerlink" title="VLAN（虚拟局域网）"></a><strong>VLAN（虚拟局域网）</strong></h4><ol><li><p><strong>动机</strong>：</p><ul><li>提供逻辑上的网络隔离。</li><li>减少广播流量，提升安全性。</li></ul></li><li><p><strong>特点</strong>：</p><ul><li><strong>基于端口的 VLAN</strong>：通过交换机端口划分 VLAN。</li><li><strong>跨交换机 VLAN</strong>：<ul><li>使用 802.1Q 协议，在帧中添加 VLAN ID。</li></ul></li></ul></li></ol><hr><h3 id="6-5-链路虚拟化：MPLS"><a href="#6-5-链路虚拟化：MPLS" class="headerlink" title="6.5 链路虚拟化：MPLS"></a><strong>6.5 链路虚拟化：MPLS</strong></h3><ol><li><p><strong>多协议标签交换（MPLS）</strong>：</p><ul><li>在链路层实现虚拟电路的功能。</li><li>使用固定长度的标签（而非 IP 地址）进行转发，加速查找。</li></ul></li><li><p><strong>特点</strong>：</p><ul><li>支持流量工程：根据源地址和目标地址选择不同路径。</li><li>快速重路由：在链路失效时使用预计算的备份路径。</li></ul></li><li><p><strong>MPLS 转发表</strong>：</p><ul><li>基于标签值转发，而不依赖 IP 地址。</li></ul></li></ol><hr><h3 id="6-6-数据中心网络"><a href="#6-6-数据中心网络" class="headerlink" title="6.6 数据中心网络"></a><strong>6.6 数据中心网络</strong></h3><ol><li><p><strong>特点</strong>：</p><ul><li>包含数万台服务器，通常用于电商、搜索引擎、内容分发等。</li><li>需要高带宽和高可靠性。</li></ul></li><li><p><strong>架构</strong>：</p><ul><li><strong>层次结构</strong>：<ul><li>服务器通过 TOR（Top-of-Rack）交换机连接。</li><li>多层交换机提供冗余和高吞吐量。</li></ul></li><li><strong>负载均衡器</strong>：<ul><li>在应用层路由流量。</li><li>分配客户端请求，隐藏数据中心内部架构。</li></ul></li></ul></li></ol><hr><h3 id="6-7-Web-请求的生命周期"><a href="#6-7-Web-请求的生命周期" class="headerlink" title="6.7 Web 请求的生命周期"></a><strong>6.7 Web 请求的生命周期</strong></h3><p>以请求 <code>www.google.com</code> 为例，完整描述协议栈的应用：</p><ol><li><strong>DHCP</strong>：<ul><li>获取 IP 地址、默认网关和 DNS 服务器地址。</li></ul></li><li><strong>ARP</strong>：<ul><li>查询默认网关的 MAC 地址。</li></ul></li><li><strong>DNS</strong>：<ul><li>将 <code>www.google.com</code> 转换为 IP 地址。</li></ul></li><li><strong>TCP 三次握手</strong>：<ul><li>建立到 Web 服务器的连接。</li></ul></li><li><strong>HTTP 请求与响应</strong>：<ul><li>发送 HTTP GET 请求，接收 Web 页面。</li></ul></li></ol><hr><h3 id="总结与复习重点-4"><a href="#总结与复习重点-4" class="headerlink" title="总结与复习重点"></a><strong>总结与复习重点</strong></h3><ol><li><strong>链路层核心功能</strong>：<ul><li>错误检测与纠正、多路访问控制、链路层地址解析。</li></ul></li><li><strong>关键技术</strong>：<ul><li>以太网、交换机、自学习机制。</li><li>VLAN 提供逻辑隔离，MPLS 提供高效转发。</li></ul></li><li><strong>Web 请求的完整协议栈应用</strong>：<ul><li>结合链路层、网络层、传输层和应用层的协作。</li></ul></li></ol><hr><h3 id="推荐学习资源-4"><a href="#推荐学习资源-4" class="headerlink" title="推荐学习资源"></a><strong>推荐学习资源</strong></h3><ol><li><strong>书籍</strong>：《计算机网络：自顶向下方法》（Kurose &amp; Ross）。</li><li><strong>工具</strong>：Wireshark 数据包分析工具。</li><li><strong>在线资源</strong>：<a href="http://gaia.cs.umass.edu/kurose_ross/interactive/">Kurose &amp; Ross 在线练习</a>。</li></ol><h2 id="第七章：无线与移动网络"><a href="#第七章：无线与移动网络" class="headerlink" title="第七章：无线与移动网络"></a>第七章：无线与移动网络</h2><p>本章内容主要围绕无线与移动网络的特点、技术及其实现展开，涉及无线通信的基本概念、移动用户的地址管理与数据路由、具体协议（如IEEE 802.11与移动IP）以及无线网络对高层协议的影响。</p><hr><h3 id="7-1-介绍"><a href="#7-1-介绍" class="headerlink" title="7.1 介绍"></a><strong>7.1 介绍</strong></h3><ul><li>当前无线用户数已远超有线用户（如5:1比例）。</li><li>无线设备（如笔记本、智能手机）支持随时随地的网络访问。</li><li>无线网络面临两大挑战：<ol><li><strong>无线通信</strong>：如何在无线链路上传递数据。</li><li><strong>移动性</strong>：如何支持用户在切换接入点时保持连接。</li></ol></li></ul><hr><h3 id="7-2-无线链路及其特性"><a href="#7-2-无线链路及其特性" class="headerlink" title="7.2 无线链路及其特性"></a><strong>7.2 无线链路及其特性</strong></h3><p>无线链路具有以下显著特性：</p><ol><li><strong>信号衰减</strong>：无线信号在传播中会逐渐减弱。</li><li><strong>干扰</strong>：同频率设备间的干扰、环境中的电磁波干扰。</li><li><strong>多径传播</strong>：信号反射导致接收端接收到多个不同延时的信号，影响通信质量。</li></ol><h4 id="信噪比（SNR）与误码率（BER）"><a href="#信噪比（SNR）与误码率（BER）" class="headerlink" title="信噪比（SNR）与误码率（BER）"></a><strong>信噪比（SNR）与误码率（BER）</strong></h4><ul><li><strong>SNR</strong>：信号与噪声的比值，SNR越高，通信越可靠。</li><li><strong>BER</strong>：误码率，SNR越高，BER越低。</li><li>动态调整：根据SNR调整物理层的调制技术，如:<ul><li>QAM256（高吞吐量，低SNR适应性）。</li><li>BPSK（低吞吐量，高SNR适应性）。</li></ul></li></ul><hr><h3 id="7-3-IEEE-802-11-无线局域网（Wi-Fi）"><a href="#7-3-IEEE-802-11-无线局域网（Wi-Fi）" class="headerlink" title="7.3 IEEE 802.11 无线局域网（Wi-Fi）"></a><strong>7.3 IEEE 802.11 无线局域网（Wi-Fi）</strong></h3><h4 id="802-11标准"><a href="#802-11标准" class="headerlink" title="802.11标准"></a><strong>802.11标准</strong></h4><ul><li><strong>802.11b</strong>：2.4 GHz频段，最高11 Mbps。</li><li><strong>802.11a&#x2F;g</strong>：5 GHz频段，最高54 Mbps。</li><li><strong>802.11n</strong>：支持多天线，最高200 Mbps。</li><li><strong>802.11ac</strong>：更高数据速率，适用于现代Wi-Fi。</li></ul><h4 id="802-11网络架构"><a href="#802-11网络架构" class="headerlink" title="802.11网络架构"></a><strong>802.11网络架构</strong></h4><ol><li><strong>基础设施模式</strong>：<ul><li>通过接入点（AP）连接到有线网络。</li><li>支持“切换”（handoff），用户可在不同AP之间移动。</li></ul></li><li><strong>Ad Hoc模式</strong>：<ul><li>无接入点，节点间直接通信，适用于临时组网。</li></ul></li></ol><h4 id="信道与关联"><a href="#信道与关联" class="headerlink" title="信道与关联"></a><strong>信道与关联</strong></h4><ul><li><strong>频谱划分</strong>：802.11b将2.4GHz-2.485GHz分为11个信道。</li><li><strong>关联（Association）</strong>：<ul><li>主动扫描：设备主动发送探测帧，寻找可用AP。</li><li>被动扫描：设备监听AP发送的信标帧。</li></ul></li></ul><h4 id="多路访问控制（MAC）"><a href="#多路访问控制（MAC）" class="headerlink" title="多路访问控制（MAC）"></a><strong>多路访问控制（MAC）</strong></h4><ul><li><strong>CSMA&#x2F;CA协议</strong>：<ul><li>检测信道空闲后发送数据。</li><li>避免碰撞：发送RTS（请求发送）和CTS（允许发送）帧进行信道预留。</li></ul></li><li><strong>帧结构</strong>：<ul><li>包含源地址、目标地址、AP地址等，支持基础设施模式和Ad Hoc模式。</li></ul></li></ul><h4 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a><strong>高级功能</strong></h4><ul><li><strong>速率自适应</strong>：根据SNR动态调整传输速率。</li><li><strong>节能管理</strong>：设备可进入“休眠模式”，并定期唤醒接收AP的信标帧。</li></ul><hr><h3 id="7-4-蜂窝网络接入"><a href="#7-4-蜂窝网络接入" class="headerlink" title="7.4 蜂窝网络接入"></a><strong>7.4 蜂窝网络接入</strong></h3><h4 id="蜂窝网络架构"><a href="#蜂窝网络架构" class="headerlink" title="蜂窝网络架构"></a><strong>蜂窝网络架构</strong></h4><ul><li><strong>基站（BS）</strong>：连接移动设备和有线网络。</li><li><strong>移动交换中心（MSC）</strong>：负责呼叫建立和移动性管理。</li><li><strong>频谱共享</strong>：<ul><li><strong>FDMA&#x2F;TDMA</strong>：频率和时间的划分。</li><li><strong>CDMA</strong>：通过独特的编码允许多个用户共享相同的频率。</li></ul></li></ul><h4 id="蜂窝网络演进"><a href="#蜂窝网络演进" class="headerlink" title="蜂窝网络演进"></a><strong>蜂窝网络演进</strong></h4><ul><li><strong>2G</strong>：如GSM，主要支持语音。</li><li><strong>3G</strong>：增加数据服务，使用分组数据核心网络（GPRS）。</li><li><strong>4G LTE</strong>：核心网络基于IP，统一承载语音与数据。</li></ul><hr><h3 id="7-5-移动性的基本原理"><a href="#7-5-移动性的基本原理" class="headerlink" title="7.5 移动性的基本原理"></a><strong>7.5 移动性的基本原理</strong></h3><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a><strong>术语</strong></h4><ul><li><strong>家庭网络（Home Network）</strong>：用户的永久网络。</li><li><strong>访问网络（Visited Network）</strong>：用户当前所在的网络。</li><li><strong>永久地址（Permanent Address）</strong>：固定的IP地址，用于标识用户。</li><li><strong>转交地址（Care-of-Address）</strong>：临时分配的地址，用于路由转发。</li><li><strong>家庭代理（Home Agent）</strong>：负责跟踪用户位置并转发数据。</li><li><strong>外部代理（Foreign Agent）</strong>：在访问网络中代表用户。</li></ul><h4 id="移动性管理方式"><a href="#移动性管理方式" class="headerlink" title="移动性管理方式"></a><strong>移动性管理方式</strong></h4><ol><li><strong>间接路由</strong>：<ul><li>通信由家庭代理转发至外部代理，再转发到移动用户。</li><li>存在“三角路由”问题，效率较低。</li></ul></li><li><strong>直接路由</strong>：<ul><li>通信方直接获取用户的转交地址，减少转发步骤。</li><li>需要动态更新地址，复杂度较高。</li></ul></li></ol><hr><h3 id="7-6-移动IP"><a href="#7-6-移动IP" class="headerlink" title="7.6 移动IP"></a><strong>7.6 移动IP</strong></h3><ul><li><strong>定义</strong>：RFC 3344，支持在不同网络之间切换时保持IP地址不变。</li><li><strong>功能组件</strong>：<ol><li><strong>间接路由</strong>：家庭代理负责转发数据。</li><li><strong>代理发现</strong>：通过ICMP消息广播外部代理信息。</li><li><strong>注册</strong>：移动节点向家庭代理报告其转交地址。</li></ol></li></ul><h4 id="数据转发流程"><a href="#数据转发流程" class="headerlink" title="数据转发流程"></a><strong>数据转发流程</strong></h4><ol><li>通信方向移动节点的永久地址发送数据包。</li><li>家庭代理接收数据包，封装后转发至外部代理。</li><li>外部代理解封数据包并交付给移动节点。</li></ol><hr><h3 id="7-7-蜂窝网络中的移动性管理"><a href="#7-7-蜂窝网络中的移动性管理" class="headerlink" title="7.7 蜂窝网络中的移动性管理"></a><strong>7.7 蜂窝网络中的移动性管理</strong></h3><h4 id="位置管理"><a href="#位置管理" class="headerlink" title="位置管理"></a><strong>位置管理</strong></h4><ol><li><strong>家庭位置寄存器（HLR）</strong>：存储用户的永久信息及当前位置。</li><li><strong>访客位置寄存器（VLR）</strong>：存储用户的临时信息。</li></ol><h4 id="切换管理（Handoff）"><a href="#切换管理（Handoff）" class="headerlink" title="切换管理（Handoff）"></a><strong>切换管理（Handoff）</strong></h4><ul><li><strong>同一MSC内切换</strong>：<ul><li>原基站检测到信号变弱后触发切换。</li><li>新基站分配资源并通知移动设备切换。</li></ul></li><li><strong>跨MSC切换</strong>：<ul><li>引入“锚点MSC”，所有数据通过锚点转发至当前基站。</li><li>可选路径优化步骤减少转发路径。</li></ul></li></ul><h4 id="LTE中的移动性"><a href="#LTE中的移动性" class="headerlink" title="LTE中的移动性"></a><strong>LTE中的移动性</strong></h4><ul><li><strong>寻呼（Paging）</strong>：广播消息定位空闲用户。</li><li><strong>切换</strong>：<ol><li>准备阶段：新基站分配资源。</li><li>执行阶段：用户切换到新基站。</li><li>完成阶段：释放旧基站资源。</li></ol></li></ul><hr><h3 id="7-8-移动性对高层协议的影响"><a href="#7-8-移动性对高层协议的影响" class="headerlink" title="7.8 移动性对高层协议的影响"></a><strong>7.8 移动性对高层协议的影响</strong></h3><ul><li><strong>TCP性能问题</strong>：<ul><li>无线链路的高误码率和切换延迟会导致TCP误判为网络拥塞，降低窗口大小。</li></ul></li><li><strong>实时流量</strong>：<ul><li>延迟波动和丢包会影响实时应用（如语音、视频）。</li></ul></li><li><strong>带宽限制</strong>：<ul><li>无线链路的带宽通常低于有线网络，需优化传输。</li></ul></li></ul><hr><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a><strong>实例分析</strong></h3><h4 id="CDMA编码与解码"><a href="#CDMA编码与解码" class="headerlink" title="CDMA编码与解码"></a><strong>CDMA编码与解码</strong></h4><ul><li>每个用户分配唯一的“码”，数据通过与码的内积进行解码。</li><li>即使多个用户同时发送，接收端仍可通过码的正交性分离信号。</li></ul><h4 id="802-11的RTS-CTS机制"><a href="#802-11的RTS-CTS机制" class="headerlink" title="802.11的RTS-CTS机制"></a><strong>802.11的RTS-CTS机制</strong></h4><ul><li><strong>RTS帧</strong>：发送端请求信道占用。</li><li><strong>CTS帧</strong>：接收端确认信道可用。</li><li>避免长数据帧的碰撞，提高传输效率。</li></ul><h4 id="移动IP的三角路由问题"><a href="#移动IP的三角路由问题" class="headerlink" title="移动IP的三角路由问题"></a><strong>移动IP的三角路由问题</strong></h4><ul><li>数据需经过家庭代理转发，即使通信双方在同一网络中，导致效率低下。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
