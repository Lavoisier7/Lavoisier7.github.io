<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta name="keywords" content="Database Principle, D">
    <meta name="description" content="2024-2025 DCS281">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Database Principle | D</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 7.3.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>


<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">D</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">D</div>
        <div class="logo-desc">
            
            世故消耗激情，岁月打磨棱角，现实浪掷理想。
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/Lavoisier7/Lavoisier7.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/Lavoisier7/Lavoisier7.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/9.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Database Principle</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/SQL-Server/">
                                <span class="chip bg-color">SQL Server</span>
                            </a>
                        
                            <a href="/tags/Database/">
                                <span class="chip bg-color">Database</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Computer-Science/" class="post-category">
                                Computer Science
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-11-25
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2025-04-30
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    23.5k
                </div>
                

                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>本文基于《Database System Concepts, 7th Ed.》的课本内容，对 SYSU-CSE DCS281 计算机专业课《数据库系统原理》进行较为详尽的知识点总结，涵盖少量实例分析。</p>
<h2 id="第一章-数据库系统概述"><a href="#第一章-数据库系统概述" class="headerlink" title="第一章 数据库系统概述"></a>第一章 数据库系统概述</h2><h3 id="1-1-数据库应用实例"><a href="#1-1-数据库应用实例" class="headerlink" title="1.1 数据库应用实例"></a>1.1 数据库应用实例</h3><p><strong>重点：</strong></p>
<ul>
<li>了解数据库在各行业中的应用，如企业信息管理、制造业、银行与金融、大学系统、航空公司、电信、网络服务等。</li>
</ul>
<p><strong>难点：</strong></p>
<ul>
<li>理解不同应用场景下数据库系统的具体需求和实现方式。</li>
</ul>
<p><strong>实例分析：</strong></p>
<ul>
<li><strong>银行与金融</strong>：管理客户信息、账户、贷款及交易。</li>
<li><strong>航空公司</strong>：处理预订和航班时刻表。</li>
<li><strong>电信</strong>：记录通话、短信和数据使用情况，生成月度账单。</li>
</ul>
<h3 id="1-2-数据与数据库系统"><a href="#1-2-数据与数据库系统" class="headerlink" title="1.2 数据与数据库系统"></a>1.2 数据与数据库系统</h3><p><strong>重点：</strong></p>
<ul>
<li>区分数据与信息，理解数据库系统的定义及其目的。</li>
</ul>
<p><strong>难点：</strong></p>
<ul>
<li>理解数据抽象及其在数据库系统中的作用。</li>
</ul>
<p><strong>实例分析：</strong></p>
<ul>
<li><strong>数据</strong>：符号化的信息，如学生成绩、图片的像素点。</li>
<li><strong>信息</strong>：数据的语义解释，如“学生A的数学成绩为90分”。</li>
</ul>
<h3 id="1-3-数据库系统组件"><a href="#1-3-数据库系统组件" class="headerlink" title="1.3 数据库系统组件"></a>1.3 数据库系统组件</h3><p><strong>重点：</strong></p>
<ul>
<li>数据库系统的组成部分：硬件、软件、数据、用户。</li>
</ul>
<p><strong>难点：</strong></p>
<ul>
<li>理解各组件在数据库系统中的角色及其相互关系。</li>
</ul>
<p><strong>实例分析：</strong></p>
<ul>
<li><strong>硬件</strong>：大容量内存、外存设备（如磁盘、磁带）。</li>
<li><strong>软件</strong>：操作系统、DBMS、编程接口。</li>
<li><strong>数据</strong>：目标数据与描述数据。</li>
<li><strong>用户</strong>：最终用户、应用程序员、系统分析员、数据库管理员（DBA）。</li>
</ul>
<h3 id="1-4-数据库设计"><a href="#1-4-数据库设计" class="headerlink" title="1.4 数据库设计"></a>1.4 数据库设计</h3><p><strong>重点：</strong></p>
<ul>
<li>理解数据库设计的逻辑设计与物理设计。</li>
<li>理解模式（Schema）与实例（Instance）的区别。</li>
</ul>
<p><strong>难点：</strong></p>
<ul>
<li>如何进行有效的数据库模式设计，确保数据的一致性和完整性。</li>
</ul>
<p><strong>实例分析：</strong></p>
<ul>
<li><strong>逻辑设计</strong>：定义关系模式，如 <code>instructor(ID, name, dept_name, salary)</code>。</li>
<li><strong>物理设计</strong>：决定数据在存储介质上的实际存储方式。</li>
</ul>
<h3 id="1-5-数据定义语言（DDL）与数据操作语言（DML）"><a href="#1-5-数据定义语言（DDL）与数据操作语言（DML）" class="headerlink" title="1.5 数据定义语言（DDL）与数据操作语言（DML）"></a>1.5 数据定义语言（DDL）与数据操作语言（DML）</h3><p><strong>重点：</strong></p>
<ul>
<li>DDL用于定义数据库模式，如创建表。</li>
<li>DML用于访问和操作数据库中的数据，如查询、插入、更新、删除。</li>
</ul>
<p><strong>难点：</strong></p>
<ul>
<li>理解DDL与DML的区别及其在实际操作中的应用。</li>
</ul>
<p><strong>实例分析：</strong></p>
<ul>
<li><p><strong>DDL 示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> instructor (</span><br><span class="line">    ID <span class="type">CHAR</span>(<span class="number">5</span>),</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    dept_name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    salary <span class="type">NUMERIC</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>DML 示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> instructor</span><br><span class="line"><span class="keyword">WHERE</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Comp. Sci.&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-6-SQL查询语言"><a href="#1-6-SQL查询语言" class="headerlink" title="1.6 SQL查询语言"></a>1.6 SQL查询语言</h3><p><strong>重点：</strong></p>
<ul>
<li>SQL作为非过程化查询语言的基本语法和使用方法。</li>
</ul>
<p><strong>难点：</strong></p>
<ul>
<li>编写复杂的SQL查询，包括多表联接、子查询等。</li>
</ul>
<p><strong>实例分析：</strong></p>
<ul>
<li><p><strong>查询示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> instructor</span><br><span class="line"><span class="keyword">WHERE</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Physics&#x27;</span> <span class="keyword">AND</span> salary <span class="operator">&gt;</span> <span class="number">90000</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-7-数据库系统架构"><a href="#1-7-数据库系统架构" class="headerlink" title="1.7 数据库系统架构"></a>1.7 数据库系统架构</h3><p><strong>重点：</strong></p>
<ul>
<li>理解集中式数据库、客户端-服务器架构、并行数据库和分布式数据库的区别。</li>
</ul>
<p><strong>难点：</strong></p>
<ul>
<li>选择适合特定应用场景的数据库架构。</li>
</ul>
<p><strong>实例分析：</strong></p>
<ul>
<li><strong>三层架构</strong>：客户端、应用服务器、数据库服务器。</li>
<li><strong>分布式数据库</strong>：支持地理分布的数据存储和访问。</li>
</ul>
<h3 id="1-8-数据库系统的发展历史"><a href="#1-8-数据库系统的发展历史" class="headerlink" title="1.8 数据库系统的发展历史"></a>1.8 数据库系统的发展历史</h3><p><strong>重点：</strong></p>
<ul>
<li>数据库系统的发展历程，从磁带时代到关系模型，再到现代的NoSQL和大数据系统。</li>
</ul>
<p><strong>难点：</strong></p>
<ul>
<li>理解不同历史阶段数据库技术的演进及其驱动因素。</li>
</ul>
<p><strong>实例分析：</strong></p>
<ul>
<li><strong>关系模型的提出</strong>：E.F. Codd在1970年提出关系模型，奠定了现代关系数据库的基础。</li>
<li><strong>NoSQL系统</strong>：如Google BigTable、Amazon Dynamo，适用于大规模分布式数据存储。</li>
</ul>
<hr>
<h2 id="第二章-关系模型与关系代数"><a href="#第二章-关系模型与关系代数" class="headerlink" title="第二章 关系模型与关系代数"></a>第二章 关系模型与关系代数</h2><h3 id="2-1-关系模型基础"><a href="#2-1-关系模型基础" class="headerlink" title="2.1 关系模型基础"></a>2.1 关系模型基础</h3><p><strong>重点：</strong></p>
<ul>
<li>关系模型的三要素：关系、属性、元组。</li>
<li>理解关系数据库的模式与实例。</li>
</ul>
<p><strong>难点：</strong></p>
<ul>
<li>理解关系的数学定义及其在数据库中的应用。</li>
</ul>
<p><strong>实例分析：</strong></p>
<ul>
<li><p><strong>关系定义</strong>：</p>
<p>关系R定义在D1, D2, …, Dn上的笛卡尔积 D1×D2×…×Dn 的一个命名子集。</p>
</li>
<li><p><strong>示例关系</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">student (student_no, sex, name)</span><br><span class="line">-------------------------------</span><br><span class="line">1 | Male | Jones</span><br><span class="line">2 | Male | Smith</span><br><span class="line">3 | Female | Kate</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-2-关系的性质"><a href="#2-2-关系的性质" class="headerlink" title="2.2 关系的性质"></a>2.2 关系的性质</h3><p><strong>重点：</strong></p>
<ul>
<li>关系的基本性质：列同质性、行唯一性、无序性、原子性。</li>
</ul>
<p><strong>难点：</strong></p>
<ul>
<li>理解并应用第一范式（1NF）概念。</li>
</ul>
<p><strong>实例分析：</strong></p>
<ul>
<li><p><strong>违反1NF的例子</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A | B | A</span><br><span class="line">------------</span><br><span class="line">1 | &quot;abc&quot; | &quot;c&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>满足1NF的例子</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A | B | C</span><br><span class="line">------------</span><br><span class="line">1 | &quot;abc&quot; | &quot;c&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-3-关键字概念"><a href="#2-3-关键字概念" class="headerlink" title="2.3 关键字概念"></a>2.3 关键字概念</h3><p><strong>重点：</strong></p>
<ul>
<li>主键、外键、候选键、超键的定义与区别。</li>
</ul>
<p><strong>难点：</strong></p>
<ul>
<li>理解外键的引用机制，不依赖于属性名称相同。</li>
</ul>
<p><strong>实例分析：</strong></p>
<ul>
<li><p><strong>外键示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">student (dept_no, student_no, name, sex)</span><br><span class="line">department (dept_no, dept_name)</span><br></pre></td></tr></table></figure>

<p><code>dept_no</code>在<code>student</code>中作为外键，引用<code>department</code>中的主键<code>dept_no</code>。</p>
</li>
</ul>
<h3 id="2-4-关系代数操作"><a href="#2-4-关系代数操作" class="headerlink" title="2.4 关系代数操作"></a>2.4 关系代数操作</h3><p><strong>重点：</strong></p>
<ul>
<li>关系代数的基本操作：选择（σ）、投影（π）、并（∪）、差（−）、笛卡尔积（×）、重命名（ρ）。</li>
</ul>
<p><strong>难点：</strong></p>
<ul>
<li>组合多个关系代数操作以构建复杂查询。</li>
</ul>
<p><strong>实例分析：</strong></p>
<ul>
<li><p><strong>选择操作</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">σ dept_name=&quot;Physics&quot; (instructor)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>投影操作</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">π name (σ dept_name=&quot;Physics&quot; (instructor))</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>联合操作</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">π course_id (σ semester=&quot;Fall&quot; AND year=2017 (section)) </span><br><span class="line">∪ </span><br><span class="line">π course_id (σ semester=&quot;Spring&quot; AND year=2018 (section))</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>差集操作</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">π course_id (σ semester=&quot;Fall&quot; AND year=2017 (section)) </span><br><span class="line">− </span><br><span class="line">π course_id (σ semester=&quot;Spring&quot; AND year=2018 (section))</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>笛卡尔积与选择的结合</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">σ instructor.id = teaches.id (instructor × teaches)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重命名操作</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ρ boy (σ sex=&quot;Male&quot; (student))</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-5-关系操作实例"><a href="#2-5-关系操作实例" class="headerlink" title="2.5 关系操作实例"></a>2.5 关系操作实例</h3><p><strong>重点：</strong></p>
<ul>
<li>理解并能具体化关系代数操作的结果。</li>
</ul>
<p><strong>难点：</strong></p>
<ul>
<li>解析复杂关系代数表达式的执行步骤与结果。</li>
</ul>
<p><strong>实例分析：</strong></p>
<ul>
<li><p><strong>删除操作</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R ← R − E</span><br></pre></td></tr></table></figure>

<p>示例：从<code>student</code>中删除满足特定条件的元组。</p>
</li>
<li><p><strong>插入操作</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R ← R ∪ &#123; r &#125;</span><br></pre></td></tr></table></figure>

<p>示例：向<code>student</code>表中插入一个新元组。</p>
</li>
<li><p><strong>全部更新</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r ← π F1, F2, …, Fn (r)</span><br></pre></td></tr></table></figure>

<p>示例：对<code>Emp</code>表中所有职工的工资上调10%。</p>
</li>
<li><p><strong>部分更新</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r ← π F1, F2, …, Fn (σ p(r)) ∪ (r − σ p(r))</span><br></pre></td></tr></table></figure>

<p>示例：仅更新<code>Emp</code>表中姓名为“小张”的职工工资。</p>
</li>
</ul>
<h3 id="2-6-关系代数运算示例解析"><a href="#2-6-关系代数运算示例解析" class="headerlink" title="2.6 关系代数运算示例解析"></a>2.6 关系代数运算示例解析</h3><p><strong>重点：</strong></p>
<ul>
<li>熟练掌握关系代数运算的具体操作及其结果。</li>
</ul>
<p><strong>难点：</strong></p>
<ul>
<li>理解运算顺序及其对结果的影响。</li>
</ul>
<p><strong>实例分析：</strong></p>
<ul>
<li><p><strong>例1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">σ 1=1 (student)</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>：返回<code>student</code>表中的所有元组，因为条件始终为真。</p>
</li>
<li><p><strong>例2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">σ 1=2 (student)</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>：返回空集，因为条件始终为假。</p>
</li>
</ul>
<hr>
<h3 id="2-7-重点与难点总结"><a href="#2-7-重点与难点总结" class="headerlink" title="2.7 重点与难点总结"></a>2.7 重点与难点总结</h3><h4 id="重点："><a href="#重点：" class="headerlink" title="重点："></a>重点：</h4><ol>
<li><strong>关系模型的基本概念</strong>：关系、属性、元组、主键与外键。</li>
<li><strong>关系代数的基本操作</strong>：选择、投影、并、差、笛卡尔积、重命名。</li>
<li><strong>数据库设计</strong>：逻辑设计与物理设计，模式与实例的区别。</li>
<li><strong>SQL语言</strong>：DDL与DML的使用，编写复杂查询。</li>
<li><strong>数据库系统架构与组件</strong>：存储管理器、查询处理器、事务管理。</li>
</ol>
<h4 id="难点："><a href="#难点：" class="headerlink" title="难点："></a>难点：</h4><ol>
<li><strong>关系代数的复杂操作</strong>：多步操作的组合理解与应用。</li>
<li><strong>数据库设计中的范式</strong>：确保数据库设计符合高范式以避免数据冗余。</li>
<li><strong>事务管理与ACID特性</strong>：理解事务的原子性、一致性、隔离性与持久性。</li>
<li><strong>SQL的高级查询</strong>：子查询、联接操作、优化查询性能。</li>
</ol>
<hr>
<h3 id="2-8-关键术语解释"><a href="#2-8-关键术语解释" class="headerlink" title="2.8 关键术语解释"></a>2.8 关键术语解释</h3><ul>
<li><strong>关系（Relation）</strong>：一个二维表，由行（元组）和列（属性）组成。</li>
<li><strong>属性（Attribute）</strong>：关系中的列，具有唯一的名称和定义良好的域。</li>
<li><strong>元组（Tuple）</strong>：关系中的行，代表数据项的一个实例。</li>
<li><strong>主键（Primary Key）</strong>：唯一标识关系中每个元组的属性或属性组合。</li>
<li><strong>外键（Foreign Key）</strong>：一个关系中的属性或属性组合，用于引用另一个关系的主键。</li>
<li><strong>关系代数（Relational Algebra）</strong>：一种过程化查询语言，用于对关系进行操作和查询。</li>
<li><strong>范式（Normal Form）</strong>：数据库设计中的规范，用以减少数据冗余和确保数据一致性。</li>
<li><strong>事务（Transaction）</strong>：一组操作，要么全部执行成功，要么全部失败，确保数据库的一致性。</li>
</ul>
<hr>
<h3 id="2-9-图表与图示描述"><a href="#2-9-图表与图示描述" class="headerlink" title="2.9 图表与图示描述"></a>2.9 图表与图示描述</h3><p>由于文本性质，以下为关键图表和图示的文字描述：</p>
<ol>
<li><p><strong>数据库系统架构图</strong>：</p>
<ul>
<li>分为三个层次：<ul>
<li><strong>物理层</strong>：描述数据在存储介质上的存储方式。</li>
<li><strong>逻辑层</strong>：描述数据库中的数据结构和关系。</li>
<li><strong>视图层</strong>：不同用户视角的数据展示，隐藏底层细节。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>关系模型示意图</strong>：</p>
<ul>
<li>展示一个关系的二维表结构，包括属性名、元组行，以及主键与外键的标识。</li>
</ul>
</li>
<li><p><strong>关系代数操作流程图</strong>：</p>
<ul>
<li>例如，选择操作σ的流程：输入关系 → 应用选择条件 → 输出满足条件的子集关系。</li>
</ul>
</li>
<li><p><strong>事务管理流程图</strong>：</p>
<ul>
<li>展示事务的开始、执行、提交或回滚的过程，确保ACID特性。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-10-实例分析详解"><a href="#2-10-实例分析详解" class="headerlink" title="2.10 实例分析详解"></a>2.10 实例分析详解</h3><h4 id="实例1：关系代数的选择操作"><a href="#实例1：关系代数的选择操作" class="headerlink" title="实例1：关系代数的选择操作"></a>实例1：关系代数的选择操作</h4><p><strong>问题描述：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">σ dept_name=&quot;Physics&quot; AND salary &gt; 90000 (instructor)</span><br></pre></td></tr></table></figure>

<p><strong>步骤解析：</strong></p>
<ol>
<li><strong>输入关系</strong>：<code>instructor</code>表。</li>
<li><strong>选择条件</strong>：<code>dept_name</code>等于”Physics”且<code>salary</code>大于90000。</li>
<li><strong>执行操作</strong>：遍历<code>instructor</code>表中的每个元组，筛选符合条件的元组。</li>
<li><strong>输出结果</strong>：所有属于”Physics”系且工资超过90000的教员信息。</li>
</ol>
<p><strong>SQL等效语句：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> instructor</span><br><span class="line"><span class="keyword">WHERE</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Physics&#x27;</span> <span class="keyword">AND</span> salary <span class="operator">&gt;</span> <span class="number">90000</span>;</span><br></pre></td></tr></table></figure>

<h4 id="实例2：关系代数的联合操作"><a href="#实例2：关系代数的联合操作" class="headerlink" title="实例2：关系代数的联合操作"></a>实例2：关系代数的联合操作</h4><p><strong>问题描述：</strong><br>查找所有在2017年秋季和2018年春季教授的课程。</p>
<p><strong>关系代数表达式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">π course_id (σ semester=&quot;Fall&quot; AND year=2017 (section))</span><br><span class="line">∪</span><br><span class="line">π course_id (σ semester=&quot;Spring&quot; AND year=2018 (section))</span><br></pre></td></tr></table></figure>

<p><strong>步骤解析：</strong></p>
<ol>
<li><strong>第一部分</strong>：选择<code>semester</code>为”Fall”且<code>year</code>为2017的<code>section</code>表中的<code>course_id</code>。</li>
<li><strong>第二部分</strong>：选择<code>semester</code>为”Spring”且<code>year</code>为2018的<code>section</code>表中的<code>course_id</code>。</li>
<li><strong>执行联合操作</strong>：将两部分结果合并，去除重复的<code>course_id</code>。</li>
<li><strong>输出结果</strong>：所有在指定学期教授过的课程编号。</li>
</ol>
<p><strong>SQL等效语句：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> course_id</span><br><span class="line"><span class="keyword">FROM</span> section</span><br><span class="line"><span class="keyword">WHERE</span> semester <span class="operator">=</span> <span class="string">&#x27;Fall&#x27;</span> <span class="keyword">AND</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2017</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> course_id</span><br><span class="line"><span class="keyword">FROM</span> section</span><br><span class="line"><span class="keyword">WHERE</span> semester <span class="operator">=</span> <span class="string">&#x27;Spring&#x27;</span> <span class="keyword">AND</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2018</span>;</span><br></pre></td></tr></table></figure>

<h4 id="实例3：SQL插入操作"><a href="#实例3：SQL插入操作" class="headerlink" title="实例3：SQL插入操作"></a>实例3：SQL插入操作</h4><p><strong>问题描述：</strong><br>向<code>student</code>表中插入一个新学生，学号为4，姓名“小周”，性别“女”。</p>
<p><strong>关系代数表达式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S ← S ∪ &#123; (4, &quot;小周&quot;, &quot;女&quot;) &#125;</span><br></pre></td></tr></table></figure>

<p><strong>SQL语句：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student (student_no, name, sex) <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;小周&#x27;</span>, <span class="string">&#x27;女&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>执行步骤：</strong></p>
<ol>
<li><strong>指定目标关系</strong>：<code>student</code>表。</li>
<li><strong>定义新元组</strong>：学号为4，姓名“小周”，性别“女”。</li>
<li><strong>执行插入操作</strong>：将新元组添加到<code>student</code>表中。</li>
</ol>
<p><strong>结果：</strong><br><code>student</code>表新增一条记录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">student_no | name | sex</span><br><span class="line">---------- | ---- | ---</span><br><span class="line">4          | 小周 | 女</span><br></pre></td></tr></table></figure>

<h4 id="实例4：关系代数的笛卡尔积与选择"><a href="#实例4：关系代数的笛卡尔积与选择" class="headerlink" title="实例4：关系代数的笛卡尔积与选择"></a>实例4：关系代数的笛卡尔积与选择</h4><p><strong>问题描述：</strong><br>将<code>instructor</code>与<code>teaches</code>表进行笛卡尔积，并筛选出匹配的教员与课程。</p>
<p><strong>关系代数表达式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">σ instructor.id = teaches.id (instructor × teaches)</span><br></pre></td></tr></table></figure>

<p><strong>步骤解析：</strong></p>
<ol>
<li><strong>笛卡尔积</strong>：生成<code>instructor</code>与<code>teaches</code>表的所有可能行组合。</li>
<li><strong>选择操作</strong>：仅保留<code>instructor.id</code>等于<code>teaches.id</code>的元组。</li>
<li><strong>输出结果</strong>：教员与其教授课程的对应关系。</li>
</ol>
<p><strong>SQL等效语句：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> instructor</span><br><span class="line"><span class="keyword">JOIN</span> teaches <span class="keyword">ON</span> instructor.id <span class="operator">=</span> teaches.id;</span><br></pre></td></tr></table></figure>

<p><strong>结果示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">instructor.ID | instructor.name | teaches.course_id</span><br><span class="line">------------- | --------------- | -----------------</span><br><span class="line">1             | 张三            | CS101</span><br><span class="line">2             | 李四            | CS102</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第三章-SQL查询语言概述"><a href="#第三章-SQL查询语言概述" class="headerlink" title="第三章 SQL查询语言概述"></a>第三章 SQL查询语言概述</h2><h3 id="3-1-重点"><a href="#3-1-重点" class="headerlink" title="3.1 重点"></a>3.1 重点</h3><ol>
<li><p><strong>SQL语言的组成</strong>：</p>
<ul>
<li><strong>数据定义语言（DDL）</strong>：包括创建、修改和删除数据库对象（如表、视图、索引等）。</li>
<li><strong>数据操纵语言（DML）</strong>：用于查询、插入、更新和删除数据。</li>
<li><strong>数据控制语言（DCL）</strong>：用于授权和管理用户权限。</li>
</ul>
</li>
<li><p><strong>SQL数据类型与模式</strong>：</p>
<ul>
<li>常用数据类型包括<code>char(n)</code>、<code>varchar(n)</code>、<code>int</code>、<code>smallint</code>、<code>numeric(p,d)</code>、<code>real</code>、<code>double precision</code>、<code>float(n)</code>等。</li>
<li>模式定义了数据库中各关系的结构，包括属性名、数据类型、完整性约束等。</li>
</ul>
</li>
<li><p><strong>SQL语句结构</strong>：</p>
<ul>
<li><strong>SELECT语句</strong>：包含<code>SELECT</code>、<code>FROM</code>、<code>WHERE</code>、<code>GROUP BY</code>、<code>HAVING</code>、<code>ORDER BY</code>等子句。</li>
<li><strong>JOIN操作</strong>：包括自然连接、内连接和外连接，理解不同类型的连接及其应用。</li>
</ul>
</li>
<li><p><strong>完整性约束</strong>：</p>
<ul>
<li><strong>实体完整性</strong>：主键不允许为<code>NULL</code>，确保每个元组的唯一性。</li>
<li><strong>参照完整性</strong>：外键必须引用另一个关系的主键或唯一键。</li>
<li><strong>用户定义完整性</strong>：通过<code>CHECK</code>约束等自定义规则确保数据的合理性。</li>
</ul>
</li>
</ol>
<h3 id="3-2-难点"><a href="#3-2-难点" class="headerlink" title="3.2 难点"></a>3.2 难点</h3><ol>
<li><strong>子查询与嵌套查询</strong>：理解相关子查询与非相关子查询的区别及其在<code>SELECT</code>、<code>WHERE</code>、<code>FROM</code>子句中的应用。</li>
<li><strong>复杂连接操作</strong>：掌握多表连接、不同类型的外连接及其在实际问题中的应用，如避免错误的自然连接导致的数据失配。</li>
<li><strong>聚集函数与分组</strong>：正确使用<code>GROUP BY</code>和<code>HAVING</code>子句，理解聚集函数的作用及其在查询优化中的重要性。</li>
<li><strong>视图的创建与管理</strong>：理解视图的本质、创建复杂视图的条件以及视图的更新限制。</li>
</ol>
<h3 id="3-3-实例分析"><a href="#3-3-实例分析" class="headerlink" title="3.3 实例分析"></a>3.3 实例分析</h3><p><strong>例1：查找所有导师的姓名</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> instructor;</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong><br>该查询语句选择<code>instructor</code>关系中的<code>name</code>属性，返回所有导师的姓名。</p>
<hr>
<p><strong>例2：查找计算机科学系的导师姓名和课程编号</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, course_id</span><br><span class="line"><span class="keyword">FROM</span> instructor, teaches</span><br><span class="line"><span class="keyword">WHERE</span> instructor.ID <span class="operator">=</span> teaches.ID</span><br><span class="line">  <span class="keyword">AND</span> instructor.dept_name <span class="operator">=</span> <span class="string">&#x27;Comp. Sci.&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong><br>该查询通过连接<code>instructor</code>和<code>teaches</code>关系，筛选计算机科学系的导师，并返回他们的姓名及所教授的课程编号。</p>
<hr>
<p><strong>例3：删除数学成绩不及格的学生选修信息</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> takes</span><br><span class="line"><span class="keyword">WHERE</span> grade <span class="operator">&lt;</span> <span class="string">&#x27;60&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong><br>该语句从<code>takes</code>关系中删除所有成绩低于60的记录，假设60为及格线。</p>
<hr>
<p><strong>例4：增加所有导师的薪水5%</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> instructor</span><br><span class="line"><span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.05</span>;</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong><br>该语句将<code>instructor</code>关系中所有导师的薪水增加5%。</p>
<hr>
<p><strong>例5：使用子查询查找平均薪水以上的导师</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> instructor</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> instructor);</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong><br>该查询返回薪水高于所有导师平均薪水的导师姓名。</p>
<hr>
<p><strong>例6：创建视图显示不包含薪水的导师信息</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> faculty <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> ID, name, dept_name</span><br><span class="line"><span class="keyword">FROM</span> instructor;</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong><br>该视图<code>faculty</code>仅包含导师的<code>ID</code>、<code>name</code>和<code>dept_name</code>，隐藏了<code>salary</code>属性，提高了数据的安全性。</p>
<hr>
<p><strong>例7：使用JOIN操作查找学生及其班主任</strong></p>
<p>假设有两个关系：</p>
<ul>
<li><code>Stu</code>（学生）</li>
<li><code>Class</code>（班级）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Stu.name, Class.ban_zhuren</span><br><span class="line"><span class="keyword">FROM</span> Stu</span><br><span class="line"><span class="keyword">JOIN</span> Class <span class="keyword">ON</span> Stu.ban_hao <span class="operator">=</span> Class.ban_hao;</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong><br>该查询通过<code>JOIN</code>操作连接<code>Stu</code>和<code>Class</code>关系，返回每个学生的姓名及其对应的班主任。</p>
<hr>
<h2 id="第四章-访问SQL与触发器"><a href="#第四章-访问SQL与触发器" class="headerlink" title="第四章 访问SQL与触发器"></a>第四章 访问SQL与触发器</h2><h3 id="4-1-重点"><a href="#4-1-重点" class="headerlink" title="4.1 重点"></a>4.1 重点</h3><ol>
<li><p><strong>访问SQL的两种方法</strong>：</p>
<ul>
<li><strong>动态SQL</strong>：在运行时生成和执行SQL语句，适合需要根据条件动态改变查询的场景。</li>
<li><strong>嵌入式SQL</strong>：将SQL语句嵌入到一般编程语言中，编译时转换为函数调用，提高执行效率。</li>
</ul>
</li>
<li><p><strong>JDBC（Java数据库连接）</strong>：</p>
<ul>
<li><strong>核心操作流程</strong>：加载驱动、建立连接、创建语句、执行查询、处理结果、关闭连接。</li>
<li><strong>特点</strong>：跨平台、支持对象-关系映射、网络独立性、数据库独立性等。</li>
</ul>
</li>
<li><p><strong>完整性约束与事务管理</strong>：</p>
<ul>
<li><strong>事务的ACID特性</strong>：原子性、一致性、隔离性、持久性。</li>
<li><strong>事务控制语句</strong>：<code>BEGIN TRANSACTION</code>、<code>COMMIT</code>、<code>ROLLBACK</code>等。</li>
</ul>
</li>
<li><p><strong>触发器</strong>：</p>
<ul>
<li><strong>定义与作用</strong>：在特定事件（如<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>）发生时自动执行的存储过程。</li>
<li><strong>类型</strong>：<code>AFTER</code>触发器、<code>INSTEAD OF</code>触发器。</li>
<li><strong>应用实例</strong>：维护数据一致性、自动更新相关表、日志记录等。</li>
</ul>
</li>
</ol>
<h3 id="4-2-难点"><a href="#4-2-难点" class="headerlink" title="4.2 难点"></a>4.2 难点</h3><ol>
<li><strong>触发器的设计与实现</strong>：如何正确设计触发器的触发条件和执行动作，避免递归触发和性能问题。</li>
<li><strong>事务的并发控制与隔离级别</strong>：理解不同隔离级别（如读未提交、读已提交、可重复读、串行化）的特点及其对数据库性能与一致性的影响。</li>
<li><strong>JDBC的高级特性</strong>：如批处理、预编译语句、元数据获取等，需要深入理解其API的使用方法和最佳实践。</li>
<li><strong>权限管理与安全性</strong>：正确配置用户权限，理解角色的创建与分配，以及视图在数据安全中的应用。</li>
</ol>
<h3 id="4-3-实例分析"><a href="#4-3-实例分析" class="headerlink" title="4.3 实例分析"></a>4.3 实例分析</h3><p><strong>例1：使用JDBC连接数据库并查询导师信息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">JDBCexample</span><span class="params">(String dbid, String userid, String passwd)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(</span><br><span class="line">            <span class="string">&quot;jdbc:oracle:thin:@db.yale.edu:2000:univdb&quot;</span>, userid, passwd);</span><br><span class="line">         <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement()) &#123;</span><br><span class="line">        <span class="comment">// 执行查询</span></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(<span class="string">&quot;SELECT * FROM instructor&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">            System.out.println(rs.getString(<span class="string">&quot;name&quot;</span>) + <span class="string">&quot; &quot;</span> + rs.getFloat(<span class="string">&quot;salary&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException sqle) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SQLException : &quot;</span> + sqle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong><br>该Java方法使用JDBC连接到Oracle数据库，查询<code>instructor</code>关系中的所有记录，并输出导师姓名和薪水。使用了<code>try-with-resources</code>语法确保资源自动关闭。</p>
<hr>
<p><strong>例2：创建一个AFTER触发器，更新学生总学分</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> credits_earned</span><br><span class="line">AFTER <span class="keyword">UPDATE</span> <span class="keyword">OF</span> takes.grade</span><br><span class="line"><span class="keyword">ON</span> takes</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">NEW</span> <span class="type">ROW</span> <span class="keyword">AS</span> nrow <span class="keyword">OLD</span> <span class="type">ROW</span> <span class="keyword">AS</span> orow</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span> (nrow.grade <span class="operator">&lt;&gt;</span> <span class="string">&#x27;F&#x27;</span> <span class="keyword">AND</span> nrow.grade <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">AND</span> (orow.grade <span class="operator">=</span> <span class="string">&#x27;F&#x27;</span> <span class="keyword">OR</span> orow.grade <span class="keyword">IS</span> <span class="keyword">NULL</span>))</span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span></span><br><span class="line">    <span class="keyword">UPDATE</span> student</span><br><span class="line">    <span class="keyword">SET</span> tot_cred <span class="operator">=</span> tot_cred <span class="operator">+</span></span><br><span class="line">        (<span class="keyword">SELECT</span> credits <span class="keyword">FROM</span> course <span class="keyword">WHERE</span> course.course_id <span class="operator">=</span> nrow.course_id)</span><br><span class="line">    <span class="keyword">WHERE</span> student.id <span class="operator">=</span> nrow.id;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong><br>该触发器在<code>takes</code>关系的<code>grade</code>属性更新后执行。当新成绩不为<code>F</code>且不为空，且原成绩为<code>F</code>或为空时，触发器将相应课程的学分加到学生的总学分<code>tot_cred</code>中，确保学生的学分信息实时更新。</p>
<hr>
<p><strong>例3：使用JDBC执行INSERT操作并处理潜在的SQL注入风险</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO instructor (ID, name, dept_name, salary) VALUES (?, ?, ?, ?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">pstmt.setString(<span class="number">1</span>, <span class="string">&quot;88877&quot;</span>);</span><br><span class="line">pstmt.setString(<span class="number">2</span>, <span class="string">&quot;Perry&quot;</span>);</span><br><span class="line">pstmt.setString(<span class="number">3</span>, <span class="string">&quot;Finance&quot;</span>);</span><br><span class="line">pstmt.setInt(<span class="number">4</span>, <span class="number">125000</span>);</span><br><span class="line">pstmt.executeUpdate();</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong><br>该Java代码使用预编译语句<code>PreparedStatement</code>插入新导师记录，避免了通过字符串拼接可能引发的SQL注入风险。确保了数据的安全性和完整性。</p>
<h3 id="4-4-第三章与第四章中提及的重要图示描述"><a href="#4-4-第三章与第四章中提及的重要图示描述" class="headerlink" title="4.4 第三章与第四章中提及的重要图示描述"></a>4.4 第三章与第四章中提及的重要图示描述</h3><ol>
<li><p><strong>视图的依赖关系图</strong>：</p>
<ul>
<li><strong>说明</strong>：图中展示了视图之间的依赖关系，如视图<code>physics_fall_2017_watson</code>依赖于视图<code>physics_fall_2017</code>，而<code>physics_fall_2017</code>又依赖于基础关系<code>course</code>和<code>section</code>。</li>
<li><strong>关键点</strong>：展示了视图层次结构，强调视图定义的递归展开过程，确保视图定义不是递归的以避免无限循环。</li>
</ul>
</li>
<li><p><strong>触发器执行过程图</strong>：</p>
<ul>
<li><strong>说明</strong>：图示展示了当执行<code>INSERT</code>、<code>UPDATE</code>或<code>DELETE</code>操作时，系统如何创建<code>inserted</code>和<code>deleted</code>临时表，并在触发器中使用这些表进行相应的数据操作。</li>
<li><strong>关键点</strong>：强调触发器在特定事件发生时自动执行，并利用临时表维护数据的前后状态。</li>
</ul>
</li>
<li><p><strong>JDBC操作流程图</strong>：</p>
<ul>
<li><strong>说明</strong>：图中展示了JDBC的典型操作流程，包括加载驱动、建立连接、创建语句、执行查询、处理结果集以及关闭连接的步骤。</li>
<li><strong>关键点</strong>：帮助理解JDBC在Java应用中与数据库交互的整体流程，提高编程实践的准确性。</li>
</ul>
</li>
<li><p><strong>联合查询与子查询示意图</strong>：</p>
<ul>
<li><strong>说明</strong>：图示展示了如何通过<code>JOIN</code>操作和嵌套<code>SELECT</code>子查询在多个关系间进行数据整合。</li>
<li><strong>关键点</strong>：帮助理解复杂查询的结构和执行顺序，增强对多表联结与子查询逻辑的掌握。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="第五章-高级SQL"><a href="#第五章-高级SQL" class="headerlink" title="第五章 高级SQL"></a>第五章 高级SQL</h2><h3 id="5-1-重点"><a href="#5-1-重点" class="headerlink" title="5.1 重点"></a>5.1 重点</h3><ol>
<li><p><strong>SQL与编程语言的集成</strong>：</p>
<ul>
<li>理解如何通过不同的编程语言（如Java、Python、PHP等）访问和操作数据库。</li>
</ul>
</li>
<li><p><strong>JDBC的使用</strong>：</p>
<ul>
<li>掌握Java应用程序中使用JDBC连接数据库、执行SQL语句以及处理结果集的流程。</li>
</ul>
</li>
<li><p><strong>函数与存储过程</strong>：</p>
<ul>
<li>理解数据库中的函数和存储过程的定义与调用，掌握其在业务逻辑封装中的应用。</li>
</ul>
</li>
<li><p><strong>触发器的设计与应用</strong>：</p>
<ul>
<li>学会设计DML触发器（AFTER和INSTEAD OF），并理解其在自动执行副作用操作中的作用。</li>
</ul>
</li>
</ol>
<h3 id="5-2-难点"><a href="#5-2-难点" class="headerlink" title="5.2 难点"></a>5.2 难点</h3><ol>
<li><p><strong>事务管理与连接池</strong>：</p>
<ul>
<li>理解事务的概念，掌握如何在应用程序中正确管理事务，避免数据不一致。</li>
</ul>
</li>
<li><p><strong>安全性问题</strong>：</p>
<ul>
<li>理解SQL注入攻击的原理及防范措施，如使用预编译语句（Prepared Statements）。</li>
</ul>
</li>
<li><p><strong>元数据的使用</strong>：</p>
<ul>
<li>熟悉如何通过JDBC获取数据库及结果集的元数据，以动态处理不同的数据库结构。</li>
</ul>
</li>
</ol>
<h3 id="5-3-实例分析"><a href="#5-3-实例分析" class="headerlink" title="5.3 实例分析"></a>5.3 实例分析</h3><p><strong>例1：JDBC 连接与查询</strong></p>
<p><strong>任务：</strong> 使用JDBC连接到SQL Server数据库，执行查询并处理结果集。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dbURL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:sqlserver://localhost:1433;databaseName=univdb&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;userid&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;passwd&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(dbURL, user, password);</span><br><span class="line">             <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT dept_name, AVG(salary) as avg_salary FROM instructor GROUP BY dept_name&quot;</span>;</span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">deptName</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;dept_name&quot;</span>);</span><br><span class="line">                <span class="type">float</span> <span class="variable">avgSalary</span> <span class="operator">=</span> rs.getFloat(<span class="string">&quot;avg_salary&quot;</span>);</span><br><span class="line">                System.out.println(deptName + <span class="string">&quot; &quot;</span> + avgSalary);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rs.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;SQLException: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>使用<code>DriverManager.getConnection</code>建立连接。</li>
<li>创建<code>Statement</code>对象执行SQL查询。</li>
<li>使用<code>ResultSet</code>处理查询结果。</li>
</ul>
<hr>
<p><strong>例2：使用预编译语句防止SQL注入</strong></p>
<p><strong>任务：</strong> 安全地向<code>instructor</code>表插入数据，防止SQL注入攻击。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecureInsertExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dbURL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:sqlserver://localhost:1433;databaseName=univdb&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;userid&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;passwd&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">insertSQL</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO instructor (ID, name, dept_name, salary) VALUES (?, ?, ?, ?)&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(dbURL, user, password);</span><br><span class="line">             <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(insertSQL)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置参数</span></span><br><span class="line">            pstmt.setString(<span class="number">1</span>, <span class="string">&quot;88877&quot;</span>);</span><br><span class="line">            pstmt.setString(<span class="number">2</span>, <span class="string">&quot;Perry&quot;</span>);</span><br><span class="line">            pstmt.setString(<span class="number">3</span>, <span class="string">&quot;Finance&quot;</span>);</span><br><span class="line">            pstmt.setInt(<span class="number">4</span>, <span class="number">125000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行插入</span></span><br><span class="line">            pstmt.executeUpdate();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 插入另一条记录</span></span><br><span class="line">            pstmt.setString(<span class="number">1</span>, <span class="string">&quot;88878&quot;</span>);</span><br><span class="line">            pstmt.setString(<span class="number">2</span>, <span class="string">&quot;John&quot;</span>);</span><br><span class="line">            pstmt.setString(<span class="number">3</span>, <span class="string">&quot;Marketing&quot;</span>);</span><br><span class="line">            pstmt.setInt(<span class="number">4</span>, <span class="number">110000</span>);</span><br><span class="line">            pstmt.executeUpdate();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;数据插入成功。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;SQLException: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>使用<code>PreparedStatement</code>预编译SQL语句，防止恶意用户通过输入构造SQL注入攻击。</li>
<li>通过<code>set</code>方法动态设置参数值。</li>
</ul>
<hr>
<p><strong>例3：触发器的创建与使用</strong></p>
<p><strong>任务：</strong> 为<code>student</code>表创建一个AFTER INSERT触发器，更新<code>student_sum</code>表中的学生总数。</p>
<p><strong>示例SQL代码：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建student表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">    stu_id <span class="type">INT</span> <span class="keyword">IDENTITY</span>(<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    stu_name <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    stu_gender <span class="type">CHAR</span>(<span class="number">2</span>),</span><br><span class="line">    stu_age <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建student_sum表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student_sum (</span><br><span class="line">    stuCount <span class="type">INT</span> <span class="keyword">DEFAULT</span>(<span class="number">0</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建AFTER INSERT触发器</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trig_insert</span><br><span class="line"><span class="keyword">ON</span> student</span><br><span class="line">AFTER <span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> <span class="variable">@stuNumber</span> <span class="type">INT</span>;</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="variable">@stuNumber</span> <span class="operator">=</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> student;</span><br><span class="line"></span><br><span class="line">    IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student_sum)</span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> student_sum <span class="keyword">VALUES</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">UPDATE</span> student_sum <span class="keyword">SET</span> stuCount <span class="operator">=</span> <span class="variable">@stuNumber</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建删除触发器</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trig_delete</span><br><span class="line"><span class="keyword">ON</span> student</span><br><span class="line">AFTER <span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> stu_id <span class="keyword">AS</span> 已删除的学生编号, stu_name, stu_gender, stu_age</span><br><span class="line">    <span class="keyword">FROM</span> deleted;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建更新触发器</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trig_update</span><br><span class="line"><span class="keyword">ON</span> student</span><br><span class="line">AFTER <span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> <span class="variable">@stuCount</span> <span class="type">INT</span>;</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="variable">@stuCount</span> <span class="operator">=</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> student;</span><br><span class="line">    <span class="keyword">UPDATE</span> student_sum <span class="keyword">SET</span> stuCount <span class="operator">=</span> <span class="variable">@stuCount</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">SELECT</span> stu_id <span class="keyword">AS</span> 更新前学生编号, stu_name <span class="keyword">AS</span> 更新前学生姓名 <span class="keyword">FROM</span> deleted;</span><br><span class="line">    <span class="keyword">SELECT</span> stu_id <span class="keyword">AS</span> 更新后学生编号, stu_name <span class="keyword">AS</span> 更新后学生姓名 <span class="keyword">FROM</span> inserted;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>触发器<code>trig_insert</code>在向<code>student</code>表插入新记录后执行，更新<code>student_sum</code>表中的学生总数。</li>
<li>触发器<code>trig_delete</code>在删除<code>student</code>表中的记录后执行，显示已删除的学生信息。</li>
<li>触发器<code>trig_update</code>在更新<code>student</code>表中的记录后执行，更新<code>student_sum</code>表并显示更新前后的学生信息。</li>
</ul>
<p><strong>注意事项：</strong></p>
<ul>
<li>确保在SQL Server中执行上述SQL语句时，具有相应的权限。</li>
<li>触发器中的<code>deleted</code>和<code>inserted</code>表是SQL Server中特殊的临时表，用于存储被删除和插入的元组。</li>
</ul>
<hr>
<h3 id="4-4-第三章与第四章中提及的重要图示描述-1"><a href="#4-4-第三章与第四章中提及的重要图示描述-1" class="headerlink" title="4.4 第三章与第四章中提及的重要图示描述"></a>4.4 第三章与第四章中提及的重要图示描述</h3><ol>
<li><p><strong>视图的依赖关系图</strong>：</p>
<ul>
<li><strong>说明</strong>：图中展示了视图之间的依赖关系，如视图<code>physics_fall_2017_watson</code>依赖于视图<code>physics_fall_2017</code>，而<code>physics_fall_2017</code>又依赖于基础关系<code>course</code>和<code>section</code>。</li>
<li><strong>关键点</strong>：展示了视图层次结构，强调视图定义的递归展开过程，确保视图定义不是递归的以避免无限循环。</li>
</ul>
</li>
<li><p><strong>触发器执行过程图</strong>：</p>
<ul>
<li><strong>说明</strong>：图示展示了当执行<code>INSERT</code>、<code>UPDATE</code>或<code>DELETE</code>操作时，系统如何创建<code>inserted</code>和<code>deleted</code>临时表，并在触发器中使用这些表进行相应的数据操作。</li>
<li><strong>关键点</strong>：强调触发器在特定事件发生时自动执行，并利用临时表维护数据的前后状态。</li>
</ul>
</li>
<li><p><strong>JDBC操作流程图</strong>：</p>
<ul>
<li><strong>说明</strong>：图中展示了JDBC的典型操作流程，包括加载驱动、建立连接、创建语句、执行查询、处理结果集以及关闭连接的步骤。</li>
<li><strong>关键点</strong>：帮助理解JDBC在Java应用中与数据库交互的整体流程，提高编程实践的准确性。</li>
</ul>
</li>
<li><p><strong>联合查询与子查询示意图</strong>：</p>
<ul>
<li><strong>说明</strong>：图示展示了如何通过<code>JOIN</code>操作和嵌套<code>SELECT</code>子查询在多个关系间进行数据整合。</li>
<li><strong>关键点</strong>：帮助理解复杂查询的结构和执行顺序，增强对多表联结与子查询逻辑的掌握。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="第六章-基于E-R模型的数据库设计"><a href="#第六章-基于E-R模型的数据库设计" class="headerlink" title="第六章 基于E-R模型的数据库设计"></a>第六章 基于E-R模型的数据库设计</h2><h3 id="6-1-重点"><a href="#6-1-重点" class="headerlink" title="6.1 重点"></a>6.1 重点</h3><ol>
<li><strong>实体-关系模型（E-R模型）</strong>：理解实体、属性、关系及其在数据库设计中的应用。</li>
<li><strong>属性类型</strong>：掌握简单属性、复合属性、多值属性和派生属性的区别及其表示方法。</li>
<li><strong>关系的基数约束</strong>：熟悉一对一、一对多、多对多等关系的特点及其在E-R图中的表示。</li>
<li><strong>主键</strong>：了解实体集和关系集的主键选择及其在唯一标识实体中的作用。</li>
<li><strong>弱实体集与标识关系</strong>：掌握弱实体集的定义及其与标识实体集之间的关系。</li>
</ol>
<h3 id="6-2-难点"><a href="#6-2-难点" class="headerlink" title="6.2 难点"></a>6.2 难点</h3><ol>
<li><strong>E-R图到关系模式的转换</strong>：如何准确地将E-R图中的各个元素映射到关系数据库的模式中。</li>
<li><strong>处理多值属性</strong>：理解如何通过分离关系来消除多值属性带来的冗余。</li>
<li><strong>聚合与泛化&#x2F;特化</strong>：掌握在E-R模型中表示复杂关系和层次结构的方法。</li>
<li><strong>设计规范化</strong>：了解如何通过规范化过程消除冗余和避免更新异常。</li>
<li><strong>依赖约束的保持与无损分解</strong>：理解在关系模式分解过程中，如何保持功能依赖以及确保分解的无损性。</li>
</ol>
<h3 id="6-3-主要内容总结"><a href="#6-3-主要内容总结" class="headerlink" title="6.3 主要内容总结"></a>6.3 主要内容总结</h3><h4 id="1-数据库设计过程概述"><a href="#1-数据库设计过程概述" class="headerlink" title="1. 数据库设计过程概述"></a>1. 数据库设计过程概述</h4><p>数据库设计过程通常包括以下几个阶段：</p>
<ul>
<li><strong>需求分析</strong>：全面描述未来数据库用户的需求。</li>
<li><strong>概念设计</strong>：选择合适的数据模型（通常是E-R模型）并将需求转化为数据库的概念模式。</li>
<li><strong>逻辑设计</strong>：将概念模式转换为特定的数据模型（如关系模型）的逻辑模式。</li>
<li><strong>物理设计</strong>：决定数据库的物理存储结构和优化性能。</li>
</ul>
<h4 id="2-实体-关系模型（E-R模型）"><a href="#2-实体-关系模型（E-R模型）" class="headerlink" title="2. 实体-关系模型（E-R模型）"></a>2. 实体-关系模型（E-R模型）</h4><p>E-R模型用于概念化地描述数据库的结构，主要包括以下三个基本概念：</p>
<ul>
<li><strong>实体集（Entity Set）</strong>：表示具有相同属性的一类对象，如“学生”、“教师”。</li>
<li><strong>属性（Attribute）</strong>：描述实体集特征的字段，如“姓名”、“学号”。属性可以分为简单属性、复合属性、多值属性和派生属性。</li>
<li><strong>关系集（Relationship Set）</strong>：表示实体集之间的关联，如“学生选课”关系。</li>
</ul>
<h5 id="2-1-实体集与属性"><a href="#2-1-实体集与属性" class="headerlink" title="2.1 实体集与属性"></a>2.1 实体集与属性</h5><ul>
<li><strong>实体</strong>：可以独立存在并具有唯一标识的对象。</li>
<li><strong>主键（Primary Key）</strong>：用于唯一标识实体集中的每一个实体，如“学生”的学号。</li>
</ul>
<h5 id="2-2-属性类型"><a href="#2-2-属性类型" class="headerlink" title="2.2 属性类型"></a>2.2 属性类型</h5><ul>
<li><strong>简单属性</strong>：不可再分的属性，如“年龄”。</li>
<li><strong>复合属性</strong>：可以分解为更小的子属性，如“姓名”可以分为“名字”和“姓氏”。</li>
<li><strong>多值属性</strong>：一个实体可以有多个此类属性的值，如“电话号码”。</li>
<li><strong>派生属性</strong>：可以由其他属性计算得到，如“年龄”可以由“出生日期”计算得出。</li>
</ul>
<h5 id="2-3-关系集与基数约束"><a href="#2-3-关系集与基数约束" class="headerlink" title="2.3 关系集与基数约束"></a>2.3 关系集与基数约束</h5><ul>
<li><strong>一对一（1:1）关系</strong>：一个实体集中的一个实体只与另一个实体集中的一个实体相关联。</li>
<li><strong>一对多（1:N）关系</strong>：一个实体集中的一个实体可以与另一个实体集中的多个实体相关联，但反之不成立。</li>
<li><strong>多对多（M:N）关系</strong>：两个实体集中的多个实体可以相互关联。</li>
</ul>
<h5 id="2-4-弱实体集与标识关系"><a href="#2-4-弱实体集与标识关系" class="headerlink" title="2.4 弱实体集与标识关系"></a>2.4 弱实体集与标识关系</h5><ul>
<li><strong>弱实体集（Weak Entity Set）</strong>：其存在依赖于另一个强实体集，通过标识关系进行标识。例如，“选课”实体集可能依赖于“学生”和“课程”实体集。</li>
<li><strong>标识关系（Identifying Relationship）</strong>：连接弱实体集与其标识强实体集的关系。</li>
</ul>
<h4 id="3-从E-R图到关系模式的转换"><a href="#3-从E-R图到关系模式的转换" class="headerlink" title="3. 从E-R图到关系模式的转换"></a>3. 从E-R图到关系模式的转换</h4><p>将E-R图转换为关系模式时，需遵循以下步骤：</p>
<ol>
<li><strong>实体集转换</strong>：每个强实体集转换为一个关系，属性成为关系的字段，主键作为关系主键。</li>
<li><strong>弱实体集转换</strong>：将弱实体集转换为关系，包含其标识实体集的主键作为外键，并结合自身的部分主键。</li>
<li><strong>关系集转换</strong>：<ul>
<li><strong>多对多关系</strong>：创建一个新的关系，包含两个参与实体集的主键作为外键。</li>
<li><strong>一对多或多对一关系</strong>：在“多”侧的关系中添加“一”侧的外键。</li>
<li><strong>一对一关系</strong>：可以选择任一侧添加对方的外键。</li>
</ul>
</li>
</ol>
<h5 id="3-1-处理多值属性"><a href="#3-1-处理多值属性" class="headerlink" title="3.1 处理多值属性"></a>3.1 处理多值属性</h5><p>多值属性通过创建新的关系来消除冗余。例如，“教师”的“电话号码”可以通过一个单独的关系 <code>教师电话（教师ID，电话）</code> 来表示。</p>
<h5 id="3-2-复合属性的展开"><a href="#3-2-复合属性的展开" class="headerlink" title="3.2 复合属性的展开"></a>3.2 复合属性的展开</h5><p>复合属性被拆解为更小的简单属性。例如，“地址”可以拆分为“街道”、“城市”、“州”、“邮编”。</p>
<h4 id="4-扩展的E-R特性"><a href="#4-扩展的E-R特性" class="headerlink" title="4. 扩展的E-R特性"></a>4. 扩展的E-R特性</h4><h5 id="4-1-泛化与特化（Generalization-Specialization）"><a href="#4-1-泛化与特化（Generalization-Specialization）" class="headerlink" title="4.1 泛化与特化（Generalization&#x2F;Specialization）"></a>4.1 泛化与特化（Generalization&#x2F;Specialization）</h5><ul>
<li><strong>泛化</strong>：将多个具体实体集抽象为一个通用的高层实体集。</li>
<li><strong>特化</strong>：将一个通用实体集细分为多个具体的低层实体集。</li>
</ul>
<h5 id="4-2-聚合（Aggregation）"><a href="#4-2-聚合（Aggregation）" class="headerlink" title="4.2 聚合（Aggregation）"></a>4.2 聚合（Aggregation）</h5><p>聚合用于表示关系集之间的关系，将一个或多个关系集视为一个整体来参与其他关系集。</p>
<h4 id="5-数据库设计中的常见问题与解决方案"><a href="#5-数据库设计中的常见问题与解决方案" class="headerlink" title="5. 数据库设计中的常见问题与解决方案"></a>5. 数据库设计中的常见问题与解决方案</h4><h5 id="5-1-冗余与更新异常"><a href="#5-1-冗余与更新异常" class="headerlink" title="5.1 冗余与更新异常"></a>5.1 冗余与更新异常</h5><ul>
<li><strong>冗余</strong>：信息重复存储，可能导致数据不一致。</li>
<li><strong>更新异常</strong>：如插入、删除、修改操作可能引发数据不一致。</li>
</ul>
<h5 id="5-2-规范化"><a href="#5-2-规范化" class="headerlink" title="5.2 规范化"></a>5.2 规范化</h5><p>通过规范化过程（如达到第三范式、BCNF等），消除冗余，避免更新异常。</p>
<h4 id="6-替代符号表示"><a href="#6-替代符号表示" class="headerlink" title="6. 替代符号表示"></a>6. 替代符号表示</h4><p>不同的E-R图符号如Chen符号、Crow’s Feet符号以及UML类图，有助于不同场景下的数据库设计和表示。</p>
<h3 id="6-4-实例分析"><a href="#6-4-实例分析" class="headerlink" title="6.4 实例分析"></a>6.4 实例分析</h3><h4 id="实例1：大学信息维护"><a href="#实例1：大学信息维护" class="headerlink" title="实例1：大学信息维护"></a>实例1：大学信息维护</h4><h5 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h5><p>一所大学需要维护以下信息：</p>
<ul>
<li>各个系，包括名称、系主任和地址。</li>
<li>各个班级，包括班级编号、名字和年级。</li>
<li>各个教师，包括教师编号、姓名和年龄。</li>
<li>一个系有多个班级，但班级只属于一个系。</li>
<li>一个系聘请某些教师，一个教师被一个系聘请。</li>
<li>教师最多是一个班的班主任；任何班级都必须有一个班主任。</li>
</ul>
<h5 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h5><ol>
<li><p><strong>实体集定义</strong></p>
<ul>
<li><strong>系（Department）</strong>：属性包括 <code>dept_name</code>（主键）、<code>head</code>、<code>address</code>。</li>
<li><strong>班级（Class）</strong>：属性包括 <code>class_id</code>（主键）、<code>name</code>、<code>grade</code>。</li>
<li><strong>教师（Teacher）</strong>：属性包括 <code>teacher_id</code>（主键）、<code>name</code>、<code>age</code>。</li>
</ul>
</li>
<li><p><strong>关系集定义</strong></p>
<ul>
<li><strong>隶属（Affiliation）</strong>：一对多关系，连接 <code>Department</code> 和 <code>Class</code>。一个系可有多个班级，但班级只能属于一个系。</li>
<li><strong>聘请（Employment）</strong>：一对多关系，连接 <code>Department</code> 和 <code>Teacher</code>。一个系聘请多个教师，一个教师被一个系聘请。</li>
<li><strong>班主任（Advisor）</strong>：一对一关系，连接 <code>Teacher</code> 和 <code>Class</code>。一个教师最多担任一个班主任，一个班级必须有一个班主任。</li>
</ul>
</li>
<li><p><strong>关系模式转换</strong></p>
<ul>
<li><strong>Department</strong>(<code>dept_name</code> [PK], <code>head</code>, <code>address</code>)</li>
<li><strong>Class</strong>(<code>class_id</code> [PK], <code>name</code>, <code>grade</code>, <code>dept_name</code> [FK])</li>
<li><strong>Teacher</strong>(<code>teacher_id</code> [PK], <code>name</code>, <code>age</code>, <code>dept_name</code> [FK])</li>
<li><strong>Advisor</strong>(<code>teacher_id</code> [PK, FK], <code>class_id</code> [FK])</li>
</ul>
</li>
<li><p><strong>SQL语句示例</strong><br>创建上述关系模式的SQL Server语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Department (</span><br><span class="line">    dept_name <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    head <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    address <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Teacher (</span><br><span class="line">    teacher_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    age <span class="type">INT</span>,</span><br><span class="line">    dept_name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (dept_name) <span class="keyword">REFERENCES</span> Department(dept_name)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Class (</span><br><span class="line">    class_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    grade <span class="type">INT</span>,</span><br><span class="line">    dept_name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (dept_name) <span class="keyword">REFERENCES</span> Department(dept_name)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Advisor (</span><br><span class="line">    teacher_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    class_id <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (teacher_id) <span class="keyword">REFERENCES</span> Teacher(teacher_id),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (class_id) <span class="keyword">REFERENCES</span> Class(class_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="重点难点解析"><a href="#重点难点解析" class="headerlink" title="重点难点解析"></a>重点难点解析</h5><ul>
<li><strong>班主任关系的处理</strong>：采用一对一关系，需要在 <code>Advisor</code> 表中将 <code>teacher_id</code> 和 <code>class_id</code> 设置为外键，并分别引用 <code>Teacher</code> 和 <code>Class</code> 表。</li>
<li><strong>避免冗余</strong>：<code>Class</code> 和 <code>Teacher</code> 表中的 <code>dept_name</code> 作为外键避免了信息重复存储。</li>
</ul>
<h4 id="实例2：处理多值属性"><a href="#实例2：处理多值属性" class="headerlink" title="实例2：处理多值属性"></a>实例2：处理多值属性</h4><h5 id="需求描述-1"><a href="#需求描述-1" class="headerlink" title="需求描述"></a>需求描述</h5><p>记录教师的多个电话号码和多个子女姓名。</p>
<h5 id="设计过程-1"><a href="#设计过程-1" class="headerlink" title="设计过程"></a>设计过程</h5><p>由于多值属性会导致数据冗余，需通过创建新的关系来处理。</p>
<ol>
<li><p><strong>实体集定义</strong></p>
<ul>
<li><strong>教师（Teacher）</strong>：属性包括 <code>teacher_id</code>（主键）、<code>name</code>、<code>age</code>。</li>
</ul>
</li>
<li><p><strong>多值属性的处理</strong></p>
<ul>
<li><strong>教师电话（Teacher_Phone）</strong>：<code>teacher_id</code>（外键）、<code>phone_number</code>。</li>
<li><strong>教师子女（Teacher_Child）</strong>：<code>teacher_id</code>（外键）、<code>child_name</code>。</li>
</ul>
</li>
<li><p><strong>关系模式转换</strong></p>
<ul>
<li><strong>Teacher</strong>(<code>teacher_id</code> [PK], <code>name</code>, <code>age</code>)</li>
<li><strong>Teacher_Phone</strong>(<code>teacher_id</code> [FK], <code>phone_number</code>)</li>
<li><strong>Teacher_Child</strong>(<code>teacher_id</code> [FK], <code>child_name</code>)</li>
</ul>
</li>
<li><p><strong>SQL语句示例</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Teacher (</span><br><span class="line">    teacher_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    age <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Teacher_Phone (</span><br><span class="line">    teacher_id <span class="type">INT</span>,</span><br><span class="line">    phone_number <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (teacher_id) <span class="keyword">REFERENCES</span> Teacher(teacher_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Teacher_Child (</span><br><span class="line">    teacher_id <span class="type">INT</span>,</span><br><span class="line">    child_name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (teacher_id) <span class="keyword">REFERENCES</span> Teacher(teacher_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="重点难点解析-1"><a href="#重点难点解析-1" class="headerlink" title="重点难点解析"></a>重点难点解析</h5><ul>
<li><strong>多值属性的分离</strong>：通过创建 <code>Teacher_Phone</code> 和 <code>Teacher_Child</code> 表，将教师的多个电话号码和子女姓名分别存储，避免冗余。</li>
<li><strong>保持关系的完整性</strong>：使用外键引用确保每个电话号码和子女姓名都关联到一个有效的教师。</li>
</ul>
<h3 id="6-5-图表与图示"><a href="#6-5-图表与图示" class="headerlink" title="6.5 图表与图示"></a>6.5 图表与图示</h3><h4 id="1-E-R图的图形表示"><a href="#1-E-R图的图形表示" class="headerlink" title="1. E-R图的图形表示"></a>1. E-R图的图形表示</h4><h5 id="实体集与属性"><a href="#实体集与属性" class="headerlink" title="实体集与属性"></a>实体集与属性</h5><ul>
<li><strong>实体集</strong>用矩形表示，内部列出其属性，主键属性下划线表示。</li>
<li><strong>复合属性</strong>用带有分支的椭圆表示，分支连接到子属性。</li>
<li><strong>多值属性</strong>用双椭圆表示。</li>
</ul>
<h5 id="关系集与基数约束"><a href="#关系集与基数约束" class="headerlink" title="关系集与基数约束"></a>关系集与基数约束</h5><ul>
<li><strong>关系集</strong>用菱形表示，连接参与的实体集。</li>
<li><strong>一对一</strong>关系在E-R图中通过双向箭头表示。</li>
<li><strong>一对多</strong>关系通过一端的单向箭头和多端的多向标记（如叉形脚）表示。</li>
<li><strong>多对多</strong>关系通过双向箭头连线表示。</li>
</ul>
<h5 id="弱实体集与标识关系"><a href="#弱实体集与标识关系" class="headerlink" title="弱实体集与标识关系"></a>弱实体集与标识关系</h5><ul>
<li><strong>弱实体集</strong>用双矩形表示，属性用双椭圆表示。</li>
<li><strong>标识关系集</strong>用双菱形表示，连接弱实体集与强实体集。</li>
</ul>
<h4 id="2-从E-R图到关系模式的转换示意"><a href="#2-从E-R图到关系模式的转换示意" class="headerlink" title="2. 从E-R图到关系模式的转换示意"></a>2. 从E-R图到关系模式的转换示意</h4><p><strong>原始E-R图示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Department]---&lt;Affiliation&gt;---[Class]</span><br><span class="line">[Department]---&lt;Employment&gt;---[Teacher]</span><br><span class="line">[Teacher]---&lt;Advisor&gt;---[Class]</span><br></pre></td></tr></table></figure>

<p><strong>转换后的关系模式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. Department(dept_name [PK], head, address)</span><br><span class="line">2. Class(class_id [PK], name, grade, dept_name [FK])</span><br><span class="line">3. Teacher(teacher_id [PK], name, age, dept_name [FK])</span><br><span class="line">4. Advisor(teacher_id [PK, FK], class_id [FK])</span><br></pre></td></tr></table></figure>

<h3 id="6-6-总结"><a href="#6-6-总结" class="headerlink" title="6.6 总结"></a>6.6 总结</h3><p>数据库设计是一个系统性工程，需要从需求分析开始，经过概念设计、逻辑设计到物理设计的多个阶段。在E-R模型的帮助下，可以清晰地描述实体、属性和它们之间的关系。通过将E-R图转换为关系模式，并应用规范化理论，可以有效地消除冗余、避免更新异常，提升数据库的整体质量。</p>
<h3 id="6-7-建议"><a href="#6-7-建议" class="headerlink" title="6.7 建议"></a>6.7 建议</h3><ol>
<li><strong>深入理解E-R模型</strong>：通过实践绘制E-R图，掌握不同关系的表示方法。</li>
<li><strong>多练习E-R图到关系模式的转换</strong>：理解各种关系的映射规则，特别是处理多值属性和弱实体集时的细节。</li>
<li><strong>掌握规范化理论</strong>：学习不同范式的定义及其目的，应用规范化过程优化数据库设计。</li>
<li><strong>使用专业工具辅助设计</strong>：利用数据库设计工具（如ERwin、PowerDesigner）绘制E-R图，提高设计效率和准确性。</li>
</ol>
<hr>
<h2 id="第七章-标准化"><a href="#第七章-标准化" class="headerlink" title="第七章 标准化"></a>第七章 标准化</h2><h3 id="7-1-关系数据库设计中的问题"><a href="#7-1-关系数据库设计中的问题" class="headerlink" title="7.1 关系数据库设计中的问题"></a>7.1 关系数据库设计中的问题</h3><p><strong>重点难点：</strong></p>
<ul>
<li><strong>重点：</strong> 理解关系数据库设计中的数据冗余和异常问题。</li>
<li><strong>难点：</strong> 识别不同类型的异常（更新异常、插入异常、删除异常）及其产生原因。</li>
</ul>
<p><strong>内容摘要：</strong></p>
<ul>
<li><strong>数据冗余：</strong> 通过关系的自然连接（如<code>instructor</code>和<code>department</code>的自然连接<code>in_dep</code>），可能导致信息的重复存储。</li>
<li><strong>异常问题：</strong><ul>
<li><strong>更新异常：</strong> 部门经理变更时需要更新多个元组，容易出错。</li>
<li><strong>插入异常：</strong> 新部门无员工时，无法插入该部门的信息。</li>
<li><strong>删除异常：</strong> 删除部门所有员工后，失去部门经理的信息。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="7-2-不良数据依赖与关系分解"><a href="#7-2-不良数据依赖与关系分解" class="headerlink" title="7.2 不良数据依赖与关系分解"></a>7.2 不良数据依赖与关系分解</h3><p><strong>重点难点：</strong></p>
<ul>
<li><strong>重点：</strong> 理解函数依赖的概念及其在关系数据库设计中的应用。</li>
<li><strong>难点：</strong> 辨别“好”与“不好”的函数依赖，以及进行关系分解以消除不良依赖。</li>
</ul>
<p><strong>内容摘要：</strong></p>
<ul>
<li><strong>函数依赖（Functional Dependency, FD）：</strong> 若属性集α决定属性集β，即<code>α → β</code>，则在任何合法实例中，若两个元组在α上相同，则在β上也相同。</li>
<li><strong>不良函数依赖：</strong> 例如<code>branch → manager</code>，当<code>branch</code>不是超级键时，会导致数据重复和异常。</li>
<li><strong>关系分解：</strong> 将“坏”关系分解为多个“好”关系以消除不良依赖。需要确保分解是无损连接（lossless-join）并尽可能保持依赖性（dependency preserving）。</li>
</ul>
<p><strong>实例分析：</strong></p>
<ul>
<li><p><strong>关系 <code>worker(name, branch, manager)</code> 存在的函数依赖：</strong></p>
<ul>
<li><code>name → branch</code></li>
<li><code>branch → manager</code></li>
<li><code>name → manager</code></li>
</ul>
</li>
<li><p><strong>问题：</strong> <code>branch → manager</code> 不是良好的依赖，因为<code>branch</code>不是超级键，导致信息冗余。</p>
</li>
<li><p><strong>分解方案：</strong></p>
<ul>
<li><code>worker1(name, branch)</code></li>
<li><code>branch(branch, manager)</code></li>
</ul>
<p>这种分解消除了冗余，避免了更新、插入和删除异常。</p>
</li>
</ul>
<hr>
<h3 id="7-3-正规化与范式"><a href="#7-3-正规化与范式" class="headerlink" title="7.3 正规化与范式"></a>7.3 正规化与范式</h3><p><strong>重点难点：</strong></p>
<ul>
<li><strong>重点：</strong> 理解不同范式（第一范式1NF，第二范式2NF，第三范式3NF，BCNF，第四范式4NF）的定义及其重要性。</li>
<li><strong>难点：</strong> 识别关系是否满足特定范式，以及进行规范化分解。</li>
</ul>
<p><strong>内容摘要：</strong></p>
<ul>
<li><strong>第一范式（1NF）：</strong> 所有属性值必须是原子性的，不能再分。</li>
<li><strong>第二范式（2NF）：</strong> 满足1NF且每个非主属性完全依赖于候选键，消除部分依赖。</li>
<li><strong>第三范式（3NF）：</strong> 满足2NF且没有传递依赖，消除传递依赖。</li>
<li><strong>BCNF（Boyce-Codd Normal Form）：</strong> 满足3NF且每个决定因素都是超级键。</li>
<li><strong>第四范式（4NF）：</strong> 满足BCNF且没有多值依赖。</li>
</ul>
<p><strong>实例分析：</strong></p>
<ul>
<li><p><strong>关系 <code>student(course_id, title, dept_name, credits, sec_id, semester, year, building, room_number, capacity, time_slot_id)</code> 存在的函数依赖：</strong></p>
<ul>
<li><code>course_id → title, dept_name, credits</code></li>
<li><code>building, room_number → capacity</code></li>
<li><code>course_id, sec_id, semester, year → building, room_number, time_slot_id</code></li>
</ul>
</li>
<li><p><strong>分解至BCNF：</strong></p>
<ul>
<li><code>course(course_id, title, dept_name, credits)</code></li>
<li><code>classroom(building, room_number, capacity)</code></li>
<li><code>section(course_id, sec_id, semester, year, building, room_number, time_slot_id)</code></li>
</ul>
<p>各个分解后的关系满足BCNF，消除了函数依赖导致的问题。</p>
</li>
</ul>
<hr>
<h3 id="7-4-规范化算法与依赖闭包"><a href="#7-4-规范化算法与依赖闭包" class="headerlink" title="7.4 规范化算法与依赖闭包"></a>7.4 规范化算法与依赖闭包</h3><p><strong>重点难点：</strong></p>
<ul>
<li><strong>重点：</strong> 掌握属性闭包（Attribute Closure）及其在确定函数依赖和候选键中的应用。</li>
<li><strong>难点：</strong> 计算函数依赖的闭包，理解规范化过程中的依赖保留和无损连接。</li>
</ul>
<p><strong>内容摘要：</strong></p>
<ul>
<li><strong>属性闭包（α+）：</strong> 在给定一组函数依赖F的情况下，属性集α的闭包是由α决定的所有属性的集合。</li>
<li><strong>候选键：</strong> 最小的超级键，能够唯一标识关系中的元组。</li>
<li><strong>规范化算法：</strong><ul>
<li><strong>算法步骤：</strong><ol>
<li>确定所有函数依赖的闭包。</li>
<li>分解关系，确保每个分解后的关系满足目标范式（如3NF、BCNF）。</li>
<li>确保分解是无损连接，并尽可能保留函数依赖。</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><strong>实例分析：</strong></p>
<ul>
<li><p><strong>计算属性闭包：</strong></p>
<ul>
<li><p>关系 <code>R(A, B, C, G, H, I)</code></p>
</li>
<li><p>函数依赖集 <code>F = &#123;A → B, A → C, CG → H, CG → I, B → H&#125;</code></p>
</li>
<li><p>计算 <code>(AG)+</code>：</p>
<ol>
<li>初始：<code>AG</code></li>
<li><code>A → B</code> 和 <code>A → C</code>，得到 <code>AGBC</code></li>
<li><code>CG → H</code> 和 <code>CG → I</code>，得到 <code>AGBCHI</code></li>
</ol>
<ul>
<li><strong>结论：</strong> <code>(AG)+</code> 包含所有属性，因此<code>AG</code>是超级键。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="7-5-依赖与范式的深入理解"><a href="#7-5-依赖与范式的深入理解" class="headerlink" title="7.5 依赖与范式的深入理解"></a>7.5 依赖与范式的深入理解</h3><p><strong>重点难点：</strong></p>
<ul>
<li><strong>重点：</strong> 了解函数依赖的规范形式（如规范覆盖Canonical Cover），以及在规范化过程中的应用。</li>
<li><strong>难点：</strong> 理解并应用规范覆盖的简化规则，进行关系的规范化分解。</li>
</ul>
<p><strong>内容摘要：</strong></p>
<ul>
<li><p><strong>规范覆盖（Canonical Cover）：</strong> 函数依赖集的简化形式，消除冗余和多余的属性。</p>
</li>
<li><p><strong>规范覆盖的计算步骤：</strong></p>
<ol>
<li>分解右侧多个属性的函数依赖为单属性依赖。</li>
<li>消除左侧多余的属性。</li>
<li>合并具有相同左侧的函数依赖。</li>
</ol>
</li>
<li><p><strong>依赖保留（Dependency Preservation）：</strong> 分解后的关系能够保留原来的所有函数依赖，便于在不进行连接操作的情况下进行依赖的验证。</p>
</li>
</ul>
<p><strong>实例分析：</strong></p>
<ul>
<li><p><strong>计算规范覆盖：</strong></p>
<ul>
<li><p>关系 <code>R(A, B, C)</code></p>
</li>
<li><p>函数依赖集 <code>F = &#123;A → BC, B → C, A → B, AB → C&#125;</code></p>
</li>
<li><p>步骤：</p>
<ol>
<li>合并相同左侧的依赖：<code>A → BC</code> 和 <code>A → B</code> 简化为 <code>A → BC</code></li>
<li>删除<code>AB → C</code>，因为已由<code>A → B</code>和<code>B → C</code>通过传递性推导出。</li>
</ol>
<ul>
<li><strong>规范覆盖：</strong> <code>Fc = &#123;A → B, B → C&#125;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="7-6-无损连接与依赖保留的算法"><a href="#7-6-无损连接与依赖保留的算法" class="headerlink" title="7.6 无损连接与依赖保留的算法"></a>7.6 无损连接与依赖保留的算法</h3><p><strong>重点难点：</strong></p>
<ul>
<li><strong>重点：</strong> 掌握无损连接分解的判定条件及依赖是否保留的算法。</li>
<li><strong>难点：</strong> 理解并应用算法判断分解是否无损连接和依赖保留。</li>
</ul>
<p><strong>内容摘要：</strong></p>
<ul>
<li><p><strong>无损连接分解（Lossless-Join Decomposition）：</strong> 分解后通过自然连接能够恢复原始关系，不丢失信息。</p>
<ul>
<li><strong>判定条件：</strong> 当分解的关系<code>R1</code>和<code>R2</code>的交集<code>R1 ∩ R2</code>是<code>R1</code>或<code>R2</code>的超级键时，分解是无损的。</li>
</ul>
</li>
<li><p><strong>依赖保留判定：</strong></p>
<ul>
<li>通过检查分解后的所有关系的函数依赖集的并集是否能够推导出原关系的所有函数依赖。</li>
</ul>
</li>
</ul>
<p><strong>实例分析：</strong></p>
<ul>
<li><p><strong>无损连接分解：</strong></p>
<ul>
<li>关系 <code>R(A, B, C)</code></li>
<li>分解为 <code>R1(A, B)</code> 和 <code>R2(B, C)</code></li>
<li>交集<code>R1 ∩ R2 = &#123;B&#125;</code>，且<code>B → C</code>，因此分解无损。</li>
</ul>
</li>
<li><p><strong>依赖保留判定：</strong></p>
<ul>
<li>分解后，<code>R1</code>包含<code>A → B</code>，<code>R2</code>包含<code>B → C</code>，两者的并集等于规范覆盖<code>Fc = &#123;A → B, B → C&#125;</code>，因此依赖保留。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="7-7-多值依赖与第四范式（4NF）"><a href="#7-7-多值依赖与第四范式（4NF）" class="headerlink" title="7.7 多值依赖与第四范式（4NF）"></a>7.7 多值依赖与第四范式（4NF）</h3><p><strong>重点难点：</strong></p>
<ul>
<li><strong>重点：</strong> 理解多值依赖（Multivalued Dependency）的概念及其在规范化中的作用。</li>
<li><strong>难点：</strong> 识别多值依赖并进行符合第四范式的分解。</li>
</ul>
<p><strong>内容摘要：</strong></p>
<ul>
<li><strong>多值依赖（Multivalued Dependency, MVD）：</strong> 若属性集α决定属性集β，且β与其他非相关属性独立，记作<code>α →→ β</code>。</li>
<li><strong>第四范式（4NF）：</strong> 满足BCNF，且不存在任何非平凡的多值依赖，即每个多值依赖的决定因素都是超级键。</li>
<li><strong>多值依赖的分解：</strong> 将关系分解为多个关系，每个关系消除一个多值依赖，确保分解后的关系在4NF。</li>
</ul>
<p><strong>实例分析：</strong></p>
<ul>
<li><p><strong>关系 <code>inst_info(ID, child_name, phone_number)</code> 存在的多值依赖：</strong></p>
<ul>
<li><code>ID →→ child_name</code></li>
<li><code>ID →→ phone_number</code></li>
</ul>
</li>
<li><p><strong>分解为：</strong></p>
<ul>
<li><code>inst_child(ID, child_name)</code></li>
<li><code>inst_phone(ID, phone_number)</code></li>
</ul>
<p>这样分解后的关系均满足4NF，消除了多值依赖引起的冗余。</p>
</li>
</ul>
<hr>
<h3 id="7-8-规范化注意事项与高级范式"><a href="#7-8-规范化注意事项与高级范式" class="headerlink" title="7.8 规范化注意事项与高级范式"></a>7.8 规范化注意事项与高级范式</h3><p><strong>重点难点：</strong></p>
<ul>
<li><strong>重点：</strong> 理解更高级范式（如第五范式PJNF）及其在特定情况下的应用。</li>
<li><strong>难点：</strong> 处理复杂的多值依赖和连接依赖，理解规范化与性能优化之间的权衡。</li>
</ul>
<p><strong>内容摘要：</strong></p>
<ul>
<li><strong>第五范式（PJNF）：</strong> 在多值依赖基础上，进一步消除连接依赖，确保关系满足所有可能的投影-连接条件。</li>
<li><strong>规范化的实际应用：</strong><ul>
<li>在实际设计中，常常在BCNF和3NF之间权衡，考虑依赖保留和性能。</li>
<li>对于复杂依赖，通常采用4NF或更高级范式以消除冗余。</li>
</ul>
</li>
</ul>
<p><strong>实例分析：</strong></p>
<ul>
<li><strong>关系 <code>dept_advisor(s_ID, i_ID, dept_name)</code></strong><ul>
<li>函数依赖集 <code>F = &#123;i_ID → dept_name, s_ID, dept_name → i_ID&#125;</code></li>
<li>分解后无法同时满足BCNF和依赖保留，需在应用中权衡选择。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="7-9-综合实例与规范化总结"><a href="#7-9-综合实例与规范化总结" class="headerlink" title="7.9 综合实例与规范化总结"></a>7.9 综合实例与规范化总结</h3><p><strong>重点难点：</strong></p>
<ul>
<li><strong>重点：</strong> 综合运用所学知识进行实际关系的规范化。</li>
<li><strong>难点：</strong> 在实际应用中识别和解决复杂的函数依赖和多值依赖问题，确保分解的正确性（无损和依赖保留）。</li>
</ul>
<p><strong>内容摘要：</strong></p>
<ul>
<li><p><strong>规范化的目标：</strong></p>
<ul>
<li><strong>无损连接（Lossless-Join）：</strong> 确保分解后可以通过连接恢复原始关系。</li>
<li><strong>依赖保留（Dependency Preservation）：</strong> 确保所有原始函数依赖可以在分解后的关系中得到验证。</li>
</ul>
</li>
<li><p><strong>规范化过程：</strong></p>
<ol>
<li>确定所有函数依赖及多值依赖。</li>
<li>按照范式规则进行分解。</li>
<li>验证分解是否满足无损连接和依赖保留。</li>
</ol>
</li>
</ul>
<p><strong>实例分析：</strong></p>
<ul>
<li><p><strong>关系 <code>cust_banker_branch(customer_id, employee_id, branch_name, type)</code></strong></p>
<ul>
<li>规范覆盖 <code>Fc = &#123;customer_id, employee_id → type, employee_id → branch_name, customer_id, branch_name → employee_id&#125;</code></li>
<li>分解为：<ul>
<li><code>(customer_id, employee_id, type)</code></li>
<li><code>(employee_id, branch_name)</code></li>
<li><code>(customer_id, branch_name, employee_id)</code></li>
</ul>
</li>
<li>删除子集关系，最终得到：<ul>
<li><code>(customer_id, employee_id, type)</code></li>
<li><code>(customer_id, branch_name, employee_id)</code></li>
</ul>
</li>
</ul>
<p>这样的分解满足3NF，保持了无损连接和依赖保留。</p>
</li>
</ul>
<hr>
<h3 id="7-10-多值依赖与进一步规范化（7-117-7-140）"><a href="#7-10-多值依赖与进一步规范化（7-117-7-140）" class="headerlink" title="7.10 多值依赖与进一步规范化（7.117 - 7.140）"></a>7.10 多值依赖与进一步规范化（7.117 - 7.140）</h3><p><strong>重点难点：</strong></p>
<ul>
<li><strong>重点：</strong> 深入理解多值依赖在规范化过程中的应用，特别是第四范式（4NF）。</li>
<li><strong>难点：</strong> 处理属性间复杂的多值依赖，确保分解后的关系结构合理且无冗余。</li>
</ul>
<p><strong>内容摘要：</strong></p>
<ul>
<li><p><strong>合并与分解策略：</strong></p>
<ul>
<li>对包含多值依赖的关系进行分解，确保每个分解后的关系仅有单一或无多值依赖。</li>
<li>使用算法识别非平凡多值依赖并进行适当的分解。</li>
</ul>
</li>
<li><p><strong>第四范式（4NF）详细定义：</strong></p>
<ul>
<li>若<code>R</code>满足BCNF，并且对于每个<code>R</code>中的多值依赖<code>α →→ β</code>，<code>α</code>是<code>R</code>的超级键，则<code>R</code>在4NF中。</li>
</ul>
</li>
</ul>
<p><strong>实例分析：</strong></p>
<ul>
<li><p><strong>关系 <code>R(A, B, C, G, H, I)</code> 存在的多值依赖：</strong></p>
<ul>
<li><code>A →→ B</code></li>
<li><code>B →→ HI</code></li>
<li><code>CG →→ H</code></li>
</ul>
</li>
<li><p><strong>分解步骤：</strong></p>
<ol>
<li>分解为<code>R1(A, B)</code> 和 <code>R2(A, C, G, H, I)</code></li>
<li><code>R2</code>仍不满足4NF，继续分解为<code>R3(C, G, H)</code> 和 <code>R4(A, C, G, I)</code></li>
<li><code>R4</code>再次分解为<code>R5(A, I)</code> 和 <code>R6(A, C, G)</code></li>
</ol>
<p>最终分解后的关系均满足4NF，消除了所有非平凡多值依赖。</p>
</li>
</ul>
<hr>
<h3 id="7-11-方法论与最佳实践"><a href="#7-11-方法论与最佳实践" class="headerlink" title="7.11 方法论与最佳实践"></a>7.11 方法论与最佳实践</h3><p><strong>重点难点：</strong></p>
<ul>
<li><strong>重点：</strong> 了解如何在实际数据库设计中应用规范化原则与方法。</li>
<li><strong>难点：</strong> 在复杂的实际场景中平衡规范化与性能需求，避免信息丢失和确保数据完整性。</li>
</ul>
<p><strong>内容摘要：</strong></p>
<ul>
<li><p><strong>规范化设计的目标：</strong> </p>
<ul>
<li>合理消除冗余，避免数据异常。</li>
<li>保持分解关系的可恢复性和依赖保留性。</li>
</ul>
</li>
<li><p><strong>最佳实践：</strong></p>
<ul>
<li>在设计早期进行规范化，确保关系结构合理。</li>
<li>对于性能敏感的应用场景，可以适当进行非规范化处理，如创建物化视图（Materialized Views）以提升查询效率。</li>
<li>避免在数据库设计中使用交叉表（Crosstab）的方式，因其不利于数据的灵活查询和维护。</li>
</ul>
</li>
</ul>
<p><strong>实例分析：</strong></p>
<ul>
<li><strong>关系<code>inst_child(ID, child_name)</code> 和 <code>inst_phone(ID, phone_number)</code></strong><ul>
<li>通过分解消除重复和多值依赖，确保每个关系满足4NF。</li>
<li>保持数据的独立性和完整性，避免冗余信息。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="7-12-总结与复习要点"><a href="#7-12-总结与复习要点" class="headerlink" title="7.12 总结与复习要点"></a>7.12 总结与复习要点</h3><ul>
<li><strong>函数依赖和多值依赖：</strong> 理解其定义和在规范化中的作用。</li>
<li><strong>范式的层次与要求：</strong> 按照1NF到4NF逐步规范化，理解每个范式消除的冗余类型。</li>
<li><strong>关系分解原则：</strong> 确保分解是无损连接且依赖保留。</li>
<li><strong>算法应用：</strong> 熟练运用属性闭包、规范覆盖等算法进行关系规范化。</li>
<li><strong>实际应用：</strong> 在实际设计中合理应用规范化原则，平衡规范化与性能需求。</li>
</ul>
<p><strong>学习建议：</strong></p>
<ul>
<li><strong>多做练习：</strong> 通过大量实例练习，巩固函数依赖和范式的理解。</li>
<li><strong>理解而非记忆：</strong> 深入理解规范化的原理，避免死记硬背。</li>
<li><strong>实际应用：</strong> 尝试在实际数据库设计项目中应用所学知识，提升实践能力。</li>
</ul>
<hr>
<h3 id="7-13-附录：SQL-Server环境下的示例SQL语句"><a href="#7-13-附录：SQL-Server环境下的示例SQL语句" class="headerlink" title="7.13 附录：SQL Server环境下的示例SQL语句"></a>7.13 附录：SQL Server环境下的示例SQL语句</h3><p><strong>示例1：创建和分解<code>worker</code>关系</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建原始worker表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> worker (</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    branch <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    manager <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入示例数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> worker <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;Jones&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;Frank&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;Smith&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;David&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;Curry&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;Frank&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;Larry&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;David&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;Julia&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;Frank&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分解为worker1和branch表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> worker1 (</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    branch <span class="type">CHAR</span>(<span class="number">1</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> branch (</span><br><span class="line">    branch <span class="type">CHAR</span>(<span class="number">1</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    manager <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入分解后的数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> worker1 (name, branch)</span><br><span class="line"><span class="keyword">SELECT</span> name, branch <span class="keyword">FROM</span> worker;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> branch (branch, manager)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> branch, manager <span class="keyword">FROM</span> worker;</span><br></pre></td></tr></table></figure>

<p><strong>示例2：创建触发器以维护<code>student_sum</code>表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建学生表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">    stu_id <span class="type">INT</span> <span class="keyword">IDENTITY</span>(<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    stu_name <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    stu_gender <span class="type">CHAR</span>(<span class="number">2</span>),</span><br><span class="line">    stu_age <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建存储学生人数的student_sum表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student_sum (</span><br><span class="line">    stuCount <span class="type">INT</span> <span class="keyword">DEFAULT</span>(<span class="number">0</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建插入触发器</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trig_insert</span><br><span class="line"><span class="keyword">ON</span> student</span><br><span class="line">AFTER <span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> <span class="variable">@stuNumber</span> <span class="type">INT</span>;</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="variable">@stuNumber</span> <span class="operator">=</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> student;</span><br><span class="line">    IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student_sum)</span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> student_sum <span class="keyword">VALUES</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">UPDATE</span> student_sum <span class="keyword">SET</span> stuCount <span class="operator">=</span> <span class="variable">@stuNumber</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建删除触发器</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trig_delete</span><br><span class="line"><span class="keyword">ON</span> student</span><br><span class="line">AFTER <span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> stu_id <span class="keyword">AS</span> 已删除的学生编号, stu_name, stu_gender, stu_age</span><br><span class="line">    <span class="keyword">FROM</span> deleted;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建更新触发器</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trig_update</span><br><span class="line"><span class="keyword">ON</span> student</span><br><span class="line">AFTER <span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> <span class="variable">@stuCount</span> <span class="type">INT</span>;</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="variable">@stuCount</span> <span class="operator">=</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> student;</span><br><span class="line">    <span class="keyword">UPDATE</span> student_sum <span class="keyword">SET</span> stuCount <span class="operator">=</span> <span class="variable">@stuCount</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">SELECT</span> stu_id <span class="keyword">AS</span> 更新前学生编号, stu_name <span class="keyword">AS</span> 更新前学生姓名 <span class="keyword">FROM</span> deleted;</span><br><span class="line">    <span class="keyword">SELECT</span> stu_id <span class="keyword">AS</span> 更新后学生编号, stu_name <span class="keyword">AS</span> 更新后学生姓名 <span class="keyword">FROM</span> inserted;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong></p>
<ul>
<li>确保在SQL Server中执行上述SQL语句时，具有相应的权限。</li>
<li>触发器中的<code>deleted</code>和<code>inserted</code>表是SQL Server中特殊的临时表，用于存储被删除和插入的元组。</li>
</ul>
<hr>
<p>通过以上总结，学生可以系统地掌握数据库规范化的理论与实践，理解不同范式的意义及其应用，熟悉在SQL Server环境下实现规范化设计的具体步骤与SQL语句。</p>
<hr>
<h2 id="第八章-多值依赖（MVDS）"><a href="#第八章-多值依赖（MVDS）" class="headerlink" title="第八章 多值依赖（MVDS）"></a>第八章 多值依赖（MVDS）</h2><h3 id="8-1-重点"><a href="#8-1-重点" class="headerlink" title="8.1 重点"></a>8.1 重点</h3><ol>
<li><p><strong>多值依赖（MVD）的定义与理解：</strong></p>
<ul>
<li>理解多值依赖的概念，即在关系模式中，如果属性集合X多值依赖于Y，意味着对于每个X的值，Y的值是相互独立的。</li>
</ul>
</li>
<li><p><strong>第四范式（4NF）的定义及其与BCNF的关系：</strong></p>
<ul>
<li>熟悉4NF的定义：如果一个关系模式中的每一个非平凡的多值依赖都由超级键决定，则该关系模式属于4NF。</li>
<li>理解4NF比BCNF更严格，4NF不仅处理函数依赖，还处理多值依赖。</li>
</ul>
</li>
<li><p><strong>多值依赖的规约与分解：</strong></p>
<ul>
<li>学会根据MVD进行关系模式的分解，以消除数据冗余。</li>
<li>了解4NF分解的方法，确保分解后的关系模式依然保持无损连接。</li>
</ul>
</li>
</ol>
<h3 id="8-2-难点"><a href="#8-2-难点" class="headerlink" title="8.2 难点"></a>8.2 难点</h3><ol>
<li><p><strong>多值依赖的识别与应用：</strong></p>
<ul>
<li>在复杂的关系模式中识别哪些属性之间存在多值依赖，区分多值依赖和函数依赖。</li>
</ul>
</li>
<li><p><strong>4NF与BCNF的区别与联系：</strong></p>
<ul>
<li>理解虽然每一个函数依赖都是多值依赖，但反之则不然，导致4NF包含更多的约束条件。</li>
</ul>
</li>
<li><p><strong>复杂分解的正确性验证：</strong></p>
<ul>
<li>确保通过多值依赖分解后的关系模式依然满足原有的数据依赖和保持无损连接。</li>
</ul>
</li>
</ol>
<h3 id="8-3-实例分析"><a href="#8-3-实例分析" class="headerlink" title="8.3 实例分析"></a>8.3 实例分析</h3><h4 id="实例1：多值依赖的定义与应用"><a href="#实例1：多值依赖的定义与应用" class="headerlink" title="实例1：多值依赖的定义与应用"></a>实例1：多值依赖的定义与应用</h4><p><strong>关系模式：Drinkers(name, addr, phones, beersLiked)</strong></p>
<p><strong>多值依赖：</strong></p>
<ul>
<li><code>name →→ phones</code></li>
<li><code>name →→ beersLiked</code></li>
</ul>
<p><strong>解释：</strong></p>
<ul>
<li>每个饮酒者的电话号码（phones）与他们喜欢的啤酒（beersLiked）是相互独立的，即每个电话号码可以与每种喜欢的啤酒组合出现，导致数据的重复。</li>
</ul>
<p><strong>SQL Server 中的示例操作：</strong></p>
<p>假设有以下数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Drinkers (name, addr, phones, beersLiked) <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="string">&#x27;sue&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;p1&#x27;</span>, <span class="string">&#x27;b1&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;sue&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;p2&#x27;</span>, <span class="string">&#x27;b2&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;sue&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;p2&#x27;</span>, <span class="string">&#x27;b1&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;sue&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;p1&#x27;</span>, <span class="string">&#x27;b2&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>分解为4NF：</strong></p>
<ol>
<li><p>分解出电话信息：</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Drinkers_Phones (</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    addr <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    phones <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (name, phones)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Drinkers_Phones (name, addr, phones)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> name, addr, phones <span class="keyword">FROM</span> Drinkers;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分解出喜欢的啤酒信息：</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Drinkers_BeersLiked (</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    beersLiked <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (name, beersLiked)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Drinkers_BeersLiked (name, beersLiked)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> name, beersLiked <span class="keyword">FROM</span> Drinkers;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这样可以消除原表中的多值依赖，避免数据冗余。</p>
<h4 id="实例2：4NF-的分解"><a href="#实例2：4NF-的分解" class="headerlink" title="实例2：4NF 的分解"></a>实例2：4NF 的分解</h4><p><strong>原关系模式：Drinkers(name, addr, phones, beersLiked, manf)</strong></p>
<p><strong>多值依赖：</strong></p>
<ul>
<li><code>name →→ (areaCode, phone)</code></li>
<li><code>name →→ (beersLiked, manf)</code></li>
</ul>
<p><strong>分解步骤：</strong></p>
<ol>
<li><p>创建 Drinkers_AreaPhone 表：</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Drinkers_AreaPhone (</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    areaCode <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    phone <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (name, areaCode, phone)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 Drinkers_BeersManf 表：</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Drinkers_BeersManf (</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    beersLiked <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    manf <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (name, beersLiked, manf)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>移除原表中的多值依赖：</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Drinkers_Info (</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    addr <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>确保分解无损连接：</strong></p>
<p>通过连接 Drinkers_AreaPhone 和 Drinkers_BeersManf 可以恢复原始数据。</p>
<hr>
<h3 id="8-4-图表与图示"><a href="#8-4-图表与图示" class="headerlink" title="8.4 图表与图示"></a>8.4 图表与图示</h3><h4 id="1-多值依赖的图示描述"><a href="#1-多值依赖的图示描述" class="headerlink" title="1. 多值依赖的图示描述"></a>1. 多值依赖的图示描述</h4><ul>
<li><strong>图1：MVD X →→ Y 的图示</strong><ul>
<li>关系模式 R 包含属性集 X、Y 和其他属性。</li>
<li>如果两个元组在 X 上相同，则可以交换 Y 属性的值，生成新的元组仍在 R 中。</li>
</ul>
</li>
</ul>
<h4 id="2-4NF-分解的流程图"><a href="#2-4NF-分解的流程图" class="headerlink" title="2. 4NF 分解的流程图"></a>2. 4NF 分解的流程图</h4><ul>
<li><strong>图2：4NF 分解流程</strong><ul>
<li>检查关系模式中的每一个多值依赖。</li>
<li>如果某个多值依赖不满足4NF，则将关系模式分解为两个子模式，一个包含多值依赖的属性，另一个包含剩余属性。</li>
<li>确保分解后的子模式满足无损连接。</li>
</ul>
</li>
</ul>
<hr>
<hr>
<h2 id="第九章-应用程序开发"><a href="#第九章-应用程序开发" class="headerlink" title="第九章 应用程序开发"></a>第九章 应用程序开发</h2><h3 id="9-1-重点"><a href="#9-1-重点" class="headerlink" title="9.1 重点"></a>9.1 重点</h3><ol>
<li><p><strong>应用程序架构与Web基础：</strong></p>
<ul>
<li>理解现代应用程序的多层架构（前端、中间层、后端）及其各自的职责。</li>
<li>掌握Web技术的基础，如HTML、JavaScript、Servlets、JSP等。</li>
</ul>
</li>
<li><p><strong>快速应用程序开发（RAD）工具与框架：</strong></p>
<ul>
<li>熟悉常用的RAD工具和Web框架，如Java Server Faces (JSF)、Ruby on Rails、ASP.NET等，提高开发效率。</li>
</ul>
</li>
<li><p><strong>应用性能优化：</strong></p>
<ul>
<li>了解缓存技术（如连接池、查询缓存、HTML缓存）以提高Web应用的响应速度和处理能力。</li>
</ul>
</li>
<li><p><strong>应用安全性：</strong></p>
<ul>
<li>深入理解Web应用常见的安全问题，如SQL注入、跨站脚本攻击（XSS）、跨站请求伪造（CSRF）等，并掌握相应的防护措施。</li>
<li>掌握加密技术及其在数据库中的应用，确保数据传输和存储的安全。</li>
</ul>
</li>
</ol>
<h3 id="9-2-难点"><a href="#9-2-难点" class="headerlink" title="9.2 难点"></a>9.2 难点</h3><ol>
<li><p><strong>会话管理与状态保持：</strong></p>
<ul>
<li>理解无状态的HTTP协议如何通过会话（Session）管理用户状态，掌握Cookies、Session等技术。</li>
</ul>
</li>
<li><p><strong>触发器的复杂应用：</strong></p>
<ul>
<li>设计复杂的触发器以维护数据一致性或实现自动化操作，同时避免触发器带来的性能问题和意外副作用。</li>
</ul>
</li>
<li><p><strong>跨域认证与单点登录（SSO）：</strong></p>
<ul>
<li>理解如何实现跨域的安全认证机制，如SAML、OpenID，以及在分布式系统中的认证流程。</li>
</ul>
</li>
<li><p><strong>加密技术的结合与应用：</strong></p>
<ul>
<li>了解对称加密与非对称加密的结合使用（混合加密），以及在实际数据库中的具体应用场景和配置方法。</li>
</ul>
</li>
</ol>
<h3 id="9-3-实例分析"><a href="#9-3-实例分析" class="headerlink" title="9.3 实例分析"></a>9.3 实例分析</h3><p><strong>例1：创建和使用触发器</strong></p>
<p><strong>任务：</strong> 为<code>student</code>表创建一个AFTER UPDATE触发器，更新<code>student_sum</code>表中的学生总数，并记录更新前后的学生信息。</p>
<p><strong>示例SQL代码：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建student表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">    stu_id <span class="type">INT</span> <span class="keyword">IDENTITY</span>(<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    stu_name <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    stu_gender <span class="type">CHAR</span>(<span class="number">2</span>),</span><br><span class="line">    stu_age <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建student_sum表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student_sum (</span><br><span class="line">    stuCount <span class="type">INT</span> <span class="keyword">DEFAULT</span>(<span class="number">0</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建AFTER UPDATE触发器</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trig_update</span><br><span class="line"><span class="keyword">ON</span> student</span><br><span class="line">AFTER <span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> <span class="variable">@stuCount</span> <span class="type">INT</span>;</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="variable">@stuCount</span> <span class="operator">=</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> student;</span><br><span class="line">    <span class="keyword">UPDATE</span> student_sum <span class="keyword">SET</span> stuCount <span class="operator">=</span> <span class="variable">@stuCount</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 显示更新前后的学生信息</span></span><br><span class="line">    <span class="keyword">SELECT</span> stu_id <span class="keyword">AS</span> 更新前学生编号, stu_name <span class="keyword">AS</span> 更新前学生姓名 <span class="keyword">FROM</span> deleted;</span><br><span class="line">    <span class="keyword">SELECT</span> stu_id <span class="keyword">AS</span> 更新后学生编号, stu_name <span class="keyword">AS</span> 更新后学生姓名 <span class="keyword">FROM</span> inserted;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>当<code>student</code>表中的记录被更新时，<code>trig_update</code>触发器自动执行。</li>
<li>触发器更新<code>student_sum</code>表中的<code>stuCount</code>为当前学生总数。</li>
<li>使用<code>deleted</code>表记录更新前的学生信息，使用<code>inserted</code>表记录更新后的学生信息。</li>
</ul>
<hr>
<p><strong>例2：防范SQL注入攻击</strong></p>
<p><strong>任务：</strong> 通过编写Servlet，确保用户输入通过预编译语句处理，防止SQL注入。</p>
<p><strong>示例Java Servlet代码片段：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设已经建立数据库连接conn</span></span><br><span class="line"><span class="type">String</span> <span class="variable">persontype</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;persontype&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(persontype.equals(<span class="string">&quot;student&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT ID, name, dept_name FROM student WHERE name = ?&quot;</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">    pstmt.setString(<span class="number">1</span>, name);</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.executeQuery();</span><br><span class="line"></span><br><span class="line">    out.println(<span class="string">&quot;&lt;table BORDER COLS=3&gt;&quot;</span>);</span><br><span class="line">    out.println(<span class="string">&quot;&lt;tr&gt; &lt;td&gt;ID&lt;/td&gt; &lt;td&gt;Name&lt;/td&gt; &lt;td&gt;Department&lt;/td&gt; &lt;/tr&gt;&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ID</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;ID&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">studentName</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">deptName</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;dept_name&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;tr&gt; &lt;td&gt;&quot;</span> + ID + <span class="string">&quot;&lt;/td&gt;&lt;td&gt;&quot;</span> + studentName + <span class="string">&quot;&lt;/td&gt;&lt;td&gt;&quot;</span> + deptName + <span class="string">&quot;&lt;/td&gt;&lt;/tr&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    out.println(<span class="string">&quot;&lt;/table&gt;&quot;</span>);</span><br><span class="line">    rs.close();</span><br><span class="line">    pstmt.close();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 类似处理instructor类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>使用<code>PreparedStatement</code>预编译SQL语句，确保用户输入的<code>name</code>参数被安全处理，防止SQL注入。</li>
<li>动态生成HTML表格显示查询结果。</li>
</ul>
<hr>
<p><strong>例3：使用JSP实现动态网页</strong></p>
<p><strong>任务：</strong> 编写一个JSP页面，根据用户输入的名字显示问候语。</p>
<p><strong>示例JSP代码：</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Hello&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;% </span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123; </span><br><span class="line">    %&gt;</span><br><span class="line">            Hello World</span><br><span class="line">    &lt;% </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    %&gt;</span><br><span class="line">            Hello, &lt;%= name %&gt;</span><br><span class="line">    &lt;% </span><br><span class="line">        &#125; </span><br><span class="line">    %&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>根据用户通过表单提交的<code>name</code>参数，动态显示不同的问候语。</li>
<li>如果用户未输入名字，则显示“Hello World”。</li>
</ul>
<h3 id="9-4-图表与图示"><a href="#9-4-图表与图示" class="headerlink" title="9.4 图表与图示"></a>9.4 图表与图示</h3><h4 id="1-Web-应用程序三层架构图示描述"><a href="#1-Web-应用程序三层架构图示描述" class="headerlink" title="1. Web 应用程序三层架构图示描述"></a>1. Web 应用程序三层架构图示描述</h4><ul>
<li><strong>图1：应用程序三层架构</strong><ol>
<li><strong>前端（Presentation Layer）：</strong> 用户界面部分，负责与用户交互，通过浏览器展示HTML、CSS、JavaScript等。</li>
<li><strong>业务逻辑层（Business Logic Layer）：</strong> 处理应用程序的核心功能和业务规则，通常通过Servlets、JSP、或其他中间件实现。</li>
<li><strong>数据访问层（Data Access Layer）：</strong> 负责与数据库的交互，通过JDBC、ORM工具（如Hibernate）进行数据的读取与存储。</li>
</ol>
</li>
</ul>
<h4 id="2-Servlet-处理流程图示描述"><a href="#2-Servlet-处理流程图示描述" class="headerlink" title="2. Servlet 处理流程图示描述"></a>2. Servlet 处理流程图示描述</h4><ul>
<li><strong>图2：Servlet 处理流程</strong><ol>
<li>用户在浏览器中提交请求（如表单）。</li>
<li>请求发送到Web服务器。</li>
<li>Web服务器将请求转发给对应的Servlet。</li>
<li>Servlet处理请求，包括与数据库的交互。</li>
<li>Servlet生成HTML响应并返回给Web服务器。</li>
<li>Web服务器将响应发送回用户的浏览器显示。</li>
</ol>
</li>
</ul>
<h4 id="3-防范XSS攻击的流程图示描述"><a href="#3-防范XSS攻击的流程图示描述" class="headerlink" title="3. 防范XSS攻击的流程图示描述"></a>3. 防范XSS攻击的流程图示描述</h4><ul>
<li><strong>图3：防范跨站脚本攻击（XSS）流程</strong><ol>
<li>用户提交输入数据。</li>
<li>服务器端对输入数据进行过滤，移除或转义HTML标签。</li>
<li>生成安全的HTML页面返回给用户。</li>
<li>浏览器渲染页面，防止恶意脚本执行。</li>
</ol>
</li>
</ul>
<hr>
<h2 id="第十章-物理存储系统和文件组织"><a href="#第十章-物理存储系统和文件组织" class="headerlink" title="第十章 物理存储系统和文件组织"></a>第十章 物理存储系统和文件组织</h2><h3 id="10-1-物理存储介质分类"><a href="#10-1-物理存储介质分类" class="headerlink" title="10.1 物理存储介质分类"></a>10.1 物理存储介质分类</h3><p>物理存储介质按数据存储的特性分为以下两类：</p>
<ul>
<li><p><strong>易失性存储（Volatile Storage）</strong>：</p>
<ul>
<li>断电后数据丢失。</li>
<li>例如：缓存（Cache）、主存（Main Memory）。</li>
</ul>
</li>
<li><p><strong>非易失性存储（Non-Volatile Storage）</strong>：</p>
<ul>
<li>断电后数据仍然保存。</li>
<li>包括：二级存储（磁盘、闪存）、三级存储（磁带、光盘）和带有电池支持的主存。</li>
</ul>
</li>
</ul>
<p><strong>影响存储介质选择的因素：</strong></p>
<ul>
<li>数据访问速度。</li>
<li>单位存储成本。</li>
<li>可靠性。</li>
</ul>
<hr>
<h3 id="10-2-存储层次结构"><a href="#10-2-存储层次结构" class="headerlink" title="10.2 存储层次结构"></a>10.2 存储层次结构</h3><p>存储设备按照速度、成本和存储容量形成一个层次结构：</p>
<ul>
<li><p><strong>主存储（Primary Storage）</strong>：</p>
<ul>
<li><strong>特点</strong>：速度最快，但易失性。</li>
<li><strong>举例</strong>：缓存、主存。</li>
</ul>
</li>
<li><p><strong>二级存储（Secondary Storage）</strong>：</p>
<ul>
<li><strong>特点</strong>：非易失性，速度适中。</li>
<li><strong>举例</strong>：闪存、磁盘（HDD、SSD）。</li>
</ul>
</li>
<li><p><strong>三级存储（Tertiary Storage）</strong>：</p>
<ul>
<li><strong>特点</strong>：非易失性，访问速度慢，适合归档数据。</li>
<li><strong>举例</strong>：磁带（顺序访问）、光盘。</li>
</ul>
</li>
</ul>
<p><strong>实例分析：</strong></p>
<ul>
<li>磁带存储容量可达1-12TB，适合大规模归档存储，但访问速度慢（顺序访问）。</li>
<li>磁盘存储的扇区（Sector）是访问的最小单位，一般大小为512字节。</li>
</ul>
<hr>
<h3 id="10-3-磁盘存储机制"><a href="#10-3-磁盘存储机制" class="headerlink" title="10.3 磁盘存储机制"></a>10.3 磁盘存储机制</h3><p>磁盘存储的关键技术细节：</p>
<ul>
<li><p><strong>磁盘结构</strong>：</p>
<ul>
<li>磁盘由若干圆形磁盘组成，每个磁盘包含多个<strong>磁道（Tracks）</strong>，每个磁道再分为<strong>扇区（Sectors）</strong>。</li>
<li>典型硬盘每个磁盘有50K-100K磁道，每扇区大小通常为512字节。</li>
</ul>
</li>
<li><p><strong>读写过程</strong>：</p>
<ul>
<li><strong>磁臂定位时间（Seek Time）</strong>：磁臂移动到目标磁道的时间。</li>
<li><strong>旋转延迟（Rotational Latency）</strong>：目标扇区旋转至磁头下的时间。</li>
<li><strong>数据传输率（Data-Transfer Rate）</strong>：数据传输速率，典型范围为25至200MB&#x2F;s。</li>
</ul>
</li>
</ul>
<p><strong>实例分析：</strong><br>假设一块硬盘的平均定位时间为5ms，旋转延迟为5ms，传输速率为100MB&#x2F;s，一次读取1MB数据：</p>
<ul>
<li>总延迟 &#x3D; 定位时间 + 旋转延迟 + 数据传输时间 &#x3D; 5ms + 5ms + (1MB &#x2F; 100MB&#x2F;s) &#x3D; 15ms。</li>
</ul>
<hr>
<h3 id="10-4-磁盘可靠性与性能"><a href="#10-4-磁盘可靠性与性能" class="headerlink" title="10.4 磁盘可靠性与性能"></a>10.4 磁盘可靠性与性能</h3><ul>
<li><p><strong>平均故障间隔时间（MTTF）</strong>：</p>
<ul>
<li>表示磁盘在连续运行中平均无故障的时间，通常为3-5年。</li>
<li>例如：MTTF为120万小时，表示1000块新磁盘中，每1200小时可能损坏一块。</li>
</ul>
</li>
<li><p><strong>磁盘控制器</strong>：</p>
<ul>
<li>负责磁盘与计算机的交互，执行磁臂移动、数据读写、校验和计算等任务。</li>
<li>提供坏扇区重新映射功能以提高可靠性。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="10-5-闪存存储"><a href="#10-5-闪存存储" class="headerlink" title="10.5 闪存存储"></a>10.5 闪存存储</h3><ul>
<li><p><strong>NAND闪存</strong>：</p>
<ul>
<li><strong>特点</strong>：广泛用于存储设备（如SSD），便宜但需要按页读取（页大小512B-4KB）。</li>
<li><strong>速度</strong>：读取一页耗时20-100微秒。</li>
<li><strong>限制</strong>：每个页只能写一次，重写需先擦除。</li>
</ul>
</li>
<li><p><strong>固态硬盘（SSD）</strong>：</p>
<ul>
<li>内部使用多块闪存，提供块级接口。</li>
<li><strong>传输速率</strong>：通过NVMe协议可达3GB&#x2F;s。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="10-6-RAID（独立磁盘冗余阵列）"><a href="#10-6-RAID（独立磁盘冗余阵列）" class="headerlink" title="10.6 RAID（独立磁盘冗余阵列）"></a>10.6 RAID（独立磁盘冗余阵列）</h3><p>RAID通过并行和冗余提升存储系统的性能和可靠性：</p>
<ul>
<li><p><strong>RAID 0（条带化存储，无冗余）</strong>：</p>
<ul>
<li><strong>特点</strong>：将数据分块存储到多个磁盘中，读写性能高，但无数据保护。</li>
<li><strong>用途</strong>：高性能、数据丢失风险可接受的场景。</li>
</ul>
</li>
<li><p><strong>RAID 1（镜像存储）</strong>：</p>
<ul>
<li><strong>特点</strong>：将每块磁盘的数据完全复制到另一块磁盘。</li>
<li><strong>优点</strong>：提供高可靠性，适合日志存储。</li>
</ul>
</li>
<li><p><strong>RAID 5（分布式奇偶校验）</strong>：</p>
<ul>
<li><strong>特点</strong>：数据和奇偶校验分布在所有磁盘上，提供容错能力。</li>
<li><strong>缺点</strong>：写性能较低。</li>
</ul>
</li>
<li><p><strong>RAID 6（双奇偶校验）</strong>：</p>
<ul>
<li><strong>特点</strong>：比RAID 5增加额外奇偶校验块，可容忍两块磁盘同时故障。</li>
</ul>
</li>
</ul>
<p><strong>实例分析：</strong><br>RAID 1的两个磁盘MTTF均为10万小时，修复时间为10小时，则系统数据丢失的平均时间为：</p>
<ul>
<li>MTTDL ≈ (MTTF² &#x2F; 修复时间) &#x3D; (10万² &#x2F; 10) &#x3D; 10亿小时（约11万年）。</li>
</ul>
<hr>
<h3 id="10-7-文件组织"><a href="#10-7-文件组织" class="headerlink" title="10.7 文件组织"></a>10.7 文件组织</h3><p>数据库存储为文件集合，每个文件由记录组成：</p>
<ul>
<li><p><strong>固定长度记录</strong>：</p>
<ul>
<li><strong>存储方式</strong>：记录按固定字节偏移存储。</li>
<li><strong>删除方式</strong>：可以通过移动记录或维护空闲列表实现。</li>
</ul>
</li>
<li><p><strong>可变长度记录</strong>：</p>
<ul>
<li><strong>存储方式</strong>：使用偏移量和长度标记字段，实际数据存储在记录末尾。</li>
<li><strong>优点</strong>：支持变长字段（如VARCHAR）和重复字段。</li>
</ul>
</li>
<li><p><strong>大对象存储</strong>：</p>
<ul>
<li>例如：BLOB&#x2F;CLOB类型。</li>
<li><strong>存储方式</strong>：可以拆分为多个元组存储，或者存储为文件系统中的文件。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="10-8-文件组织策略"><a href="#10-8-文件组织策略" class="headerlink" title="10.8 文件组织策略"></a>10.8 文件组织策略</h3><ul>
<li><p><strong>堆文件（Heap）</strong>：</p>
<ul>
<li>无序存储，记录插入到空闲空间。</li>
<li>使用空闲空间映射表（Free-Space Map）来快速定位空闲块。</li>
</ul>
</li>
<li><p><strong>顺序文件（Sequential）</strong>：</p>
<ul>
<li>按搜索键值存储，适合顺序访问。</li>
<li><strong>处理删除和插入</strong>：通过溢出块和指针链维护顺序。</li>
</ul>
</li>
<li><p><strong>多表聚簇文件（Multitable Clustering）</strong>：</p>
<ul>
<li>将多个关系存储在同一文件中，适合频繁的连接查询。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="10-9-列存储与压缩"><a href="#10-9-列存储与压缩" class="headerlink" title="10.9 列存储与压缩"></a>10.9 列存储与压缩</h3><ul>
<li><p><strong>列存储（Column-Oriented Storage）</strong>：</p>
<ul>
<li>将每个属性单独存储，适合数据分析和决策支持。</li>
<li><strong>优点</strong>：减少I&#x2F;O、提升压缩率、支持矢量化处理。</li>
<li><strong>缺点</strong>：重建元组成本高，更新和删除效率低。</li>
</ul>
</li>
<li><p><strong>实例：Parquet文件格式</strong>：</p>
<ul>
<li>广泛应用于大数据场景，提供高效的列式存储。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="10-10-缓存管理"><a href="#10-10-缓存管理" class="headerlink" title="10.10 缓存管理"></a>10.10 缓存管理</h3><ul>
<li><strong>缓冲区管理器</strong>：<ul>
<li><strong>功能</strong>：管理内存中的数据块缓存，减少磁盘访问次数。</li>
<li><strong>替换策略</strong>：<ul>
<li><strong>LRU（最近最少使用）</strong>：根据历史访问记录替换。</li>
<li><strong>MRU（最近最多使用）</strong>：适合需要频繁访问的块。</li>
<li><strong>Toss-Immediate</strong>：块处理完成后立即释放。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>实例分析：</strong><br>嵌套循环连接可能导致LRU策略性能低下，因为循环内的访问模式会不断驱逐之前加载的块。</p>
<hr>
<h3 id="10-11-数据字典（系统目录）"><a href="#10-11-数据字典（系统目录）" class="headerlink" title="10.11 数据字典（系统目录）"></a>10.11 数据字典（系统目录）</h3><p>数据字典存储数据库的元数据，例如：</p>
<ul>
<li>关系的名称、属性及其类型。</li>
<li>索引信息和物理存储位置。</li>
<li>用户信息和统计数据。</li>
</ul>
<p>元数据的高效访问对数据库系统的运行至关重要。</p>
<hr>
<hr>
<h2 id="第十一章-索引"><a href="#第十一章-索引" class="headerlink" title="第十一章 索引"></a>第十一章 索引</h2><h3 id="11-1-索引的基本概念"><a href="#11-1-索引的基本概念" class="headerlink" title="11.1 索引的基本概念"></a>11.1 索引的基本概念</h3><p><strong>关键概念</strong></p>
<ul>
<li><p><strong>搜索键（Search Key）</strong>：</p>
<ul>
<li>用于查找记录的一个或多个属性。</li>
</ul>
</li>
<li><p><strong>索引文件（Index File）</strong>：</p>
<ul>
<li>包含形式为 <code>(search-key, pointer)</code> 的索引条目，指向实际数据记录。</li>
</ul>
</li>
<li><p><strong>索引的两种基本类型</strong>：</p>
<ol>
<li><strong>有序索引（Ordered Indices）</strong>：按搜索键值排序存储。</li>
<li><strong>哈希索引（Hash Indices）</strong>：通过哈希函数将搜索键均匀分布到“桶”中。</li>
</ol>
</li>
</ul>
<p><strong>评价指标</strong></p>
<ul>
<li><p><strong>支持的访问类型</strong>：</p>
<ul>
<li>按指定值查找记录。</li>
<li>按范围值查找记录。</li>
</ul>
</li>
<li><p><strong>时间效率</strong>：访问、插入和删除的时间。</p>
</li>
<li><p><strong>空间开销</strong>：索引的存储成本。</p>
</li>
</ul>
<hr>
<h3 id="11-2-有序索引"><a href="#11-2-有序索引" class="headerlink" title="11.2 有序索引"></a>11.2 有序索引</h3><p>有序索引是基于搜索键值排序的索引方式。</p>
<p><strong>分类</strong></p>
<ol>
<li><p><strong>聚簇索引（Clustering Index）</strong>：</p>
<ul>
<li>索引的键值与文件的物理顺序一致。</li>
<li>通常是主键，但不一定必须是主键。</li>
<li>又称<strong>主索引（Primary Index）</strong>。</li>
</ul>
</li>
<li><p><strong>非聚簇索引（Non-Clustering Index）</strong>：</p>
<ul>
<li>索引的键值与文件的物理顺序无关。</li>
<li>又称<strong>次级索引（Secondary Index）</strong>。</li>
</ul>
</li>
<li><p><strong>密集索引（Dense Index）</strong>：</p>
<ul>
<li>每个搜索键值都有一个索引记录。</li>
<li><strong>例子</strong>：对<code>instructor</code>关系的<code>ID</code>属性建立密集索引。<ul>
<li><strong>解析</strong>：每个<code>ID</code>值在索引中都有一个对应的条目，指向实际数据记录。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>稀疏索引（Sparse Index）</strong>：</p>
<ul>
<li>仅为部分搜索键值建立索引条目。</li>
<li><strong>适用场景</strong>：文件按搜索键排序，例如每个块的第一个键值。</li>
<li><strong>优缺点</strong>：稀疏索引节省空间，但查找速度较慢。</li>
</ul>
</li>
</ol>
<p><strong>例子解析</strong>：<br>假设文件根据<code>dept_name</code>排序，对其建立稀疏索引。要查找<code>Physics</code>，首先找到小于<code>Physics</code>的最大键值（例如<code>Mathematics</code>），然后从指针指定的位置顺序扫描。</p>
<hr>
<h3 id="11-3-多级索引"><a href="#11-3-多级索引" class="headerlink" title="11.3 多级索引"></a>11.3 多级索引</h3><p>当索引文件太大无法全部加载到内存时：</p>
<ul>
<li>将索引看作顺序文件，为其构建稀疏索引（称为<strong>外层索引</strong>）。</li>
<li>如果外层索引仍然过大，可以继续构建更高层的索引，形成多层次结构。</li>
</ul>
<p><strong>优点</strong>：通过分层结构减少磁盘访问次数，提高查找效率。<br><strong>缺点</strong>：插入或删除时需要更新所有层次的索引。</p>
<hr>
<h3 id="11-4-B-树索引"><a href="#11-4-B-树索引" class="headerlink" title="11.4 B+树索引"></a>11.4 B+树索引</h3><p><strong>B+树</strong>是一种动态多级索引结构，广泛用于数据库系统中。</p>
<p><strong>特点</strong></p>
<ul>
<li>自动调整以适应插入和删除，避免性能下降。</li>
<li><strong>平衡性</strong>：从根到叶节点的路径长度相同。</li>
<li><strong>节点结构</strong>：<ul>
<li>非叶节点存储键值和指针，形成稀疏索引。</li>
<li>叶节点存储所有搜索键值及对应指针，形成密集索引，并通过指针相连。</li>
</ul>
</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>插入和删除只需局部调整，性能稳定。</li>
<li>查找时间为<code>O(log n)</code>，其中<code>n</code>为树的阶。</li>
</ul>
<p><strong>例子解析</strong>：</p>
<ol>
<li><p><strong>插入“Adams”</strong>：</p>
<ul>
<li>找到适当的叶节点，如果节点已满，拆分节点，将部分键值移至新节点，并将新节点的信息插入父节点。</li>
<li>如果父节点也满，继续向上拆分，可能导致树高度增加。</li>
</ul>
</li>
<li><p><strong>删除“Singh”</strong>：</p>
<ul>
<li>如果删除导致节点不足，将其与相邻节点合并，或从邻居节点借用键值。</li>
<li>如果父节点变得不足，继续调整，可能导致树高度减少。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="11-5-哈希索引"><a href="#11-5-哈希索引" class="headerlink" title="11.5 哈希索引"></a>11.5 哈希索引</h3><p>哈希索引通过哈希函数将搜索键值映射到桶地址。</p>
<p><strong>分类</strong></p>
<ol>
<li><p><strong>静态哈希</strong>：</p>
<ul>
<li>桶数量固定。</li>
<li><strong>缺点</strong>：当文件大小动态变化时，可能导致桶溢出或空间浪费。</li>
</ul>
</li>
<li><p><strong>动态哈希</strong>：</p>
<ul>
<li><strong>线性哈希（Linear Hashing）</strong>：增量扩展桶，以适应文件增长。</li>
<li><strong>可扩展哈希（Extendable Hashing）</strong>：通过增加哈希表的深度而不增加桶数量。</li>
</ul>
</li>
</ol>
<p><strong>例子解析</strong>：</p>
<p>对<code>instructor</code>的<code>ID</code>属性建立哈希索引：</p>
<ol>
<li>将<code>ID</code>值通过哈希函数映射到桶。</li>
<li>如果多个键值映射到同一桶，使用溢出链表存储额外记录。</li>
</ol>
<p><strong>优缺点对比</strong>：</p>
<ul>
<li>哈希索引适合精确查找。</li>
<li>有序索引适合范围查询。</li>
</ul>
<hr>
<h3 id="11-6-复合索引"><a href="#11-6-复合索引" class="headerlink" title="11.6 复合索引"></a>11.6 复合索引</h3><p><strong>复合搜索键</strong>：包含多个属性的搜索键，例如<code>(dept_name, salary)</code>。</p>
<p><strong>特点</strong></p>
<ul>
<li>按字典序排序（例如：<code>(Finance, 80000)</code> &lt; <code>(Marketing, 70000)</code>）。</li>
<li>可以同时高效处理多个条件查询。</li>
</ul>
<p><strong>例子解析</strong>：<br>假设有索引<code>(dept_name, salary)</code>：</p>
<ol>
<li><p>查询条件<code>dept_name=&quot;Finance&quot; AND salary=80000</code>：</p>
<ul>
<li>索引直接定位到满足条件的记录。</li>
</ul>
</li>
<li><p>查询条件<code>dept_name=&quot;Finance&quot; AND salary&lt;80000</code>：</p>
<ul>
<li>索引可快速定位到<code>Finance</code>，然后顺序扫描满足<code>salary&lt;80000</code>的记录。</li>
</ul>
</li>
<li><p>查询条件<code>dept_name&lt;&quot;Finance&quot; AND salary=80000</code>：</p>
<ul>
<li>无法高效利用索引，因为<code>dept_name</code>的范围查询优先级更高。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="11-7-位图索引"><a href="#11-7-位图索引" class="headerlink" title="11.7 位图索引"></a>11.7 位图索引</h3><p>哈希索引通过哈希函数将搜索键值映射到桶地址。</p>
<p><strong>特点</strong></p>
<ul>
<li>每个属性值对应一个位图，位图每位表示一个记录是否具有该值。</li>
<li>适合属性值数量较少的情况，例如性别、国家、收入等级。</li>
</ul>
<p><strong>查询操作</strong></p>
<ul>
<li>使用位运算（与、或、非）快速计算结果。</li>
<li><strong>例子</strong>：<ul>
<li>查询男性且收入等级为L1：<code>Bitmap(Male) AND Bitmap(L1)</code>。</li>
<li>查询结果位图可以直接定位记录。</li>
</ul>
</li>
</ul>
<p><strong>优点</strong>：空间开销小，查询效率高。<br><strong>缺点</strong>：不适合动态变化的数据。</p>
<hr>
<h3 id="11-8-索引的创建与管理"><a href="#11-8-索引的创建与管理" class="headerlink" title="11.8 索引的创建与管理"></a>11.8 索引的创建与管理</h3><p><strong>SQL中的索引定义</strong></p>
<ul>
<li><p><strong>创建索引</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name (attribute_list);</span><br></pre></td></tr></table></figure>

<p><strong>例子</strong>：对<code>branch</code>表的<code>branch_name</code>属性创建索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX b_index <span class="keyword">ON</span> branch(branch_name);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>删除索引</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>唯一索引</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX unique_index_name <span class="keyword">ON</span> table_name(attribute_list);</span><br></pre></td></tr></table></figure>

<p>用于强制候选键的唯一性。</p>
</li>
</ul>
<p><strong>数据库自动创建索引</strong></p>
<ul>
<li>数据库通常会自动为<strong>主键</strong>和<strong>外键</strong>创建索引：<ul>
<li>主键索引：加速主键查找。</li>
<li>外键索引：加速连接查询。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="11-9-索引的优化选择"><a href="#11-9-索引的优化选择" class="headerlink" title="11.9 索引的优化选择"></a>11.9 索引的优化选择</h3><p>索引的使用需权衡查询性能与更新成本：</p>
<ul>
<li><p><strong>查询优化</strong>：</p>
<ul>
<li>索引加速查询，但复杂查询可能需要多个索引。</li>
<li><strong>索引调优工具</strong>：部分数据库提供索引调优助手，根据查询和更新负载建议优化索引。</li>
</ul>
</li>
<li><p><strong>更新代价</strong>：</p>
<ul>
<li>插入、删除、更新操作需要维护索引，可能增加成本。</li>
</ul>
</li>
</ul>
<hr>
<hr>
<h2 id="第十三章-查询优化"><a href="#第十三章-查询优化" class="headerlink" title="第十三章 查询优化"></a>第十三章 查询优化</h2><h3 id="13-1-查询优化的目标"><a href="#13-1-查询优化的目标" class="headerlink" title="13.1 查询优化的目标"></a>13.1 查询优化的目标</h3><p>查询优化的目标是通过生成低成本的执行计划来提高查询性能。</p>
<ul>
<li><strong>查询优化的两种方法</strong>：<ol>
<li><p><strong>启发式优化（Heuristic Optimization）</strong>：</p>
<ul>
<li>使用规则优化查询结构，不需要具体的统计信息。</li>
<li>优化过程基于通用规则，如选择操作下推、投影操作提前等。</li>
</ul>
</li>
<li><p><strong>基于成本的优化（Cost-Based Optimization）</strong>：</p>
<ul>
<li>使用统计信息和模型估计查询计划的执行成本。</li>
<li>比较多个等价查询计划，选择成本最低的方案。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="13-2-关系代数等价性与规则"><a href="#13-2-关系代数等价性与规则" class="headerlink" title="13.2 关系代数等价性与规则"></a>13.2 关系代数等价性与规则</h3><h4 id="等价性定义"><a href="#等价性定义" class="headerlink" title="等价性定义"></a>等价性定义</h4><p>两个关系代数表达式在所有合法的数据库实例上生成相同的结果集，则它们是等价的。</p>
<h4 id="常用等价规则"><a href="#常用等价规则" class="headerlink" title="常用等价规则"></a>常用等价规则</h4><ol>
<li><p><strong>选择操作规则</strong>：</p>
<ul>
<li><p>选择的分解与交换：</p>
<ul>
<li><code>σθ1∧θ2(E) ≡ σθ1(σθ2(E))</code></li>
<li><code>σθ1(σθ2(E)) ≡ σθ2(σθ1(E))</code></li>
</ul>
</li>
<li><p>选择与笛卡尔积、连接的结合：</p>
<ul>
<li><code>σθ(E1 × E2) ≡ E1 ⨝θ E2</code></li>
<li><code>σθ1(E1 ⨝θ2 E2) ≡ E1 ⨝θ1∧θ2 E2</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>投影操作规则</strong>：</p>
<ul>
<li>只保留最后一个投影操作：<br><code>πL1(πL2(...πLn(E)...)) ≡ πL1(E)</code>，其中 <code>L1 ⊆ L2 ⊆ ... ⊆ Ln</code>。</li>
</ul>
</li>
<li><p><strong>连接操作规则</strong>：</p>
<ul>
<li>连接的交换性：<code>E1 ⨝ E2 ≡ E2 ⨝ E1</code></li>
<li>连接的结合性：<code>(E1 ⨝ E2) ⨝ E3 ≡ E1 ⨝ (E2 ⨝ E3)</code></li>
</ul>
</li>
<li><p><strong>选择与连接的分配性</strong>：</p>
<ul>
<li><code>σθ(E1 ⨝ E2) ≡ (σθ(E1)) ⨝ E2</code>，条件是 <code>θ</code> 只涉及 <code>E1</code> 的属性。</li>
</ul>
</li>
<li><p><strong>投影与连接的分配性</strong>：</p>
<ul>
<li><code>πL1∪L2(E1 ⨝ E2) ≡ (πL1(E1)) ⨝ (πL2(E2))</code>，条件是 <code>L1</code> 和 <code>L2</code> 包含连接所需的所有属性。</li>
</ul>
</li>
<li><p><strong>集合操作规则</strong>：</p>
<ul>
<li>并集和交集的交换性与结合性：<ul>
<li><code>E1 ∪ E2 ≡ E2 ∪ E1</code>，<code>(E1 ∪ E2) ∪ E3 ≡ E1 ∪ (E2 ∪ E3)</code></li>
</ul>
</li>
<li>选择与集合操作的分配性：<ul>
<li><code>σθ(E1 ∪ E2) ≡ σθ(E1) ∪ σθ(E2)</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>例子解析</strong>：<br>查询：查找<code>Music</code>系的教师姓名及其在2017年授课的课程标题。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ARTIST.NAME, COURSE.TITLE</span><br><span class="line"><span class="keyword">FROM</span> ARTIST, TEACHES, COURSE</span><br><span class="line"><span class="keyword">WHERE</span> ARTIST.dept_name <span class="operator">=</span> <span class="string">&#x27;Music&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> TEACHES.year <span class="operator">=</span> <span class="number">2017</span></span><br><span class="line">  <span class="keyword">AND</span> ARTIST.ID <span class="operator">=</span> TEACHES.ID</span><br><span class="line">  <span class="keyword">AND</span> TEACHES.course_id <span class="operator">=</span> COURSE.course_id;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>初始表达式：<br><code>πname, title(σdept_name=&#39;Music&#39;∧year=2017(instructor ⨝ teaches ⨝ course))</code></p>
</li>
<li><p>使用连接结合性：<br><code>(instructor ⨝ teaches) ⨝ course</code> 转换为 <code>instructor ⨝ (teaches ⨝ course)</code></p>
</li>
<li><p>应用选择下推规则：<br><code>σdept_name=&#39;Music&#39;(instructor) ⨝ σyear=2017(teaches) ⨝ course</code></p>
</li>
<li><p>提前投影：减少中间结果的大小。</p>
</li>
</ol>
<hr>
<h3 id="13-3-基于成本的优化"><a href="#13-3-基于成本的优化" class="headerlink" title="13.3 基于成本的优化"></a>13.3 基于成本的优化</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li><p><strong>生成等价表达式</strong>：</p>
<ul>
<li>使用关系代数等价规则生成多个等价表达式。</li>
</ul>
</li>
<li><p><strong>注释表达式</strong>：</p>
<ul>
<li>为每个表达式选择具体的算法（如嵌套循环连接、哈希连接等）。</li>
</ul>
</li>
<li><p><strong>估算成本</strong>：</p>
<ul>
<li>基于统计信息估算每种执行计划的成本。</li>
</ul>
</li>
<li><p><strong>选择最低成本计划</strong>：</p>
<ul>
<li>比较所有计划，选择成本最低的一个。</li>
</ul>
</li>
</ol>
<h4 id="成本估算"><a href="#成本估算" class="headerlink" title="成本估算"></a>成本估算</h4><ul>
<li><p><strong>统计信息</strong>：</p>
<ul>
<li>记录的数量（<code>nr</code>）。</li>
<li>每个块的记录数（<code>fr</code>）。</li>
<li>属性的不同值数量（<code>V(A, r)</code>）。</li>
</ul>
</li>
<li><p><strong>选择操作</strong>：</p>
<ul>
<li><code>σA=v(r)</code> 的记录数：<code>nr / V(A, r)</code>。</li>
<li><code>σA≥v(r)</code> 的记录数：<code>nr * (Amax - v + 1) / (Amax - Amin + 1)</code>。</li>
</ul>
</li>
<li><p><strong>连接操作</strong>：</p>
<ul>
<li>若 <code>R ⋂ S</code> 为键：<code>|r ⨝ s| = |s|</code>。</li>
<li>一般情况：<code>|r ⨝ s| ≈ nr * ns / max(V(A, r), V(A, s))</code>。</li>
</ul>
</li>
</ul>
<p><strong>例子解析</strong>：<br>学生表（<code>student</code>）和选课表（<code>takes</code>）：  </p>
<ul>
<li><code>nstudent = 5000</code>, <code>bstudent = 100</code>, <code>ntakes = 10000</code>, <code>btakes = 400</code>。  </li>
<li><code>V(ID, student) = 5000</code>, <code>V(ID, takes) = 2500</code>。<br>假设 <code>ID</code> 是 <code>takes</code> 的外键，连接结果的大小为 <code>ntakes = 10000</code>。</li>
</ul>
<hr>
<h3 id="13-4-动态规划与连接顺序"><a href="#13-4-动态规划与连接顺序" class="headerlink" title="13.4 动态规划与连接顺序"></a>13.4 动态规划与连接顺序</h3><h4 id="连接顺序优化"><a href="#连接顺序优化" class="headerlink" title="连接顺序优化"></a>连接顺序优化</h4><ul>
<li><strong>连接顺序会显著影响查询性能。</strong></li>
<li>动态规划通过递归计算子集的最优连接计划，避免重复计算。</li>
</ul>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ol>
<li><p>对于每个子集 <code>S</code>：</p>
<ul>
<li>尝试所有可能的分割 <code>S1</code> 和 <code>S2</code>（<code>S1 ⨝ S2</code>）。</li>
<li>计算每种分割的成本，选择最低成本的方案。</li>
</ul>
</li>
<li><p>存储每个子集的最优计划，避免重复计算。</p>
</li>
</ol>
<p><strong>复杂性</strong>：  </p>
<ul>
<li><strong>一般情况</strong>：<code>O(3^n)</code>，其中 <code>n</code> 为关系数量。  </li>
<li><strong>左深树优化</strong>：<code>O(n * 2^n)</code>，适用于优化复杂度较低的场景。</li>
</ul>
<hr>
<h3 id="13-5-启发式优化"><a href="#13-5-启发式优化" class="headerlink" title="13.5 启发式优化"></a>13.5 启发式优化</h3><h4 id="启发式规则"><a href="#启发式规则" class="headerlink" title="启发式规则"></a>启发式规则</h4><ol>
<li><p><strong>选择操作尽早执行</strong>：</p>
<ul>
<li>减少待处理的元组数量。</li>
</ul>
</li>
<li><p><strong>投影操作尽早执行</strong>：</p>
<ul>
<li>减少待处理的属性数量。</li>
</ul>
</li>
<li><p><strong>优先执行选择性强的操作</strong>：</p>
<ul>
<li>选择性强的操作通常会显著减少中间结果的大小。</li>
</ul>
</li>
<li><p><strong>避免笛卡尔积</strong>：</p>
<ul>
<li>替换为连接操作。</li>
</ul>
</li>
</ol>
<p><strong>例子解析</strong>：<br>查询：查找专辑名称为“Andy’s OG Remix”的艺术家姓名。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ARTIST.NAME</span><br><span class="line"><span class="keyword">FROM</span> ARTIST, APPEARS, ALBUM</span><br><span class="line"><span class="keyword">WHERE</span> ARTIST.ID <span class="operator">=</span> APPEARS.ARTIST_ID</span><br><span class="line">  <span class="keyword">AND</span> APPEARS.ALBUM_ID <span class="operator">=</span> ALBUM.ID</span><br><span class="line">  <span class="keyword">AND</span> ALBUM.NAME <span class="operator">=</span> &quot;Andy’s OG Remix&quot;;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>分解谓词</strong>：  </p>
<ul>
<li><code>ARTIST.ID = APPEARS.ARTIST_ID</code>  </li>
<li><code>APPEARS.ALBUM_ID = ALBUM.ID</code>  </li>
<li><code>ALBUM.NAME = &quot;Andy’s OG Remix&quot;</code></li>
</ul>
</li>
<li><p><strong>谓词下推</strong>：  </p>
<ul>
<li>将 <code>ALBUM.NAME = &quot;Andy’s OG Remix&quot;</code> 下推到 <code>ALBUM</code> 中，减少中间结果。</li>
</ul>
</li>
<li><p><strong>替换笛卡尔积</strong>：  </p>
<ul>
<li>用连接代替笛卡尔积：<code>ARTIST ⨝ APPEARS ⨝ ALBUM</code>。</li>
</ul>
</li>
<li><p><strong>提前投影</strong>：  </p>
<ul>
<li>删除不必要的属性，减少中间结果的大小。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="13-6-统计信息与直方图"><a href="#13-6-统计信息与直方图" class="headerlink" title="13.6 统计信息与直方图"></a>13.6 统计信息与直方图</h3><ul>
<li><strong>数据库系统使用统计信息（如记录数、属性的不同值数）来估算查询成本。</strong></li>
<li><strong>直方图</strong>：<ul>
<li><strong>等宽直方图</strong>：将值域划分为等宽区间。</li>
<li><strong>等深直方图</strong>：每个区间包含相同数量的元组。</li>
</ul>
</li>
</ul>
<p><strong>例子解析</strong>：<br>假设<code>V(age, people) = 5</code>, <code>nr = 5</code>：  </p>
<ol>
<li><p>查询 <code>age=2</code>：  </p>
<ul>
<li>满足条件的记录数为 <code>nr / V(age, people) = 5 / 5 = 1</code>。</li>
</ul>
</li>
<li><p>查询 <code>age&gt;=2</code>：  </p>
<ul>
<li>满足条件的记录数为 <code>nr * (Amax - 2 + 1) / (Amax - Amin + 1)</code>。  </li>
<li>结果为 <code>5 * (4 - 2 + 1) / (4 - 0 + 1) = 3</code>。</li>
</ul>
</li>
</ol>
<hr>
<hr>
<h2 id="第十四章-事务"><a href="#第十四章-事务" class="headerlink" title="第十四章 事务"></a>第十四章 事务</h2><h3 id="14-1-事务的基本概念"><a href="#14-1-事务的基本概念" class="headerlink" title="14.1 事务的基本概念"></a>14.1 事务的基本概念</h3><h4 id="事务（Transaction）"><a href="#事务（Transaction）" class="headerlink" title="事务（Transaction）"></a>事务（Transaction）</h4><ul>
<li><strong>定义</strong>：事务是一个程序执行的单位，通过访问和可能更新数据库中的数据项来完成任务。</li>
<li><strong>性质</strong>：事务要么完全执行（所有操作成功完成），要么完全不执行（任何操作都不生效）。</li>
</ul>
<p><strong>例子</strong>：<br>将$50从账户A转移到账户B的事务：</p>
<ol>
<li>读取账户A余额。</li>
<li>从账户A扣除50。</li>
<li>写回账户A的新余额。</li>
<li>读取账户B余额。</li>
<li>向账户B添加50。</li>
<li>写回账户B的新余额。</li>
</ol>
<p><strong>问题</strong>：</p>
<ul>
<li>如果系统在步骤3和步骤6之间崩溃，可能导致数据不一致（$50丢失）。</li>
</ul>
<hr>
<h3 id="14-2-事务的ACID属性"><a href="#14-2-事务的ACID属性" class="headerlink" title="14.2 事务的ACID属性"></a>14.2 事务的ACID属性</h3><p>事务需要满足以下四个关键特性以保证数据库的一致性：</p>
<ol>
<li><p><strong>原子性（Atomicity）</strong>：</p>
<ul>
<li>事务的所有操作要么全部执行，要么全部不执行。</li>
<li><strong>解决方法</strong>：通过日志记录，在事务失败时回滚未完成的操作。</li>
</ul>
</li>
<li><p><strong>一致性（Consistency）</strong>：</p>
<ul>
<li>事务的执行必须保证数据库从一个一致状态转变为另一个一致状态。</li>
<li><strong>例子</strong>：在转账事务中，A和B账户余额之和在事务执行后保持不变。</li>
</ul>
</li>
<li><p><strong>隔离性（Isolation）</strong>：</p>
<ul>
<li>事务彼此独立运行，每个事务的中间状态对其他事务不可见。</li>
<li><strong>问题</strong>：如果隔离性未得到保证，可能导致数据不一致。</li>
</ul>
</li>
<li><p><strong>持久性（Durability）</strong>：</p>
<ul>
<li>一旦事务提交，其对数据库的修改必须永久保存，即使系统崩溃。</li>
<li><strong>解决方法</strong>：使用日志或稳定存储。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="14-3-事务的状态"><a href="#14-3-事务的状态" class="headerlink" title="14.3 事务的状态"></a>14.3 事务的状态</h3><p><strong>事务的生命周期</strong>由以下几种状态组成：</p>
<ul>
<li><strong>活动状态（Active）</strong>：事务正在执行。</li>
<li><strong>部分提交状态（Partially Committed）</strong>：事务的最后一条语句已经执行，但尚未完成提交。</li>
<li><strong>失败状态（Failed）</strong>：事务由于某种原因无法继续。</li>
<li><strong>中止状态（Aborted）</strong>：事务被回滚，数据库恢复到事务开始时的状态。</li>
<li><strong>提交状态（Committed）</strong>：事务成功完成，所有修改被永久保存。</li>
</ul>
<p><strong>例子</strong>：  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">50</span> <span class="keyword">WHERE</span> <span class="keyword">no</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">50</span> <span class="keyword">WHERE</span> <span class="keyword">no</span> <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果在第一条<code>UPDATE</code>执行后系统崩溃，事务的<strong>原子性</strong>和<strong>一致性</strong>会受影响。</li>
</ul>
<hr>
<h3 id="14-4-调度与并发执行"><a href="#14-4-调度与并发执行" class="headerlink" title="14.4 调度与并发执行"></a>14.4 调度与并发执行</h3><h4 id="调度（Schedule）"><a href="#调度（Schedule）" class="headerlink" title="调度（Schedule）"></a>调度（Schedule）</h4><ul>
<li><p>调度是指事务中所有操作按照时间顺序执行的过程。</p>
</li>
<li><p><strong>串行调度</strong>：</p>
<ul>
<li>一个事务完成后再执行下一个事务。</li>
<li>保证一致性，但效率低。</li>
</ul>
</li>
<li><p><strong>并发调度</strong>：</p>
<ul>
<li>多个事务交错执行，提高资源利用率和响应时间。</li>
</ul>
</li>
</ul>
<h4 id="并发执行的优点"><a href="#并发执行的优点" class="headerlink" title="并发执行的优点"></a>并发执行的优点</h4><ol>
<li>提高处理器和磁盘的利用率。</li>
<li>减少事务的平均响应时间。</li>
</ol>
<h4 id="并发调度的问题"><a href="#并发调度的问题" class="headerlink" title="并发调度的问题"></a>并发调度的问题</h4><p>如果未正确处理并发调度，可能导致以下数据不一致性：</p>
<ol>
<li><p><strong>丢失修改</strong>：</p>
<ul>
<li><p>两个事务同时修改同一数据，一个事务的修改被另一个事务覆盖。</p>
</li>
<li><p><strong>例子</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">T1: read(A); A :<span class="operator">=</span> A <span class="operator">+</span> <span class="number">100</span>; write(A);</span><br><span class="line">T2: read(A); A :<span class="operator">=</span> A <span class="operator">+</span> <span class="number">200</span>; write(A);</span><br></pre></td></tr></table></figure>

<p>如果<code>T1</code>和<code>T2</code>同时执行，<code>T2</code>的写入会覆盖<code>T1</code>的结果，导致<code>T1</code>的修改丢失。</p>
</li>
</ul>
</li>
<li><p><strong>不可重复读</strong>：</p>
<ul>
<li><p>一个事务在两次读取同一数据时，数据值发生了变化。</p>
</li>
<li><p><strong>例子</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">T1: read(A); print(A); read(A); print(A);</span><br><span class="line">T2: read(A); A :<span class="operator">=</span> A <span class="operator">+</span> <span class="number">100</span>; write(A);</span><br></pre></td></tr></table></figure>

<p><code>T1</code>读取两次<code>A</code>的值可能不同。</p>
</li>
</ul>
</li>
<li><p><strong>读“脏”数据</strong>：</p>
<ul>
<li><p>一个事务<code>T2</code>读取了另一个事务<code>T1</code>未提交的数据，如果<code>T1</code>回滚，则<code>T2</code>读取的数据无效。</p>
</li>
<li><p><strong>例子</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">T1: read(A); A :<span class="operator">=</span> A <span class="operator">+</span> <span class="number">100</span>; write(A); <span class="keyword">rollback</span>;</span><br><span class="line">T2: read(A); print(A);</span><br></pre></td></tr></table></figure>

<p><code>T2</code>读取了<code>T1</code>未提交的修改，导致读“脏”数据。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="14-5-可串行化（Serializability）"><a href="#14-5-可串行化（Serializability）" class="headerlink" title="14.5 可串行化（Serializability）"></a>14.5 可串行化（Serializability）</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>一个调度是<strong>可串行化的</strong>，如果它的执行效果与某个串行调度相同。</p>
<ul>
<li>可串行化是并发调度的正确性准则。</li>
</ul>
<h4 id="冲突可串行化（Conflict-Serializability）"><a href="#冲突可串行化（Conflict-Serializability）" class="headerlink" title="冲突可串行化（Conflict Serializability）"></a>冲突可串行化（Conflict Serializability）</h4><ul>
<li>如果一个调度可以通过交换非冲突操作转换为串行调度，则该调度是冲突可串行化的。</li>
<li><strong>冲突的定义</strong>：<ul>
<li>两个操作访问同一数据，且至少有一个是写操作：<ul>
<li><code>read(Q) vs write(Q)</code>：冲突。</li>
<li><code>write(Q) vs write(Q)</code>：冲突。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="检测冲突可串行化"><a href="#检测冲突可串行化" class="headerlink" title="检测冲突可串行化"></a>检测冲突可串行化</h4><p>通过<strong>优先图（Precedence Graph）</strong>检测：</p>
<ol>
<li>图中每个节点表示一个事务。</li>
<li>如果事务<code>Ti</code>的操作在事务<code>Tj</code>之前访问了数据，则添加一条从<code>Ti</code>到<code>Tj</code>的边。</li>
<li><strong>判断方法</strong>：如果优先图无环，则调度是冲突可串行化的。</li>
</ol>
<p><strong>例子</strong>：  </p>
<ul>
<li><p>调度：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">T1: read(A); write(A);</span><br><span class="line">T2: read(A); write(A);</span><br></pre></td></tr></table></figure>

<ul>
<li>优先图：<code>T1 → T2</code>，无环，因此可串行化。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="14-6-恢复性调度"><a href="#14-6-恢复性调度" class="headerlink" title="14.6 恢复性调度"></a>14.6 恢复性调度</h3><h4 id="恢复性（Recoverable）"><a href="#恢复性（Recoverable）" class="headerlink" title="恢复性（Recoverable）"></a>恢复性（Recoverable）</h4><p>如果事务<code>Tj</code>依赖于事务<code>Ti</code>写入的数据，则<code>Tj</code>必须在<code>Ti</code>提交后才能提交。</p>
<ul>
<li><strong>问题</strong>：如果<code>Tj</code>在<code>Ti</code>回滚之前提交，则可能导致不一致。</li>
</ul>
<h4 id="级联回滚（Cascading-Rollback）"><a href="#级联回滚（Cascading-Rollback）" class="headerlink" title="级联回滚（Cascading Rollback）"></a>级联回滚（Cascading Rollback）</h4><ul>
<li>一个事务的失败可能导致多个事务回滚。</li>
<li><strong>避免方法</strong>：<strong>无级联调度（Cascadeless Schedule）</strong>，要求<code>Tj</code>读取<code>Ti</code>的数据时，<code>Ti</code>必须已提交。</li>
</ul>
<hr>
<h3 id="14-7-事务隔离级别"><a href="#14-7-事务隔离级别" class="headerlink" title="14.7 事务隔离级别"></a>14.7 事务隔离级别</h3><p>SQL-92定义了四种隔离级别，允许不同程度的并发性：</p>
<ol>
<li><p><strong>Serializable（可串行化）</strong>：</p>
<ul>
<li>最严格的隔离级别，保证事务调度可串行化。</li>
</ul>
</li>
<li><p><strong>Repeatable Read（可重复读）</strong>：</p>
<ul>
<li>防止不可重复读，但无法避免幻影读。</li>
</ul>
</li>
<li><p><strong>Read Committed（读已提交）</strong>：</p>
<ul>
<li>只能读取已提交的数据，可能导致不可重复读。</li>
</ul>
</li>
<li><p><strong>Read Uncommitted（读未提交）</strong>：</p>
<ul>
<li>允许读取未提交的数据，可能导致读“脏”数据。</li>
</ul>
</li>
</ol>
<p><strong>例子解析</strong>：<br>事务1：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> accounts <span class="keyword">WHERE</span> balance <span class="operator">&gt;</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>

<p>事务2：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果隔离级别是<code>Read Uncommitted</code>，事务1可能读取到事务2未提交的结果。</li>
</ul>
<hr>
<hr>
<h2 id="第十五章-并发控制"><a href="#第十五章-并发控制" class="headerlink" title="第十五章 并发控制"></a>第十五章 并发控制</h2><h3 id="15-1-引言：并发控制的必要性"><a href="#15-1-引言：并发控制的必要性" class="headerlink" title="15.1 引言：并发控制的必要性"></a>15.1 引言：并发控制的必要性</h3><ul>
<li><strong>目标</strong>：在不预先知道整个调度的情况下，确保所有执行调度都是正确的（即可串行化的）。</li>
<li><strong>挑战</strong>：<ol>
<li><strong>数据一致性</strong>：多事务并发执行时，可能导致数据不一致。</li>
<li><strong>事务隔离性</strong>：必须避免事务间的互相干扰。</li>
</ol>
</li>
<li><strong>解决方案</strong>：<ul>
<li>使用并发控制协议，如<strong>锁机制</strong>、<strong>时间戳协议</strong>、<strong>多版本控制</strong>等。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="15-2-基于锁的并发控制"><a href="#15-2-基于锁的并发控制" class="headerlink" title="15.2 基于锁的并发控制"></a>15.2 基于锁的并发控制</h3><h4 id="2-1-锁的基本概念"><a href="#2-1-锁的基本概念" class="headerlink" title="2.1 锁的基本概念"></a>2.1 锁的基本概念</h4><ul>
<li><p><strong>定义</strong>：锁是控制数据项并发访问的一种机制。</p>
</li>
<li><p><strong>两种锁模式</strong>：</p>
<ol>
<li><strong>共享锁（S锁）</strong>：允许事务读取数据，但不允许修改。</li>
<li><strong>排它锁（X锁）</strong>：允许事务读取和修改数据。</li>
</ol>
</li>
<li><p><strong>锁兼容矩阵</strong>：</p>
<table>
<thead>
<tr>
<th>请求锁类型</th>
<th>已持有锁类型</th>
<th>兼容性</th>
</tr>
</thead>
<tbody><tr>
<td>S</td>
<td>S</td>
<td>是</td>
</tr>
<tr>
<td>S</td>
<td>X</td>
<td>否</td>
</tr>
<tr>
<td>X</td>
<td>S</td>
<td>否</td>
</tr>
<tr>
<td>X</td>
<td>X</td>
<td>否</td>
</tr>
</tbody></table>
</li>
</ul>
<p><strong>例子</strong>：<br>事务<code>T2</code>读取两个数据项：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">T2: lock-S(A); read(A); unlock(A);</span><br><span class="line">    lock-S(B); read(B); unlock(B);</span><br><span class="line">    display(A + B)</span><br></pre></td></tr></table></figure>

<p>这种方式不能保证<strong>可串行化</strong>，因为没有控制事务间的交互。</p>
<hr>
<h4 id="2-2-两阶段锁协议（2PL）"><a href="#2-2-两阶段锁协议（2PL）" class="headerlink" title="2.2 两阶段锁协议（2PL）"></a>2.2 两阶段锁协议（2PL）</h4><ul>
<li><p><strong>定义</strong>：一种确保冲突可串行化的协议，分为两个阶段：</p>
<ol>
<li><strong>增长阶段</strong>：事务可以获取锁，但不能释放锁。</li>
<li><strong>收缩阶段</strong>：事务可以释放锁，但不能获取新锁。</li>
</ol>
</li>
<li><p><strong>关键点</strong>：事务的“锁点”（获取最后一个锁的时间）决定了事务的顺序。</p>
</li>
</ul>
<p><strong>例子</strong>：</p>
<ol>
<li><p>符合两阶段锁协议：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">T1: lock-S(B); lock-X(A); read(B); read(A);</span><br><span class="line">    unlock(B); write(A); unlock(A)</span><br></pre></td></tr></table></figure>
</li>
<li><p>不符合两阶段锁协议：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">T1: lock-S(B); read(B); unlock(B);</span><br><span class="line">    lock-X(A); read(A); write(A); unlock(A)</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>扩展</strong>：</p>
<ol>
<li><strong>严格两阶段锁协议</strong>：事务直到提交或回滚后才释放其所有的排它锁，避免了<strong>级联回滚</strong>。</li>
<li><strong>严格强制两阶段锁协议</strong>：事务直到提交或回滚后才释放所有的锁，保证了事务的可恢复性和串行化顺序。</li>
</ol>
<hr>
<h4 id="2-3-死锁处理"><a href="#2-3-死锁处理" class="headerlink" title="2.3 死锁处理"></a>2.3 死锁处理</h4><ul>
<li><p><strong>死锁</strong>：当一组事务彼此等待对方释放锁时，会导致系统无法继续执行。</p>
</li>
<li><p><strong>死锁预防策略</strong>：</p>
<ol>
<li><strong>等待-死（Wait-Die）</strong>：较老的事务可以等待较新的事务；较新的事务必须回滚。</li>
<li><strong>伤害-等待（Wound-Wait）</strong>：较老的事务会中止较新的事务；较新的事务可以等待较老的事务。</li>
</ol>
</li>
<li><p><strong>死锁检测</strong>：</p>
<ul>
<li>使用<strong>等待图</strong>，如果图中存在环，则表示发生死锁。</li>
</ul>
</li>
<li><p><strong>死锁恢复</strong>：</p>
<ul>
<li>回滚代价最小的事务以打破死锁。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="15-3-基于时间戳的并发控制"><a href="#15-3-基于时间戳的并发控制" class="headerlink" title="15.3 基于时间戳的并发控制"></a>15.3 基于时间戳的并发控制</h3><h4 id="3-1-时间戳协议"><a href="#3-1-时间戳协议" class="headerlink" title="3.1 时间戳协议"></a>3.1 时间戳协议</h4><ul>
<li><strong>时间戳</strong>：每个事务在开始时分配一个唯一的时间戳（TS）。</li>
<li><strong>规则</strong>：<ol>
<li>如果<code>TS(Ti) &lt; TS(Tj)</code>，则系统必须确保<code>Ti</code>的操作在<code>Tj</code>之前执行。</li>
<li>每个数据项维护两个时间戳：<ul>
<li>**W-timestamp(Q)**：最后写入<code>Q</code>的事务的时间戳。</li>
<li>**R-timestamp(Q)**：最后读取<code>Q</code>的事务的时间戳。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><strong>读操作规则</strong>：</p>
<ol>
<li>如果<code>TS(Ti) &lt; W-timestamp(Q)</code>，表示<code>Ti</code>试图读取已被覆盖的数据，<code>Ti</code>回滚。</li>
<li>如果<code>TS(Ti) &gt;= W-timestamp(Q)</code>，执行读取操作，并更新<code>R-timestamp(Q)</code>。</li>
</ol>
<p><strong>写操作规则</strong>：</p>
<ol>
<li>如果<code>TS(Ti) &lt; R-timestamp(Q)</code>，表示<code>Ti</code>生成的值已经被其他事务读取，<code>Ti</code>回滚。</li>
<li>如果<code>TS(Ti) &lt; W-timestamp(Q)</code>，表示<code>Ti</code>试图写入过期数据，<code>Ti</code>回滚。</li>
<li>否则，执行写操作，并更新<code>W-timestamp(Q)</code>。</li>
</ol>
<p><strong>优点</strong>：</p>
<ul>
<li>保证了可串行化。</li>
<li>避免死锁（因为没有事务等待）。</li>
</ul>
<h4 id="3-2-Thomas写规则"><a href="#3-2-Thomas写规则" class="headerlink" title="3.2 Thomas写规则"></a>3.2 Thomas写规则</h4><ul>
<li><strong>改进</strong>：当事务试图写入过期值时，直接忽略写操作，而不是回滚事务。</li>
<li><strong>优势</strong>：允许更多的并发调度，支持一些不可冲突串行化的调度。</li>
</ul>
<hr>
<h3 id="15-4-多版本并发控制（MVCC）"><a href="#15-4-多版本并发控制（MVCC）" class="headerlink" title="15.4 多版本并发控制（MVCC）"></a>15.4 多版本并发控制（MVCC）</h3><h4 id="4-1-多版本协议的核心思想"><a href="#4-1-多版本协议的核心思想" class="headerlink" title="4.1 多版本协议的核心思想"></a>4.1 多版本协议的核心思想</h4><ul>
<li>数据库维护每个数据项的多个版本。</li>
<li><strong>写入</strong>：创建新版本。</li>
<li><strong>读取</strong>：根据事务的时间戳读取适当的版本。</li>
</ul>
<h4 id="4-2-多版本时间戳排序（MVTO）"><a href="#4-2-多版本时间戳排序（MVTO）" class="headerlink" title="4.2 多版本时间戳排序（MVTO）"></a>4.2 多版本时间戳排序（MVTO）</h4><ul>
<li><p>每个数据项的版本包含：</p>
<ol>
<li><strong>内容</strong>：版本的值。</li>
<li><strong>W-timestamp</strong>：创建该版本的事务时间戳。</li>
<li><strong>R-timestamp</strong>：读取该版本的最大事务时间戳。</li>
</ol>
</li>
<li><p><strong>规则</strong>：</p>
<ol>
<li><strong>读取</strong>：选择满足条件的最新版本。</li>
<li><strong>写入</strong>：<ul>
<li>如果<code>TS(Ti) &lt; R-timestamp(Qk)</code>，则回滚事务。</li>
<li>否则，创建新版本。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>读取操作永不等待，提高了并发性。</li>
<li>保证了可串行化。</li>
</ul>
<h4 id="4-3-快照隔离（Snapshot-Isolation-SI）"><a href="#4-3-快照隔离（Snapshot-Isolation-SI）" class="headerlink" title="4.3 快照隔离（Snapshot Isolation, SI）"></a>4.3 快照隔离（Snapshot Isolation, SI）</h4><ul>
<li><p><strong>工作原理</strong>：</p>
<ul>
<li>每个事务读取开始时的“快照”数据。</li>
<li>写操作遵循<strong>第一个提交者获胜（First-Committer-Wins）</strong>规则。</li>
</ul>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li>读操作不会阻塞，提高了读性能。</li>
<li>写操作避免冲突。</li>
</ul>
</li>
<li><p><strong>不足</strong>：</p>
<ul>
<li>可能导致非串行化调度（如丢失更新）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="15-5-其他并发控制协议"><a href="#15-5-其他并发控制协议" class="headerlink" title="15.5 其他并发控制协议"></a>15.5 其他并发控制协议</h3><h4 id="5-1-图锁协议"><a href="#5-1-图锁协议" class="headerlink" title="5.1 图锁协议"></a>5.1 图锁协议</h4><ul>
<li><p>基于数据项的部分顺序关系（有向无环图）。</p>
</li>
<li><p><strong>规则</strong>：</p>
<ul>
<li>事务必须按规定的顺序访问数据。</li>
</ul>
</li>
<li><p><strong>优点</strong>：避免死锁，增加并发性。</p>
</li>
<li><p><strong>缺点</strong>：可能需要锁定未访问的数据，增加开销。</p>
</li>
</ul>
<h4 id="5-2-多粒度锁"><a href="#5-2-多粒度锁" class="headerlink" title="5.2 多粒度锁"></a>5.2 多粒度锁</h4><ul>
<li><p>数据项可分为多种粒度（如数据库→表→记录）。</p>
</li>
<li><p><strong>意向锁</strong>：</p>
<ul>
<li><strong>IS（意向共享）</strong>：表示将对数据的子节点加共享锁。</li>
<li><strong>IX（意向排它）</strong>：表示将对数据的子节点加排它锁。</li>
<li><strong>SIX（共享且意向排它）</strong>：当前节点为共享锁，子节点可能加排它锁。</li>
</ul>
</li>
<li><p><strong>优点</strong>：提高并发性，减少锁管理开销。</p>
</li>
</ul>
<hr>
<h3 id="15-6-总结"><a href="#15-6-总结" class="headerlink" title="15.6 总结"></a>15.6 总结</h3><p>本章介绍了数据库并发控制的核心机制和协议，包括基于锁的控制、时间戳协议和多版本并发控制。</p>
<p><strong>重点内容</strong>：</p>
<ol>
<li>两阶段锁协议及其扩展（严格2PL、强制2PL）。</li>
<li>时间戳协议和Thomas写规则。</li>
<li>多版本控制中的快照隔离（SI）。</li>
<li>死锁的检测与预防。</li>
</ol>
<p><strong>实例分析</strong>：通过多个调度示例，详细阐述了并发控制协议在实际场景中的应用及其优缺点。</p>
<p><strong>关键思想</strong>：在保证事务ACID特性的基础上，最大化并发性和系统性能。</p>
<hr>
<hr>
<h2 id="第十六章-恢复系统"><a href="#第十六章-恢复系统" class="headerlink" title="第十六章 恢复系统"></a>第十六章 恢复系统</h2><h3 id="16-1-恢复系统的目标"><a href="#16-1-恢复系统的目标" class="headerlink" title="16.1 恢复系统的目标"></a>16.1 恢复系统的目标</h3><ul>
<li><strong>核心问题</strong>：在系统发生故障时，如何保证数据库的一致性和事务的ACID特性（原子性、一致性、隔离性、持久性）。</li>
<li><strong>恢复算法的两部分</strong>：<ol>
<li><strong>正常事务处理期间的准备</strong>：<ul>
<li>记录足够的信息以便在故障发生后能够恢复。</li>
</ul>
</li>
<li><strong>故障后的恢复操作</strong>：<ul>
<li>将数据库恢复到一致状态。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="16-2-故障分类"><a href="#16-2-故障分类" class="headerlink" title="16.2 故障分类"></a>16.2 故障分类</h3><ol>
<li><p><strong>事务故障</strong>：</p>
<ul>
<li><strong>逻辑错误</strong>：由于内部错误（如违反约束条件）导致事务无法完成。</li>
<li><strong>系统错误</strong>：如死锁，数据库系统需要终止某个事务。</li>
</ul>
</li>
<li><p><strong>系统崩溃</strong>：</p>
<ul>
<li>由于硬件或软件故障导致系统崩溃。</li>
<li><strong>假设</strong>：非易失性存储的数据不会被系统崩溃破坏（<strong>Fail-Stop假设</strong>）。</li>
</ul>
</li>
<li><p><strong>磁盘故障</strong>：</p>
<ul>
<li>硬盘损坏或部分数据丢失。</li>
<li>使用校验和检测磁盘故障。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="16-3-存储结构"><a href="#16-3-存储结构" class="headerlink" title="16.3 存储结构"></a>16.3 存储结构</h3><ol>
<li><p><strong>易失性存储</strong>：</p>
<ul>
<li>不会在系统崩溃后保留数据。</li>
<li>例如：主存、缓存。</li>
</ul>
</li>
<li><p><strong>非易失性存储</strong>：</p>
<ul>
<li>系统崩溃后保留数据。</li>
<li>例如：磁盘、闪存。</li>
</ul>
</li>
<li><p><strong>稳定存储</strong>：</p>
<ul>
<li>理想化的存储，能够抵抗所有故障。</li>
<li><strong>实现方式</strong>：保持多个副本（如RAID系统）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="16-4-日志和恢复机制"><a href="#16-4-日志和恢复机制" class="headerlink" title="16.4 日志和恢复机制"></a>16.4 日志和恢复机制</h3><h4 id="4-1-日志记录"><a href="#4-1-日志记录" class="headerlink" title="4.1 日志记录"></a>4.1 日志记录</h4><ul>
<li><strong>日志的作用</strong>：记录事务的操作，以便在系统崩溃后进行恢复。</li>
<li><strong>日志记录方式</strong>：<ol>
<li><strong>事务开始</strong>：<code>&lt;Ti start&gt;</code>。</li>
<li><strong>写操作</strong>：<code>&lt;Ti, X, V1, V2&gt;</code>，记录数据项<code>X</code>的旧值<code>V1</code>和新值<code>V2</code>。</li>
<li><strong>事务提交</strong>：<code>&lt;Ti commit&gt;</code>。</li>
</ol>
</li>
</ul>
<p><strong>例子</strong>：<br>事务<code>T0</code>将$50从账户A转移到账户B：</p>
<ol>
<li><p>日志记录：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;T0 start&gt;</span><br><span class="line">&lt;T0, A, 1000, 950&gt;</span><br><span class="line">&lt;T0, B, 2000, 2050&gt;</span><br><span class="line">&lt;T0 commit&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果系统崩溃：</p>
<ul>
<li>若<code>&lt;T0 commit&gt;</code>存在，则需要重做（Redo）。</li>
<li>若<code>&lt;T0 commit&gt;</code>不存在，则需要回滚（Undo）。</li>
</ul>
</li>
</ol>
<h4 id="4-2-Undo和Redo操作"><a href="#4-2-Undo和Redo操作" class="headerlink" title="4.2 Undo和Redo操作"></a>4.2 Undo和Redo操作</h4><ol>
<li><p><strong>Undo（回滚）</strong>：</p>
<ul>
<li>将事务所做的修改恢复为旧值。</li>
<li>写入补偿日志记录：<code>&lt;Ti, X, V1&gt;</code>。</li>
</ul>
</li>
<li><p><strong>Redo（重做）</strong>：</p>
<ul>
<li>将事务提交的修改重新应用于数据库。</li>
</ul>
</li>
</ol>
<p><strong>恢复规则</strong>：</p>
<ul>
<li>需要<strong>Undo</strong>：日志中有<code>&lt;Ti start&gt;</code>但没有<code>&lt;Ti commit&gt;</code>。</li>
<li>需要<strong>Redo</strong>：日志中有<code>&lt;Ti start&gt;</code>且有<code>&lt;Ti commit&gt;</code>。</li>
</ul>
<h4 id="4-3-恢复算法"><a href="#4-3-恢复算法" class="headerlink" title="4.3 恢复算法"></a>4.3 恢复算法</h4><ol>
<li><p><strong>Redo阶段</strong>：</p>
<ul>
<li>从最近的检查点开始，向前扫描日志，对所有提交的事务重做操作。</li>
</ul>
</li>
<li><p><strong>Undo阶段</strong>：</p>
<ul>
<li>从日志末尾向后扫描，对未完成的事务进行回滚操作。</li>
</ul>
</li>
</ol>
<p><strong>示例</strong>：<br>假设以下日志记录：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;checkpoint L=&#123;T0, T1&#125;&gt;</span><br><span class="line">&lt;T0 start&gt;</span><br><span class="line">&lt;T0, A, 1000, 950&gt;</span><br><span class="line">&lt;T0, B, 2000, 2050&gt;</span><br><span class="line">&lt;T1 start&gt;</span><br><span class="line">&lt;T1, C, 700, 600&gt;</span><br><span class="line">&lt;T0 commit&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>恢复步骤：<ol>
<li>Redo：重做<code>T0</code>的操作，因为<code>T0</code>已提交。</li>
<li>Undo：回滚<code>T1</code>的操作，因为<code>T1</code>未提交。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="16-5-检查点（Checkpoint）"><a href="#16-5-检查点（Checkpoint）" class="headerlink" title="16.5 检查点（Checkpoint）"></a>16.5 检查点（Checkpoint）</h3><h4 id="5-1-检查点的作用"><a href="#5-1-检查点的作用" class="headerlink" title="5.1 检查点的作用"></a>5.1 检查点的作用</h4><ul>
<li>检查点减少了恢复时需要处理的日志记录长度。</li>
<li><strong>步骤</strong>：<ol>
<li>将内存中的日志记录写入稳定存储。</li>
<li>将修改过的缓冲区块写回磁盘。</li>
<li>写入<code>&lt;checkpoint L&gt;</code>日志记录，其中<code>L</code>是所有活跃事务的列表。</li>
</ol>
</li>
</ul>
<h4 id="5-2-恢复时的优化"><a href="#5-2-恢复时的优化" class="headerlink" title="5.2 恢复时的优化"></a>5.2 恢复时的优化</h4><ul>
<li>从最近的检查点开始扫描日志。</li>
<li>只需要处理检查点之后开始的事务，之前的日志可被忽略。</li>
</ul>
<p><strong>例子</strong>：<br>日志：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;checkpoint L=&#123;T1, T2&#125;&gt;</span><br><span class="line">&lt;T1 start&gt;</span><br><span class="line">&lt;T1, A, 100, 200&gt;</span><br><span class="line">&lt;T1 commit&gt;</span><br><span class="line">&lt;T2 start&gt;</span><br><span class="line">&lt;T2, B, 300, 400&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>T1</code>已提交，无需处理。</li>
<li><code>T2</code>尚未完成，需要回滚。</li>
</ul>
<hr>
<h3 id="16-6-Write-Ahead-Logging-WAL"><a href="#16-6-Write-Ahead-Logging-WAL" class="headerlink" title="16.6 Write-Ahead Logging (WAL)"></a>16.6 Write-Ahead Logging (WAL)</h3><ul>
<li><strong>规则</strong>：写入数据块之前，必须先将对应的日志记录写入稳定存储。</li>
<li><strong>目的</strong>：保证即使系统崩溃，也能通过日志恢复数据。</li>
</ul>
<hr>
<h3 id="16-7-数据库缓冲管理"><a href="#16-7-数据库缓冲管理" class="headerlink" title="16.7 数据库缓冲管理"></a>16.7 数据库缓冲管理</h3><ul>
<li><strong>No-Force策略</strong>：事务提交时，不强制将数据块写回磁盘。</li>
<li><strong>Steal策略</strong>：允许未提交事务修改的数据块写回磁盘，但必须遵守WAL规则。</li>
</ul>
<p><strong>步骤</strong>：</p>
<ol>
<li>写入日志记录。</li>
<li>刷新日志到稳定存储。</li>
<li>将数据块写回磁盘。</li>
</ol>
<hr>
<h3 id="16-8-模糊检查点（Fuzzy-Checkpointing）"><a href="#16-8-模糊检查点（Fuzzy-Checkpointing）" class="headerlink" title="16.8 模糊检查点（Fuzzy Checkpointing）"></a>16.8 模糊检查点（Fuzzy Checkpointing）</h3><ul>
<li><strong>避免长时间中断</strong>：允许事务在检查点期间继续运行。</li>
<li><strong>步骤</strong>：<ol>
<li>暂停更新，写入<code>&lt;checkpoint L&gt;</code>日志记录。</li>
<li>记录所有修改过的缓冲区块。</li>
<li>恢复更新，将缓冲区块逐步写回磁盘。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="16-9-远程备份系统"><a href="#16-9-远程备份系统" class="headerlink" title="16.9 远程备份系统"></a>16.9 远程备份系统</h3><h4 id="9-1-目的"><a href="#9-1-目的" class="headerlink" title="9.1 目的"></a>9.1 目的</h4><ul>
<li>提供高可用性，即使主站点发生故障，事务处理仍可在备份站点继续。</li>
</ul>
<h4 id="9-2-工作原理"><a href="#9-2-工作原理" class="headerlink" title="9.2 工作原理"></a>9.2 工作原理</h4><ol>
<li>主站点将日志记录传输到备份站点。</li>
<li>备份站点应用日志更新本地数据库。</li>
<li>主站点故障后，备份站点接管事务处理。</li>
</ol>
<h4 id="9-3-提交策略"><a href="#9-3-提交策略" class="headerlink" title="9.3 提交策略"></a>9.3 提交策略</h4><ul>
<li><strong>One-Safe</strong>：主站点提交后即可返回结果，但可能导致更新丢失。</li>
<li><strong>Two-Very-Safe</strong>：主备站点同时记录提交，可靠但延迟高。</li>
<li><strong>Two-Safe</strong>：在主站点和备份站点之间权衡性能和可靠性。</li>
</ul>
<hr>
<h3 id="16-10-总结"><a href="#16-10-总结" class="headerlink" title="16.10 总结"></a>16.10 总结</h3><p>本章详细讲解了数据库恢复的核心机制，包括日志记录、Undo&#x2F;Redo操作、检查点和远程备份系统。通过具体的例子说明了如何在事务失败或系统崩溃后恢复数据库的一致性。重难点如下：</p>
<ul>
<li><strong>日志记录与WAL规则</strong>：日志是恢复的核心，必须首先写入稳定存储。</li>
<li><strong>检查点的优化作用</strong>：减少日志扫描的范围，加速恢复。</li>
<li><strong>恢复算法的两个阶段</strong>：Redo和Undo。</li>
<li><strong>远程备份系统</strong>：提高系统的可用性和容错能力。</li>
</ul>
<p>通过这些机制，数据库系统能够在故障后快速恢复，同时保证事务的ACID特性。</p>
<hr>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Lavoisier</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://Lavoisier7.github.io/2024/11/25/Database_Principle/">http://Lavoisier7.github.io/2024/11/25/Database_Principle/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Lavoisier</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/SQL-Server/">
                                    <span class="chip bg-color">SQL Server</span>
                                </a>
                            
                                <a href="/tags/Database/">
                                    <span class="chip bg-color">Database</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">Your appreciation is my driving force for progress</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="https://unpkg.com/valine/dist/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'j5FifBJFtHJ7QOATVuihjWvp-gzGzoHsz',
        appKey: 'GRwn2SERkTOROu36TR5Ux6Nj',
        serverURLs: 'https://j5FifBJFtHJ7QOATVuihjWvp-gzGzoHsz.leancloud.app',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'true' === 'true',
        avatar: 'monsterid',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: 'circumspection'
    });
</script>

<!--酷Q推送-->


    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2024/11/26/Computer_Architecture/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="Computer Architecture">
                        
                        <span class="card-title">Computer Architecture</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            进阶版计算机组成原理
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2024-11-26
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Computer-Science/" class="post-category">
                                    Computer Science
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/elective/">
                        <span class="chip bg-color">elective</span>
                    </a>
                    
                    <a href="/tags/CA/">
                        <span class="chip bg-color">CA</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2024/11/24/Marcel_Proust/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/3.jpg" class="responsive-img" alt="Marcel Proust">
                        
                        <span class="card-title">Marcel Proust</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            前半生出入社交名利场，后半生缠绵病榻
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-11-24
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Literary-giants/" class="post-category">
                                    Literary giants
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Marcel-Proust/">
                        <span class="chip bg-color">Marcel Proust</span>
                    </a>
                    
                    <a href="/tags/In-Search-of-Lost-Time/">
                        <span class="chip bg-color">In Search of Lost Time</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE' || selection.getRangeAt(0).commonAncestorContainer.nodeName === 'CODE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: D<br />'
            + '文章作者: Lavoisier<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者Lavoisier所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('1'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2024-2025</span>
            
            <a href="/about" target="_blank">Lavoisier</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
                <span id="translate">|&nbsp;繁/简：</span><a id="translateLink" href="javascript:translatePage();">繁</a>
            
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">93.1k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2024";
                        var startMonth = "11";
                        var startDate = "19";
                        var startHour = "20";
                        var startMinute = "30";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/Lavoisier7" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:wzd6@foxmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
        <script type="text/javascript" src="/js/tw_cn.js"></script>
        <script type="text/javascript">
          var defaultEncoding = 2; //网站编写字体是否繁体，1-繁体，2-简体
          var translateDelay = 0; //延迟时间,若不在前, 要设定延迟翻译时间, 如100表示100ms,默认为0
          var cookieDomain = "http://Lavoisier7.github.io"; //Cookie地址, 一定要设定, 通常为你的网址
          var msgToTraditionalChinese = "繁"; //此处可以更改为你想要显示的文字
          var msgToSimplifiedChinese = "简"; //同上，但两处均不建议更改
          var translateButtonId = "translateLink"; //默认互换id
          translateInitilization();
        </script>
    
    
    
        
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/sakura.js"><\/script>');
            }
        </script>
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    
    
    <script type="text/javascript" size="150" alpha='0.6'
        zIndex="-1" src="/libs/background/ribbon-refresh.min.js" async="async"></script>
    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    

</body>

</html>
